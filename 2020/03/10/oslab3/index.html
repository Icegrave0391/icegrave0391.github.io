<!DOCTYPE html>
<html lang="zh-Hans">







<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="preconnect" href="//www.googletagmanager.com">
	<link rel="preconnect" href="//zz.bdstatic.com">
	<link rel="preconnect" href="//sp0.baidu.com">
	<link rel="preconnect" href="//www.google-analytics.com">
	<link rel="preconnect" href="//cdn1.lncld.net">
	<link rel="preconnect" href="//unpkg.com">
	<link rel="preconnect" href="//app-router.leancloud.cn">
	<link rel="preconnect" href="//9qpuwspm.api.lncld.net">
	<link rel="preconnect" href="//gravatar.loli.net">

	<title>手把手带你MIT6.828 - Lab3 | Icegrave</title>

	<meta name="HandheldFriendly" content="True">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
	<meta name="generator" content="hexo">
	<meta name="author" content="Heart-Shaped Box">
	<meta name="description" content>

	
	<meta name="keywords" content="mit6.828, memory management">
	

	
	<link rel="shortcut icon" href="https://mubai.oss-cn-hangzhou.aliyuncs.com/icon.png">
	<link rel="apple-touch-icon" href="https://mubai.oss-cn-hangzhou.aliyuncs.com/icon.png">
	

	
	<meta name="theme-color" content="#3c484e">
	<meta name="msapplication-TileColor" content="#3c484e">
	

	

	

	<meta property="og:site_name" content="Icegrave">
	<meta property="og:type" content="article">
	<meta property="og:title" content="手把手带你MIT6.828 - Lab3 | Icegrave">
	<meta property="og:description" content>
	<meta property="og:url" content="http://yoursite.com/2020/03/10/oslab3/">

	
	<meta property="article:published_time" content="2020-03-10T10:03:00+08:00"> 
	<meta property="article:author" content="Heart-Shaped Box">
	<meta property="article:published_first" content="Icegrave, /2020/03/10/oslab3/">
	

	
	
	<link rel="stylesheet" href="/css/allinonecss.min.css">

	
	
	
</head>
<body class="post-template">
	<div class="site-wrapper">
		




<header class="site-header post-site-header outer">
    <div class="inner">
        
<nav class="site-nav"> 
    <div class="site-nav-left">
        <ul class="nav">
            <li>
                
                <a href="/" title="Home">HOME</a>
                
            </li>
            
            
            <li>
                <a href="/about" title="ABOUT">ABOUT</a>
            </li>
            
            <li>
                <a href="/archives" title="ARCHIVES">ARCHIVES</a>
            </li>
            
            
        </ul> 
    </div>
    
    <div class="search-button-area">
        <a href="#search" class="search-button">Search ...</a>
    </div>
     
    <div class="site-nav-right">
        
        <a href="#search" class="search-button">Search ...</a>
         
        
<div class="social-links">
    
    <a class="social-link" title="weibo" href="https://weibo.com/" target="_blank" rel="noopener">
        <svg viewbox="0 0 1141 1024" xmlns="http://www.w3.org/2000/svg"><path d="M916.48 518.144q27.648 21.504 38.912 51.712t9.216 62.976-14.336 65.536-31.744 59.392q-34.816 48.128-78.848 81.92t-91.136 56.32-94.72 35.328-89.6 18.944-75.264 7.68-51.712 1.536-49.152-2.56-68.096-10.24-78.336-21.504-79.872-36.352-74.24-55.296-59.904-78.848q-16.384-29.696-22.016-63.488t-5.632-86.016q0-22.528 7.68-51.2t27.136-63.488 53.248-75.776 86.016-90.112q51.2-48.128 105.984-85.504t117.248-57.856q28.672-10.24 63.488-11.264t57.344 11.264q10.24 11.264 19.456 23.04t12.288 29.184q3.072 14.336 0.512 27.648t-5.632 26.624-5.12 25.6 2.048 22.528q17.408 2.048 33.792-1.536t31.744-9.216 31.232-11.776 33.28-9.216q27.648-5.12 54.784-4.608t49.152 7.68 36.352 22.016 17.408 38.4q2.048 14.336-2.048 26.624t-8.704 23.04-7.168 22.016 1.536 23.552q3.072 7.168 14.848 13.312t27.136 12.288 32.256 13.312 29.184 16.384zM658.432 836.608q26.624-16.384 53.76-45.056t44.032-64 18.944-75.776-20.48-81.408q-19.456-33.792-47.616-57.344t-62.976-37.376-74.24-19.968-80.384-6.144q-78.848 0-139.776 16.384t-105.472 43.008-72.192 60.416-38.912 68.608q-11.264 33.792-6.656 67.072t20.992 62.976 42.496 53.248 57.856 37.888q58.368 25.6 119.296 32.256t116.224 0.512 100.864-21.504 74.24-33.792zM524.288 513.024q20.48 8.192 38.912 18.432t32.768 27.648q10.24 12.288 17.92 30.72t10.752 39.424 1.536 42.496-9.728 38.912q-8.192 18.432-19.968 37.376t-28.672 35.328-40.448 29.184-57.344 18.944q-61.44 11.264-117.76-11.264t-88.064-74.752q-12.288-39.936-13.312-70.656t16.384-66.56q13.312-27.648 40.448-51.712t62.464-38.912 75.264-17.408 78.848 12.8zM361.472 764.928q37.888 3.072 57.856-18.432t21.504-48.128-15.36-47.616-52.736-16.896q-27.648 3.072-43.008 23.552t-17.408 43.52 9.728 42.496 39.424 21.504zM780.288 6.144q74.752 0 139.776 19.968t113.664 57.856 76.288 92.16 27.648 122.88q0 33.792-16.384 50.688t-35.328 17.408-35.328-14.336-16.384-45.568q0-40.96-22.528-77.824t-59.392-64.512-84.48-43.52-96.768-15.872q-31.744 0-47.104-15.36t-14.336-34.304 18.944-34.304 51.712-15.36zM780.288 169.984q95.232 0 144.384 48.64t49.152 146.944q0 30.72-10.24 43.52t-22.528 11.264-22.528-14.848-10.24-35.84q0-60.416-34.816-96.256t-93.184-35.84q-19.456 0-28.672-10.752t-9.216-23.04 9.728-23.04 28.16-10.752z"/></svg>
    </a>
    
    
    <a class="social-link" title="github" href="https://github.com/Icegrave0391" target="_blank" rel="noopener">
        <svg viewbox="0 0 1049 1024" xmlns="http://www.w3.org/2000/svg"><path d="M524.979332 0C234.676191 0 0 234.676191 0 524.979332c0 232.068678 150.366597 428.501342 358.967656 498.035028 26.075132 5.215026 35.636014-11.299224 35.636014-25.205961 0-12.168395-0.869171-53.888607-0.869171-97.347161-146.020741 31.290159-176.441729-62.580318-176.441729-62.580318-23.467619-60.841976-58.234462-76.487055-58.234463-76.487055-47.804409-32.15933 3.476684-32.15933 3.476685-32.15933 53.019436 3.476684 80.83291 53.888607 80.83291 53.888607 46.935238 79.963739 122.553122 57.365291 152.97411 43.458554 4.345855-33.897672 18.252593-57.365291 33.028501-70.402857-116.468925-12.168395-239.022047-57.365291-239.022047-259.012982 0-57.365291 20.860106-104.300529 53.888607-140.805715-5.215026-13.037566-23.467619-66.926173 5.215027-139.067372 0 0 44.327725-13.906737 144.282399 53.888607 41.720212-11.299224 86.917108-17.383422 131.244833-17.383422s89.524621 6.084198 131.244833 17.383422C756.178839 203.386032 800.506564 217.29277 800.506564 217.29277c28.682646 72.1412 10.430053 126.029806 5.215026 139.067372 33.897672 36.505185 53.888607 83.440424 53.888607 140.805715 0 201.64769-122.553122 245.975415-239.891218 259.012982 19.121764 16.514251 35.636014 47.804409 35.636015 97.347161 0 70.402857-0.869171 126.898978-0.869172 144.282399 0 13.906737 9.560882 30.420988 35.636015 25.205961 208.601059-69.533686 358.967656-265.96635 358.967655-498.035028C1049.958663 234.676191 814.413301 0 524.979332 0z"/></svg>
    </a>
    
    
    <a class="social-link" title="facebook" href="https://facebook" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

    </a>
    
    
    <a class="social-link" title="twitter" href="https://twitter.com" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

    </a>
    
    
    
    
</div>
    </div>
</nav>
    </div>
</header>


<div id="site-main" class="site-main outer" role="main">
    <div class="inner">
        <header class="post-full-header">
            <div class="post-full-meta">
                <time class="post-full-meta-date" datetime="2020-03-10T02:23:36.000Z">
                    2020-03-10
                </time>
                
                <span class="date-divider">/</span>
                
                <a href="/categories/operating-system/">operating system</a>&nbsp;&nbsp;
                
                
            </div>
            <h1 class="post-full-title">手把手带你MIT6.828 - Lab3</h1>
        </header>
        <div class="post-full ">
            
            <figure class="post-full-image" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfwldfuklj31li0u0hdu.jpg)">
            </figure>
            
            <div class="post-full-content">
                <article id="photoswipe" class="markdown-body">
                    <h1 id="Lab3-User-Environments"><a href="#Lab3-User-Environments" class="headerlink" title="Lab3 User Environments"></a>Lab3 User Environments</h1><p>官方文档: <a href="https://pdos.csail.mit.edu/6.828/2018/lec/" target="_blank" rel="noopener">lectures</a></p>
<h3 id="gt-实验介绍"><a href="#gt-实验介绍" class="headerlink" title="&gt; 实验介绍"></a>&gt; 实验介绍</h3><p>在本次实验中，我们将实现最基本的内核功能以使得一个受保护的用户模式环境（进程）可以正常运行。我们将增强jos的内核，设置一系列数据结构以追踪用户环境，创建一个单一用户环境，加载程序镜像然后执行。</p>
<p>同时我们将让jos的内核能够处理用户环境的系统调用以及其他引发的异常。</p>
<blockquote>
<p>在本次实验中，<em>环境（environment）</em>和<em>进程（process）</em>这两个术语是可以交换的，他们都表示程序运行的抽象层面。我们使用术语<em>环境</em>而非<em>进程</em>，是为了强调我们的观念：jos的<em>环境</em>以及UNIX的<em>进程</em>提供了不同的interface，而非相同的语义。</p>
</blockquote>
<h3 id="gt-实验准备"><a href="#gt-实验准备" class="headerlink" title="&gt; 实验准备"></a>&gt; 实验准备</h3><p>使用git切换分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b lab3 origin/lab3</span><br><span class="line">git merge lab2</span><br></pre></td></tr></table></figure>
<p>在这个过程中出现了冲突，我们将<code>kern/monitor.c</code>的冲突进行编辑即可。</p>
<p>实验三新增文件：</p>
<ul>
<li>inc/<ul>
<li>inc/env.h 用户模式环境的公有定义</li>
<li>inc/trap.h 陷阱处理的公有定义</li>
<li>inc/syscall.h 用户环境对内核的系统调用的公有定义</li>
<li>inc/lib.h 用户模式支持的库公有定义</li>
</ul>
</li>
<li>kern/<ul>
<li>kern/env.h 用户模式环境的内核私有定义</li>
<li>kern/env.c 用户模式环境的内核代码实现</li>
<li>kern/trap.h 内核私有的陷阱处理定义</li>
<li>kern/trap.c 陷阱处理代码</li>
<li>kern/trapentry.S 汇编语言的陷阱处理程序入口</li>
<li>kern/syscall.h 系统调用处理的内核私有定义</li>
<li>kern/syscall.c 系统调用实现代码</li>
</ul>
</li>
<li>lib/<ul>
<li>lib/Makefrag 用户模式库obj/lib/libjos.a的Makefile</li>
<li>lib/entry.S 用户环境的汇编语言入口</li>
<li>lib/libmain.c entry.S调用的用户模式库安装代码</li>
<li>lib/syscall.c 用户模式系统调用的打桩函数</li>
<li>lib/console.c 用户模式的putchar和getchar实现，提供了控制台IO</li>
<li>lib/exit.c 用户模式的exit实现</li>
<li>lib/panic.c 用户模式的panic实现</li>
</ul>
</li>
<li>user/* 检验内核实验三代码的测试程序</li>
</ul>
<p><strong>内联汇编</strong></p>
<p>在本实验中我们会频繁发现gcc的内联汇编的使用，我们必须要理解。</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/index.html" target="_blank" rel="noopener">x86内联汇编</a>中给出了详细教程。</p>
<h2 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A: User Environments and Exception Handling"></a>Part A: User Environments and Exception Handling</h2><p><code>inc/env.h</code>头文件包含了jos用户环境中的基本定义，我们需要进行阅读。kernel使用了<code>struct env</code>来追踪每一个用户环境。这个实验中我们只需要创建一个环境，尽管如此，我们将设计jos的内核以支持多用户环境。而在lab4中，我么将会用一个用户环境去<code>fork</code>其他用户环境，以利用多用户环境的特性。</p>
<p><code>kern/env.c</code>中，我们可以看到kernl维护了三个与环境有关的全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> = <span class="title">NULL</span>;</span>		<span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> = <span class="title">NULL</span>;</span>		<span class="comment">// The current env</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>	<span class="comment">// Free environment list</span></span><br></pre></td></tr></table></figure>
<p>一旦jos成功运行之后，<code>envs</code>指针将会指向一个<code>struct env</code>类型的数组用以表示系统中所有的环境。在我们的设计中，jos的内核将会允许最大数量<code>NENV</code>个环境同时激活（尽管实际上在一个特定时间里，运行的环境非常少）。<code>NENV</code>在<code>inc/env.h</code>中定义。</p>
<p>同理，jos的kernel使用<code>env_free_list</code>来维护当前所有未激活的<code>struct env</code>，这样的设计简化了环境分配和释放的过程，它们仅仅需要从该链表上进行添加或者移除。</p>
<p>kernel使用<code>curenv</code>去追踪任意时刻当前正在运行的环境。在boot启动过程中知道直到第一个环境运行的时间之前，<code>curenv</code>被设置为NULL。</p>
<h3 id="A-1-Environment-State"><a href="#A-1-Environment-State" class="headerlink" title="A.1 Environment State"></a>A.1 Environment State</h3><p><code>env</code>结构体在<code>inc.env</code>中有如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></span><br><span class="line">	<span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></span><br><span class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></span><br><span class="line">	<span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Address space</span></span><br><span class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>env_tf</code>：这是个结构体类型变量，其中<code>struct Trapframe</code>在<code>inc/trap.h</code>中定义，表示当环境不运行或者其他环境运行时，该环境被保存的寄存器值。kernel保存这些值主要用于上下文切换和现场保护。</li>
<li><code>env_link</code>：指向<code>env_free_list</code>的下一个环境成员（<code>env_free_list</code>指向链表中的第一个空闲环境）。</li>
<li><code>env_id</code>：kernel储存的用于标识该环境的唯一标识符。在用户的一个环境结束之后，kernel可能会将同样的<code>env</code>重新分配给另一个环境，但是<code>env_id</code>将是不同的。</li>
<li><code>env_parent_id</code>：存储了创建该环境的环境的<code>env_id</code>（可以理解为父亲节点），通过这个方式我们可以形成环境的’family tree’（用于安全方面的决策）</li>
<li><code>env_type</code>：用于标记特殊的环境类型。对于大部分环境，该值为<code>ENV_TYPE_USER</code>，后续的lab中将会有其他的值。</li>
<li><code>env_status</code> - 环境状态，有以下几种取值：<ul>
<li><code>ENV_FREE</code>：表明<code>struct env</code>处于空闲状态，应当在<code>env_free_list</code>上</li>
<li><code>ENV_RUNNABLE</code>：表明<code>struct env</code>代表的环境正在等待运行</li>
<li><code>ENV_RUNNING</code>：表明<code>struct env</code>代表的环境为正在运行的环境</li>
<li><code>ENV_NOT_RUNNABLE</code>：表明<code>struct env</code>代表的环境正在运行，但是没有准备好继续运行：比如等待另一个环境的IPC（进程间通信）</li>
<li><code>ENV_DYING</code>：表明<code>struct env</code>代表的环境是一个僵尸环境，僵尸环境将在下一次陷入内核的时候被释放</li>
</ul>
</li>
<li><code>env_pgdir</code>：保存了环境的页目录的内核虚拟地址。</li>
</ul>
<p>如同Unix的进程一样，jos的环境结合了线程（thread）和地址空间（address space）。线程是由<code>env_tf</code>域的被保存的寄存器值定义；地址空间是由<code>env_pgdir</code>域指向的页目录和页表定义。如果想让一个环境能够运行，kernel必须要使用保存的寄存器值和合适的地址空间来设置CPU。</p>
<p>jos的<code>struct env</code>结构和xv6的<code>struct proc</code>非常类似。两种结构都持有了用户模式的寄存器状态。然而在jos中，每一个独立的环境并不具有不同的内核栈（kernel stack），因为jos的内核中同时只能有一个运行的jos环境，也就是说jos只需要一个内核栈。</p>
<h3 id="A-2-Allocating-the-Environment-Array"><a href="#A-2-Allocating-the-Environment-Array" class="headerlink" title="A.2 Allocating the Environment Array"></a>A.2 Allocating the Environment Array</h3><p>在lab2中，我们已经在<code>mem_init()</code>的过程中为<code>pages[]</code>数组分配了内存（kernel用于追踪哪些pages是空闲的，哪些不是）。我们现在需要修改<code>mem_init()</code>函数，类似地，进一步为<code>struct Env</code>结构体数组<code>Envs</code>分配空间。</p>
<p><strong>exercise 1:</strong></p>
<p>在<code>kern/pmap.c</code>中修改<code>mem_init()</code>函数为<code>envs</code>数组分配空间，这个数组包含了<code>NENV</code>个结构体实例成员。如同<code>pages</code>一样，<code>envs</code>所读经的内存空间需要映射到用户只读区域<code>UENVS</code>之上（详见lab2的内存结构分配图以或者<code>inc/memlayout.h</code>中内存分配的定义）。</p>
<p>完成后我们可以运行<code>check_kern_pgdir()</code>来检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">uint32_t</span> envs_size = <span class="keyword">sizeof</span>(struct Env) * NENV;</span><br><span class="line">envs = boot_alloc(envs_size);</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, envs_size);</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map the 'envs' array read-only by the user at linear address UENVS</span></span><br><span class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">boot_map_region(kern_pgdir, UENVS, envs_size, PADDR(envs), PTE_U | PTE_P);</span><br></pre></td></tr></table></figure>
<p>顺利完成后，即可在qemu中看到<code>chech_kern_pgdir() succeeded!</code></p>
<h3 id="A-3-Creating-and-Running-Environments"><a href="#A-3-Creating-and-Running-Environments" class="headerlink" title="A.3 Creating and Running Environments"></a>A.3 Creating and Running Environments</h3><p>我们现在将在<code>kern/env.c</code>中编写运行用户环境的必要代码。目前为止我们还没有文件系统，我们将只能配置内核以加载一个嵌入内核中的静态二进制映像。jos内核将这个二进制镜像以ELF可执行镜像格式进行嵌入。</p>
<p>Lab3的<code>GNUMakefile</code>在<code>obj/user</code>目录中生成了一些二进制映像（binary image）。观察<code>kern/Makefrag</code>我们会发现一些链接的魔法：链接器将这些二进制文件直接装载到kernel的可执行文件中，就如同这些文件是<code>.o</code>类型的文件。同时链接器的<code>-b binary</code>选项使得这些文件以原始未被翻译的raw binary file形式，而不是普通的编译器生成的<code>.o</code>文件形式进行链接（以<code>-b binary</code>选项进行链接，这些文件并不需要是真正的ELF文件，他们甚至可以是文本文件或者图片）。</p>
<p>在建立kernel过程结束之后，我们观察<code>obj/kern/kernel.sym</code>，会注意到链接器有魔力地生成了一些有趣的符号，比如<code>_binary_obj_user_hello_start</code>，<code>_binary_obj_user_hello_end</code>以及<code>_binary_obj_user_hello_size</code>。链接器通过二进制文件的名字生成了这些符号的名字，这些符号使得内核代码能够通过某种方式引用对应的二进制文件。</p>
<p>在<code>i386_init()</code>以及<code>kern/init.c</code>中，我们将会看到我们的代码运行了装载到环境中的二进制映像。然而，用于建立用户环境的一些关键函数还并没有完成，我们需要将其完成。</p>
<p><strong>exercise 2:</strong></p>
<p>在<code>env.c</code>中，完善如下代码：</p>
<ul>
<li><code>env_init()</code></li>
</ul>
<p>初始化所有<code>envs</code>数组中的<code>struct env</code>类型的结构，然后将其添加到<code>env_free_list</code>中。同时调用<code>env_init_percpu</code>函数，该函数将配置硬件分段来将特权级不同的段分开：内核有特权级0，用户有特权级3。</p>
<blockquote>
<p>错误记录：<code>i</code>必须使用<code>int</code>类型，使用<code>size_t</code>会直接产生<code>Triple_Fault</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark all environments in 'envs' as free, set their env_ids to 0,</span></span><br><span class="line"><span class="comment">// and insert them into the env_free_list.</span></span><br><span class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></span><br><span class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></span><br><span class="line"><span class="comment">// env_alloc() returns envs[0]).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		envs[i].env_status = ENV_FREE;</span><br><span class="line">		envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">		envs[i].env_link = env_free_list;</span><br><span class="line">		env_free_list = &amp;envs[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>env_setup_vm()</code></li>
</ul>
<p>为新的用户环境建立一个虚拟内存系统（为其分配页目录同时初始化新环境内核部分的地址空间）。这里由于用户环境在<code>UTOP</code>之上的虚拟空间其实都是内核空间在这个区域的副本，在<code>UTOP</code>之下的部分在初始化过程全部可以初始为0，即我们可以直接用<code>kern_pgdir</code>中的内容为模版建立用户环境的页目录。</p>
<p>这里回顾一下lab2中<code>mem_init()</code>调用了几个<code>boot_map_regions()</code>将<code>kern_pgdir</code>内核区域的页表和地址管理全部建立起来，而并没有关心<code>UTOP</code>以下的用户区部分，所以我们这里使用<code>kern_pgdir</code>为模版，为每一个用户环境可以设置相同的内核虚拟地址空间，而用户区域的则先全部仅仅进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize the kernel virtual memory layout for environment e.</span></span><br><span class="line"><span class="comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span></span><br><span class="line"><span class="comment">// and initialize the kernel portion of the new environment's address space.</span></span><br><span class="line"><span class="comment">// Do NOT (yet) map anything into the user portion</span></span><br><span class="line"><span class="comment">// of the environment's virtual address space.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if page directory or table could not be allocated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line">	<span class="comment">//	(except at UVPT, which we've set below).</span></span><br><span class="line">  <span class="comment">// 意思是 内核区域以上的页目录是统一的，而用户区域的页表管理则由对应的环境进行分配</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></span><br><span class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line">	<span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir's</span></span><br><span class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></span><br><span class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	e -&gt; env_pgdir = (<span class="keyword">pde_t</span> *)page2kva(p);</span><br><span class="line">	p -&gt; pp_ref += <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line">	<span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>region_alloc()</code></li>
</ul>
<p>这个函数用于为环境分配物理空间。</p>
<blockquote>
<p>错误记录：注意<code>ROUNDDOWN</code>以及<code>ROUNDUP</code>的类型转换。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate len bytes of physical memory for environment env,</span></span><br><span class="line"><span class="comment">// and map it at virtual address va in the environment's address space.</span></span><br><span class="line"><span class="comment">// Does not zero or otherwise initialize the mapped pages in any way.</span></span><br><span class="line"><span class="comment">// Pages should be writable by user and kernel.</span></span><br><span class="line"><span class="comment">// Panic if any allocation attempt fails.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line">	<span class="comment">//   'va' and 'len' values that are not page-aligned.</span></span><br><span class="line">	<span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line">	<span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> start_addr = (<span class="keyword">uintptr_t</span>) ROUNDDOWN(va, PGSIZE);</span><br><span class="line">	<span class="keyword">uintptr_t</span> end_addr = (<span class="keyword">uintptr_t</span>) ROUNDUP(va + len, PGSIZE);</span><br><span class="line">	<span class="keyword">while</span>(start_addr &lt; end_addr)&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">p</span>;</span></span><br><span class="line">		p = page_alloc(ALLOC_ZERO);</span><br><span class="line">		<span class="keyword">if</span>(!p)&#123;</span><br><span class="line">			panic(<span class="string">"[region_alloc] page alloc error: %e\n"</span>, -E_NO_MEM);</span><br><span class="line">		&#125;</span><br><span class="line">		page_insert(e -&gt; env_pgdir, p, (<span class="keyword">void</span> *)start_addr, PTE_P | PTE_U | PTE_W);</span><br><span class="line">		start_addr += PGSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数完成后，我们能够为环境以物理页为单位映射到用户虚拟空间中，并且配置该环境的页目录。</p>
<ul>
<li><code>load_icore</code></li>
</ul>
<p>该函数的作用是解析ELF镜像文件，并将目标ELF镜像文件加载到环境的用户地址空间中。同时他还为这个加载进入用户空间的二进制文件创建一个程序栈。</p>
<p>根据函数的注释，我们可以按照<code>boot/main.c</code>代码加载ELF的方式获取一些提示，同时我们仍然需要了解ELF头和文件结构（在lab1中进行了讲解）：</p>
<p><img alt="image-20200302160913062" style="zoom:67%;" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcfndwkks1j30go0g9gna.jpg" data-index="0" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcfndwkks1j30go0g9gna.jpg"></p>
<p>同时在<code>inc/elf.h</code>中也有相应的结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> &#123;</span>                  <span class="comment">//对应上图的ELF头部</span></span><br><span class="line">	<span class="keyword">uint32_t</span> e_magic;	<span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">	<span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">uint16_t</span> e_type;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_machine;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_version;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_entry;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_phoff;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_shoff;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_flags;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_ehsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_phentsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_phnum;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shentsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shnum;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shstrndx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> &#123;</span>              <span class="comment">//对应上图的ELF程序头部</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_type;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_offset;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_pa;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_filesz;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_memsz;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_flags;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于ELF的详细知识仍然请移步CSAPP，有关本次实验我们只需要知道如下知识：</p>
<p>ELF头部在其二进制文件的开头部分，且通过解析ELF头部我们可以得到<code>e_phoff</code>即程序头表的位置，以及程序头表的大小<code>e_phnum</code>。</p>
<p>程序头表<code>struct Proghdr</code>是专门用来描述段信息的（注意这个段不是内存中的段，程序头描述的段时磁盘上程序的一个段，如常见的代码段和数据段等）。我们可以通过遍历程序头表，通过每一个段的<code>p_type</code>来获取每一个段的信息（在这里我们只需要<em>可加载程序段</em><code>ELF_PROG_LOAD</code>），然后将所需的段加载进入内存。（我们要理解注释中的<code>ph</code>正是<code>struct Proghdr *</code>类型的）</p>
<p>同时我们还需要注意到<code>cr3</code>寄存器，在这个函数运行之前我们的运行环境是内核环境kernel，此时<code>cr3</code>中存放的是<code>kern_pgdir</code>。这里我们需要用户环境，因此我们需要使用<code>lcr3()</code>切换到用户环境的页目录，加载完镜像之后再切换回内核页目录。</p>
<p>我们还需要为程序设置入口点，根据注释的提示我们观察<code>env_pop_tf()</code>函数，其作用是恢复保存在<code>env_tf</code>即结构体<code>struct Trapframe *</code>中的寄存器并返回。这里我们在结构体<code>struct Trapframe *</code>中很容易找到成员<code>tf_eip</code>，这就是环境中所保存的<code>IP</code>寄存器了。而让环境的<code>IP</code>寄存器指向二进制的可执行程序部分，也就是ELF头部中的<code>e_entry</code>成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set up the initial program binary, stack, and processor flags</span></span><br><span class="line"><span class="comment">// for a user process.</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function loads all loadable segments from the ELF binary image</span></span><br><span class="line"><span class="comment">// into the environment's user memory, starting at the appropriate</span></span><br><span class="line"><span class="comment">// virtual addresses indicated in the ELF program header.</span></span><br><span class="line"><span class="comment">// At the same time it clears to zero any portions of these segments</span></span><br><span class="line"><span class="comment">// that are marked in the program header as being mapped</span></span><br><span class="line"><span class="comment">// but not actually present in the ELF file - i.e., the program's bss section.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All this is very similar to what our boot loader does, except the boot</span></span><br><span class="line"><span class="comment">// loader also needs to read the code from disk.  Take a look at</span></span><br><span class="line"><span class="comment">// boot/main.c to get ideas.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Finally, this function maps one page for the program's initial stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// load_icode panics if it encounters problems.</span></span><br><span class="line"><span class="comment">//  - How might load_icode fail?  What might be wrong with the given input?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//  Load each program segment into virtual memory</span></span><br><span class="line">	<span class="comment">//  at the address specified in the ELF segment header.</span></span><br><span class="line">	<span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></span><br><span class="line">	<span class="comment">//  Each segment's virtual address can be found in ph-&gt;p_va</span></span><br><span class="line">	<span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></span><br><span class="line">	<span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line">	<span class="comment">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span></span><br><span class="line">	<span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line">	<span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line">	<span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  All page protection bits should be user read/write for now.</span></span><br><span class="line">	<span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></span><br><span class="line">	<span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line">	<span class="comment">//  the same virtual page.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You may find a function like region_alloc useful.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line">	<span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line">	<span class="comment">//  So which page directory should be in force during</span></span><br><span class="line">	<span class="comment">//  this function?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You must also do something with the program's entry point,</span></span><br><span class="line">	<span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line">	<span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	lcr3(PADDR(e -&gt; env_pgdir));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> * <span class="title">elf</span> = (<span class="title">struct</span> <span class="title">ELF</span> *)<span class="title">binary</span>;</span></span><br><span class="line">	<span class="comment">// 参考main.c解析ELF头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> * <span class="title">ph</span>, * <span class="title">eph</span>;</span></span><br><span class="line">	<span class="comment">// check magic</span></span><br><span class="line">	<span class="keyword">if</span>(elf-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		panic(<span class="string">"[load_icode] Invalid ELF File\n"</span>);</span><br><span class="line">	<span class="comment">// segment iteration</span></span><br><span class="line">	ph = (struct Proghdr *)(binary + elf-&gt;e_phoff);</span><br><span class="line">	eph = ph + elf-&gt;e_phnum;</span><br><span class="line">	<span class="keyword">for</span>(; ph &lt; eph; ph++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ph -&gt; p_type == ELF_PROG_LOAD)&#123;</span><br><span class="line">			<span class="comment">// 为该虚拟地址分配物理页</span></span><br><span class="line">			region_alloc(e, (<span class="keyword">void</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">			<span class="comment">// 将ELF header拷贝到用户环境虚拟地址</span></span><br><span class="line">			<span class="built_in">memcpy</span>((<span class="keyword">void</span> *)ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">	(e-&gt;env_tf).tf_eip = elf-&gt;e_entry;</span><br><span class="line">	<span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">stack</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">stack</span>)</span><br><span class="line">		panic(<span class="string">"[load_icode] Lack memory for allocing program stack\n"</span>);</span><br><span class="line">	<span class="keyword">if</span>(page_insert(e-&gt;env_pgdir, <span class="built_in">stack</span>, (<span class="keyword">void</span> *)USTACKTOP - PGSIZE, PTE_W | PTE_P | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		panic(<span class="string">"[load_icode] Error in setting program's stack\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>env_create()</code></li>
</ul>
<p>在内核初始化的过程中创建一个新的环境。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a new env with env_alloc, loads the named elf</span></span><br><span class="line"><span class="comment">// binary into it with load_icode, and sets its env_type.</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">// The new env's parent ID is set to 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error = env_alloc(&amp;env, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(error)&#123;</span><br><span class="line">		panic(<span class="string">"[env_create] error: %e"</span>, error);</span><br><span class="line">	&#125;</span><br><span class="line">	load_icode(env, binary);</span><br><span class="line">	env -&gt; env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>env_run</code></li>
</ul>
<p>用户环境的上下文切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Context switch from curenv to env e.</span></span><br><span class="line"><span class="comment">// Note: if this is the first call to env_run, curenv is NULL.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function does not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></span><br><span class="line">	<span class="comment">//	   1. Set the current environment (if any) back to</span></span><br><span class="line">	<span class="comment">//	      ENV_RUNNABLE if it is ENV_RUNNING (think about</span></span><br><span class="line">	<span class="comment">//	      what other states it can be in),</span></span><br><span class="line">	<span class="comment">//	   2. Set 'curenv' to the new environment,</span></span><br><span class="line">	<span class="comment">//	   3. Set its status to ENV_RUNNING,</span></span><br><span class="line">	<span class="comment">//	   4. Update its 'env_runs' counter,</span></span><br><span class="line">	<span class="comment">//	   5. Use lcr3() to switch to its address space.</span></span><br><span class="line">	<span class="comment">// Step 2: Use env_pop_tf() to restore the environment's</span></span><br><span class="line">	<span class="comment">//	   registers and drop into user mode in the</span></span><br><span class="line">	<span class="comment">//	   environment.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hint: This function loads the new environment's state from</span></span><br><span class="line">	<span class="comment">//	e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line">	<span class="comment">//	and make sure you have set the relevant parts of</span></span><br><span class="line">	<span class="comment">//	e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (curenv)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">		&#123;</span><br><span class="line">			curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">		&#125;</span><br><span class="line">		curenv = e;</span><br><span class="line">		curenv-&gt;env_status = ENV_RUNNING;</span><br><span class="line">		curenv-&gt;env_runs += <span class="number">1</span>;</span><br><span class="line">		lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">	&#125;</span><br><span class="line">	env_pop_tf(&amp;curenv-&gt;env_tf);</span><br><span class="line">	panic(<span class="string">"env_run not yet implemented"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们完成以上所有函数，在此给出函数调用关系图：</p>
<ul>
<li><code>start</code> (<code>kern/entry.S</code>)</li>
<li><code>i386_init</code> (<code>kern/init.c</code>) <ul>
<li><code>cons_init</code></li>
<li><code>mem_init</code></li>
<li><code>env_init</code></li>
<li><code>trap_init</code> (still incomplete at this point)</li>
<li><code>env_create</code></li>
<li><code>env_run</code><ul>
<li><code>env_pop_tf</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在我们完成以上内容，我们的操作系统会进入用户环境并且执行<code>hello</code>这个二进制文件，直至执行到系统调用<code>int</code> 指令。此时由于jos还并没有设置任何从用户空间进入内核空间的方法，我们会遇到问题。</p>
<p>而且当CPU发现我们无法处理系统中断调用之后，会产生一个通用保护错误（general protection exception），于是生成了一个二重错误（double fault exception）。最终还会因为无法处理这些错误而生成三重错误（triple fault）然后放弃进行系统重启。（为了方便调试，6.868修改了qemu使得此时出现三重错误时打印所有寄存器值以及内存状态）</p>
<p>检验我们是否正确完成了工作非常简单，我们依旧使用gdb进行调试。首先我们在<code>env_pop_tf()</code>函数打断点<code>b kern/env.c:env_pop_tf</code>并且运行到该断点之后，使用<code>si</code>单步进行到<code>iret</code>，这是我们可以看到我们的操作系统成功将<code>0xf0000000</code>以上的指令转而执行<code>0x80000000</code>以上的指令，即进入了我们的用户地址空间：</p>
<p><img alt="image-20200315145606468" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcumbvzgk3j30f704pdgc.jpg" data-index="1" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcumbvzgk3j30f704pdgc.jpg"></p>
<p>最终在<code>int</code>指令处，我们会遭遇triple fault，如同之前分析所得。</p>
<p><img alt="image-20200315145707316" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcumcwno7ej312v0bm43d.jpg" data-index="2" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcumcwno7ej312v0bm43d.jpg"></p>
<h3 id="A-4-Handling-Interrupts-and-Exceptions"><a href="#A-4-Handling-Interrupts-and-Exceptions" class="headerlink" title="A.4 Handling Interrupts and Exceptions"></a>A.4 Handling Interrupts and Exceptions</h3><p>按照我们上述的分析，此时在用户环境执行了系统调用会直接宕机：处理器进入用户环境以后，没有办法再次调用内核处理异常。这里我们就需要实现内核对基本异常以及系统调用的处理，首先我们需要熟悉x86下的中断和异常机制。</p>
<p><strong>exercise 3</strong></p>
<p>阅读<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm" target="_blank" rel="noopener">Chapter 9, Exceptions and Interrupts</a>，了解中断和异常处理部分。</p>
<p><em>中断是处理器以外的异步事件引发的，而异常是由当前正在执行的指令同步引发的。</em></p>
<h3 id="A-5-Basics-of-Protected-Control-Transfer"><a href="#A-5-Basics-of-Protected-Control-Transfer" class="headerlink" title="A.5 Basics of Protected Control Transfer"></a>A.5 Basics of Protected Control Transfer</h3><p>异常（exceptions）以及中断（interrupts）都是<strong>受保护控制转移</strong>，引发处理器从用户模式切换到内核模式（CPL=0），避免用户模式代码干扰内核的环境。</p>
<p>为了确保这些受保护的控制传递，在x86中主要有两种方式能够保证发生中断/异常时当前正在运行的代码不会随意选择进入内核的位置和方式（即只有在精心控制下才能进入内核），分别是中断描述符表（Interrupt Descriptor Table）和任务状态段（Task State Segment）。</p>
<h4 id="gt-gt-中断描述符表IDT"><a href="#gt-gt-中断描述符表IDT" class="headerlink" title="&gt;&gt; 中断描述符表IDT"></a>&gt;&gt; 中断描述符表IDT</h4><p>中断描述符表（IDT）将每个中断或异常标识符与服务于相关事件的指令的描述符相关联。像GDT和LDT一样，IDT是8字节描述符的数组。通过这种方式处理器保证了异常和中断仅能导致内核在若干具体的、明确定义的入口执行。</p>
<p>Intel一共定义了256种异常，每一种异常都有一个独特的异常号（异常向量），CPU以异常号为索引去中断描述符表中寻找对应表项，然后对特定中断进行处理。而所有异常（exception）都使用0-31之间的32个异常号，剩余的则对应于软件或硬件中断（interrupt）。</p>
<p>中断描述符表可以驻留在物理内存的任意位置？（应该是在内核的私有内存建立）</p>
<p>处理器从该表中加载送入EIP寄存器的值（处理程序的入口），以及送入CS段寄存器的值（包括特权级，jos中所有异常都在内核模式之行，具有特权级0）</p>
<p><img alt="image-20200316201747268" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTgy1gcw1buarcxj30h70clwem.jpg" data-index="3" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gcw1buarcxj30h70clwem.jpg"></p>
<h4 id="gt-gt-任务状态段TSS"><a href="#gt-gt-任务状态段TSS" class="headerlink" title="&gt;&gt; 任务状态段TSS"></a>&gt;&gt; 任务状态段TSS</h4><p>处理器需要将中断/异常发生之前的寄存器值保存起来（比如EIP寄存器和CS段寄存器），以便执行完处理程序之后恢复现场，从中断/异常发生的地方继续执行。但是需要注意，保存旧寄存器状态的区域必须<strong>对非特权用户模式代码处于被保护状态</strong>。否则恶意代码或者错误代码会破坏内核。也就是说保存状态的区域是不能被用户特权级访问的。</p>
<p>基于这个原因，x86处理器在处理特权级转变的时候，建立了一个独立于用户栈之外的栈。任务状态段指定了相应的段寄存器以及栈的地址。处理器需要将<code>SS</code>，<code>EFLAGS</code>，<code>CS</code>，<code>EIP</code>以及一个可选的错误码压入新栈中。然后从中断描述符中读取相应的<code>CS</code>和<code>EIP</code>。同时设置<code>ESP</code>和<code>SS</code>指向新的栈。</p>
<p><strong>Example：</strong></p>
<p>现在假设用户环境在执行一条代码的时候试图进行除零运算：</p>
<ul>
<li>处理器根据TSS所定义的<code>SS0</code>和<code>ESP0</code>来切换程序栈，在jos中他们分别对应<code>GD_KD</code>以及<code>KSTACKTOP</code>。</li>
<li>处理器将需要保护所有现场压入栈中</li>
</ul>
<p><img alt="image-20200317111041701" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcwr1xd96fj30a70373yi.jpg" data-index="4" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcwr1xd96fj30a70373yi.jpg"></p>
<ul>
<li>处理器根据我们正在处理的除零错误找到异常号（0），进一步找到中断向量表索引IDT[0]。然后根据内容设置新的CS:EIP。</li>
<li>异常处理程序接管控制流，然后进行异常处理。</li>
</ul>
<h4 id="gt-gt-Nested-Exception-and-Interrupts"><a href="#gt-gt-Nested-Exception-and-Interrupts" class="headerlink" title="&gt;&gt; Nested Exception and Interrupts"></a>&gt;&gt; Nested Exception and Interrupts</h4><p>处理器既可以在用户模式下接受中断/异常，也可以在内核模式下。但是只有从用户模式进入内核的时候，x86处理器才会自动切换堆栈，然后将旧的寄存器状态压栈并且通过IDT调用适当的处理程序。如果发生中断/异常的时候处理器已经处于内核模式（CS寄存器的低2位为0），那么CPU会将更多的值压入同一内核堆栈（这时不再需要压入<code>SS</code>和<code>ESP</code>）。这样，内核可以优雅地处理由内核本身内的代码引起的嵌套异常。</p>
<h3 id="A-6-Setting-Up-the-IDT"><a href="#A-6-Setting-Up-the-IDT" class="headerlink" title="A.6 Setting Up the IDT"></a>A.6 Setting Up the IDT</h3><p>此时我们需要建立jos中能够处理异常和系统调用的IDT。到现在为止，我们需要设置IDT使内核能够处理异常号为0-31的异常（处理器异常）。</p>
<p>头文件<code>inc/trap.h</code>和<code>kern/trap.h</code>包含了一些关于中断和异常的定义。<code>kern/trap.h</code>包含了一些内核严格私有的定义，而<code>inc/trap.h</code>中的定义对用户级程序和库有用。</p>
<p>（注意：0-31异常号中有一些可能已经被intel所保留，这些异常号永远不会被处理器引发，所以实际上不必担心如何处理这些异常号）</p>
<p>我们需要实现如下表所示的IDT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      IDT                   trapentry.S         trap.c</span><br><span class="line">   </span><br><span class="line">+----------------+                        </span><br><span class="line">|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)</span><br><span class="line">|                |             // do stuff      &#123;</span><br><span class="line">|                |             call trap          // handle the exception/interrupt</span><br><span class="line">|                |             // ...           &#125;</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handler2    |--------&gt; handler2:</span><br><span class="line">|                |            // do stuff</span><br><span class="line">|                |            call trap</span><br><span class="line">|                |            // ...</span><br><span class="line">+----------------+</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handlerX    |--------&gt; handlerX:</span><br><span class="line">|                |             // do stuff</span><br><span class="line">|                |             call trap</span><br><span class="line">|                |             // ...</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure>
<p>在<code>trapentry.S</code>文件中已经定义了每个中断和异常的处理程序，<code>trap_init()</code>函数应当使用这些处理程序的入口地址来初始化IDT。每一个处理程序都应该在栈上建立一个<code>struct Trapframe</code>用于保护现场，并且以这个结构的指针为参数调用在<code>trap.c</code>中的<code>trap()</code>。</p>
<p><strong>Exercise 4</strong></p>
<p>修改<code>trapentry.S</code>以及<code>trap.c</code>来实现上述功能。一些宏定义可能会帮助我们：</p>
<ul>
<li><code>inc/trap.c</code>中的<code>T_*</code>宏定义</li>
<li><code>trapentry.S</code>中的<code>TRAPHANDLER</code>以及<code>TRAPHANDLER_NOEC</code></li>
</ul>
<p>我们需要使用这些宏为<code>inc/trap.h</code>中定义的每一个trap增加入口点（entry point），每个异常处理函数都会跳转到<code>_alltraps</code>（在<code>TRAPHANDLER</code>中规定）。同时我们还需要修改<code>trap_init()</code>函数来初始化IDT使得其能够指向入口点（可以使用<code>inc/mmu.h</code>的<code>SETGATE</code>宏）。你的<code>_alltraps</code>需要完成如下工作：</p>
<ul>
<li>数据压栈，使得栈的结构看上去像<code>struct Trapframe</code>，在这里使用<code>pushal</code></li>
<li>将<code>GD_KD</code>加载到<code>%ds</code>和<code>%es</code></li>
<li><code>pushl %esp</code>作为<code>trap()</code>函数的参数</li>
<li><code>call trap()</code>调用函数</li>
</ul>
<p>首先我们观察<code>trapentry.S</code>中的两个宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line"> *</span><br><span class="line"> * You shouldn&apos;t call a TRAPHANDLER function from C, but you may</span><br><span class="line"> * need to _declare_ one in C (for instance, to get a function pointer</span><br><span class="line"> * during IDT setup).  You can declare the function with</span><br><span class="line"> *   void NAME();</span><br><span class="line"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="line"> */</span><br><span class="line"> ; 注意：我们所有中断服务例程的函数的名称，都是通过这两个宏定义的</span><br><span class="line"> </span><br><span class="line">#define TRAPHANDLER(name, num)						\</span><br><span class="line">	.globl name;		/* define global symbol for &apos;name&apos; */	\</span><br><span class="line">	.type name, @function;	/* symbol type is function */		\</span><br><span class="line">	.align 2;		/* align function definition */		\</span><br><span class="line">	name:			/* function starts here */		\</span><br><span class="line">	pushl $(num);							\</span><br><span class="line">	jmp _alltraps</span><br><span class="line"></span><br><span class="line">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&apos;t push an error code.</span><br><span class="line"> * It pushes a 0 in place of the error code, so the trap frame has the same</span><br><span class="line"> * format in either case.</span><br><span class="line"> */</span><br><span class="line">#define TRAPHANDLER_NOEC(name, num)					\</span><br><span class="line">	.globl name;							\</span><br><span class="line">	.type name, @function;						\</span><br><span class="line">	.align 2;							\</span><br><span class="line">	name:								\</span><br><span class="line">	pushl $0;							\</span><br><span class="line">	pushl $(num);							\</span><br><span class="line">	jmp _alltraps</span><br></pre></td></tr></table></figure>
<p>两个宏都接受参数<code>name</code>（<strong>定义一个名称为name的全局处理函数</strong>）和<code>num</code>（异常号）。但是<code>TRAPHANDLER_NOEC</code>在将num压入<strong>内核栈</strong>之前多压了一个<code>0</code>，其注释是用来代替<code>error code</code>？</p>
<p>再次，我们需要重申中断处理时压入程序栈的流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">	<span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">	<span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">	<span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| <span class="number">0x00000</span> | old SS   |     <span class="string">" - 4</span></span><br><span class="line"><span class="string">|      old ESP       |     "</span> - <span class="number">8</span></span><br><span class="line">|     old EFLAGS     |     <span class="string">" - 12  //直至下面箭头所指的-24，都是由处理器负责压栈</span></span><br><span class="line"><span class="string">| 0x00000 | old CS   |     "</span> - <span class="number">16</span>  <span class="comment">//用户不需要处理（有些中断没有error code） </span></span><br><span class="line">|      old EIP       |     <span class="string">" - 20  //对于没有error code的中断 需要用户手动填空</span></span><br><span class="line"><span class="string">|     error code     |     "</span> - <span class="number">24</span> <span class="comment">// &lt;---- </span></span><br><span class="line">+--------------------+             </span><br><span class="line">|    trap number     |    <span class="comment">//这部分在_alltrap()进行压栈</span></span><br><span class="line">| <span class="number">0x00000</span> | old DS   | </span><br><span class="line">| <span class="number">0x00000</span> | old ES   |</span><br><span class="line">|  old registers     |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<p>所以对于有些不需要压入<code>error code</code>的异常，我们需要补齐而使得栈结构和<code>struct Trapframe</code>保持一致。</p>
<p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_10.htm" target="_blank" rel="noopener">Error code summary</a>告诉我们哪些异常需要压入错误码。</p>
<p>首先我们填充<code>trapentry.S</code>的<code>_alltrap()</code>压栈部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line">_alltraps:</span><br><span class="line">	;ds es</span><br><span class="line">	push %ds</span><br><span class="line">	push %es</span><br><span class="line">	pushal   ;其余寄存器</span><br><span class="line"></span><br><span class="line">	;load DS and ES with GD_KD (不能用立即数设置段寄存器)</span><br><span class="line">	mov $GD_KD, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure>
<p>然后我们实现并初始化IDT，此时需要首先了解<code>SETGATE</code>宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class="line">    <span class="comment">//   see section 9.6.1.3 of the i386 reference: "The difference between</span></span><br><span class="line">    <span class="comment">//   an interrupt gate and a trap gate is in the effect on IF (the</span></span><br><span class="line">    <span class="comment">//   interrupt-enable flag). An interrupt that vectors through an</span></span><br><span class="line">    <span class="comment">//   interrupt gate resets IF, thereby preventing other interrupts from</span></span><br><span class="line">    <span class="comment">//   interfering with the current interrupt handler. A subsequent IRET</span></span><br><span class="line">    <span class="comment">//   instruction restores IF to the value in the EFLAGS image on the</span></span><br><span class="line">    <span class="comment">//   stack. An interrupt through a trap gate does not change IF."</span></span><br><span class="line"><span class="comment">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level -</span></span><br><span class="line"><span class="comment">//	  the privilege level required for software to invoke</span></span><br><span class="line"><span class="comment">//	  this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)			\</span></span><br><span class="line">&#123;								\</span><br><span class="line">	(gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>) (off) &amp; <span class="number">0xffff</span>;		\</span><br><span class="line">	(gate).gd_sel = (sel);					\</span><br><span class="line">	(gate).gd_args = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_rsv1 = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;	\</span><br><span class="line">	(gate).gd_s = <span class="number">0</span>;					\</span><br><span class="line">	(gate).gd_dpl = (dpl);					\</span><br><span class="line">	(gate).gd_p = <span class="number">1</span>;					\</span><br><span class="line">	(gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>) (off) &gt;&gt; <span class="number">16</span>;		\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>gate</code>：异常在IDT中的描述符</li>
<li><code>istrap</code>：用于区分异常和中断，异常则为1，中断为0</li>
<li><code>sel</code>：处理异常函数的数据段<ul>
<li><code>inc/memlayout.h</code>中有各种段选择符的详细说明（此处选择内核代码段<code>GD_KT</code>）</li>
</ul>
</li>
<li><code>off</code>：异常处理函数的入口偏移（可以使用对应的函数指针）</li>
<li><code>dpl</code>：这个描述符的优先级（能够被什么特权级的程序显式调用）</li>
</ul>
<p>这里我们明白了，这个宏的作用就是设置中断描述符的函数入口地址，然后在<code>trap_init()</code>过程中初始化IDT，让其每个表项都指向<code>trapentry.S</code>中我们使用两个宏定义的相应函数入口点。</p>
<p>所以我们接下来首先参照<code>inc/trap.h</code>中的所有异常号，在<code>trapentry.S</code>中定义相应的异常处理函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(divide_handler, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(debug_handler, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(nmi_handler, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(brkpt_handler, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(oflow_handler, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(bound_handler, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(illop_handler, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(device_handler, T_DEVICE)</span><br><span class="line">TRAPHANDLER_NOEC(dblflt_handler, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(tss_handler, T_TSS)</span><br><span class="line">TRAPHANDLER(segnp_handler, T_SEGNP)</span><br><span class="line">TRAPHANDLER(stack_handler, T_STACK)</span><br><span class="line">TRAPHANDLER(gpflt_handler, T_GPFLT)</span><br><span class="line">TRAPHANDLER(pgflt_handler, T_PGFLT)</span><br><span class="line">TRAPHANDLER_NOEC(fperr_handler, T_FPERR)</span><br><span class="line">TRAPHANDLER_NOEC(align_handler, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(mchk_handler, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(simderr_handler, T_SIMDERR)</span><br><span class="line">TRAPHANDLER_NOEC(syscall_handler, T_SYSCALL)</span><br></pre></td></tr></table></figure>
<p>然后在<code>kern/trap.c</code>中实现<code>trap_init()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先声明我们在trapentry.S中定义的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nmi_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brkpt_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oflow_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bound_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">illop_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dblflt_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tss_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segnp_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpflt_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pgflt_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fperr_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">align_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mchk_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simderr_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_handler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	SETGATE(idt[<span class="number">0</span>], <span class="number">1</span>, GD_KT, divide_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">1</span>], <span class="number">1</span>, GD_KT, debug_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">2</span>], <span class="number">1</span>, GD_KT, nmi_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">3</span>], <span class="number">1</span>, GD_KT, brkpt_handler, <span class="number">3</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">4</span>], <span class="number">1</span>, GD_KT, oflow_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">5</span>], <span class="number">1</span>, GD_KT, bound_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">6</span>], <span class="number">1</span>, GD_KT, illop_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">7</span>], <span class="number">1</span>, GD_KT, device_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">8</span>], <span class="number">1</span>, GD_KT, dblflt_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">10</span>], <span class="number">1</span>, GD_KT, tss_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">11</span>], <span class="number">1</span>, GD_KT, segnp_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">12</span>], <span class="number">1</span>, GD_KT, stack_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">13</span>], <span class="number">1</span>, GD_KT, gpflt_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">14</span>], <span class="number">1</span>, GD_KT, pgflt_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">16</span>], <span class="number">1</span>, GD_KT, fperr_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">17</span>], <span class="number">1</span>, GD_KT, align_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">18</span>], <span class="number">1</span>, GD_KT, mchk_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">19</span>], <span class="number">1</span>, GD_KT, simderr_handler, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">48</span>], <span class="number">1</span>, GD_KT, syscall_handler, <span class="number">3</span>);</span><br><span class="line">	<span class="comment">// Per-CPU setup</span></span><br><span class="line">	trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们就配置好了IDT和每个异常服务程序的定义。</p>
<p><strong>Questions</strong></p>
<p>Q：为什么对于每一个中断/异常，我们都需要使用一个单独的函数(handler function)，而不能让所有中断/异常都用一个函数处理？</p>
<p>A：由于CPU对于不同的异常码，对应的栈处理时是否处理错误码<code>error_code</code>是不同的且用户不可见。所以我们不能使用一个函数。</p>
<p>Q：是否有任何办法让<code>user/softint</code>程序行为正确？我们的评测系统期望能够产生一个<code>int $13</code>一般保护异常，但是在其汇编代码中生成的是<code>int $14</code>缺页异常信号，但是为什么我们的处理器依然会产生13号异常？假设内核允许这个指令能产生14号异常，那么会发生什么？</p>
<p>A：虽然<code>softint</code>在汇编代码中强行生成了<code>int $14</code>异常号，但是我们可以查看缺页中断的<code>dpl</code>为0，即不可以在用户态显式触发。也就是说<code>softint</code>触发该异常是非法操作，此时内核的保护机制生成了一个一般保护异常（13号）来处理这个非法操作。</p>
<p>而假如用户可以真正使内核产生14号缺页异常，那么操作系统会根据触发异常的指令去判断其访问的内存位置，但这个缺页中断并非访存指令引起（是由用户显式调用的） ，因而操作系统没办法处理这个异常。</p>
<p>在我们完成了exercise 4之后进行评分<code>make grade</code>，应该有<code>Part A 30/30</code>。</p>
<h2 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h2><p>此时kernel已经具有了基本的异常处理能力，我们将会继续对其进行优化，以提供依赖于异常处理的重要操作系统原语。</p>
<h3 id="B-1-Handling-Page-Faults"><a href="#B-1-Handling-Page-Faults" class="headerlink" title="B.1 Handling Page Faults"></a>B.1 Handling Page Faults</h3><p>缺页异常是非常重要的，具有中断向量14。当缺页异常被触发的时候，处理器会将触发异常的线性地址存放在一个特殊的处理器控制寄存器<code>cr2</code>中。在<code>trap.c</code>中我们已经提供了<code>page_fault_handler()</code>来处理缺页错误。</p>
<p><strong>exercise 5</strong></p>
<p>修改<code>trap_dispatch()</code>使得其在发生缺页时能够调度<code>page_fault_handler()</code>函数来处理异常。实现之后我们能在<code>make grade</code>通过<code>faultread</code>, <code>faultreadkernel</code>, <code>faultwrite</code>, <code>faultwritekernel</code>且总评分为50。如果实现有问题，我们可以通过<code>make run-x</code>来运行一个具体用户程序进行调试（如<code>make run-hello</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>(tf -&gt; tf_trapno == T_PGFLT)&#123;</span><br><span class="line">		page_fault_handler(tf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">		panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		env_destroy(curenv);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之后会实现缺页异常的具体处理逻辑。</p>
<h3 id="B-2-The-Breakpoint-Exception"><a href="#B-2-The-Breakpoint-Exception" class="headerlink" title="B.2 The Breakpoint Exception"></a>B.2 The Breakpoint Exception</h3><p>断点异常（具有中断向量3）通常用于允许调试器在程序代码中插入断点，即在相关的代码位置暂时使用<code>int $3</code>来代替原本应该执行的指令。在jos中我们将会大量使用这个异常来实现一个原始的伪系统调用，使得用户环境可以使用它来调用jos内核监视器（如果我们将jos内核监视器视为原始调试器，这种做法是适当的）。比如说<code>lib/panic.c</code>中user mode下的<code>panic()</code>函数，实际上就是在显示了panic信息之后使用了<code>int $3</code>。</p>
<p><strong>exercise 6</strong></p>
<p>修改<code>trap_dispatch()</code>来实现内核监视器中的断点异常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>(tf -&gt; tf_trapno == T_PGFLT)&#123;</span><br><span class="line">		page_fault_handler(tf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tf -&gt; tf_trapno == T_BRKPT)&#123;</span><br><span class="line">		monitor(tf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">		panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		env_destroy(curenv);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们可以通过<code>breakpoint</code>测试案例。</p>
<p><strong>Questions</strong></p>
<p>Q：根据你在part A中实现IDT的方式，断点测试情况下可能会生成断点异常（break point exception）或者一般保护异常（general protection fault），这是为什么？我们需要如何设置才能够使IDT触发断点异常？且何种错误的设置方式会触发一般保护异常？</p>
<p>A：跟上一个练习的问题类似，解释是我们在<code>SETGATE</code>过程中设置<code>dpl</code>，决定了用户能否显式触发中断。测试文件是在用户环境下的，如果我们设置只有内核能够触发<code>int $3</code>断点异常，则用户测试时显然会触发一般保护异常。所以我们需要将<code>dpl</code>设置为3，使得用户能够显式触发异常。</p>
<p>Q：你认为这些机制的意义是什么？<code>user/softint</code>测试程序做了什么？</p>
<p>A：显然是为了使得用户环境和内核环境能够相互独立，用户环境仅能够在特定环境下（异常）能够执行某些内核代码进行处理，保证了恶意程序不会破坏内核，同时用户环境能够得到内核指令支持。<code>softint</code>通过内联汇编显式调用<code>int</code>指令。</p>
<h3 id="B-3-System-Calls"><a href="#B-3-System-Calls" class="headerlink" title="B.3 System Calls"></a>B.3 System Calls</h3><p>用户进程通过系统调用来请求内核为其工作。当用户环境唤起系统调用时，处理器进入内核模式，处理器和内核协作来保存用户进程状态，内核执行适当的代码来完成系统调用，然后恢复至用户进程。对于用户环境如何唤起内核注意以及系统调用的具体实现是因系统而异的。</p>
<p>jos内核中我们使用<code>int $0x30</code>作为系统调用中断（中断向量48号），我们需要建立相关的种段描述符。注意到<code>0x30</code>中断向量是不可能通过硬件产生的，毫无疑问是由用户环境下的代码产生的。</p>
<p>应用程序将会通过寄存器传递系统调用号以及相应的系统调用参数。这种方式下内核就不会访问用户环境栈或者指令流。系统调用号存放在<code>%eax</code>寄存器中，其余参数（最多五个）相应地存放在 <code>%edx</code>, <code>%ecx</code>, <code>%ebx</code>, <code>%edi</code>, <code>%esi</code>中。内核将返回值存放在寄存器<code>%eax</code>中。用于唤醒系统调用的汇编代码已经实现在<code>lib/syscall.c</code>中的<code>syscall()</code>。我们需要阅读这个函数以确保理解了如何唤醒系统调用。</p>
<p><strong>exercise 7</strong></p>
<p>为内核增加系统调用处理函数。我们需要修改<code>kern/trapentry.S</code>以及<code>kern.trap.c</code>中的<code>trap_init()</code>函数。我们还需要修改<code>trap_dispatch()</code>，使其能够以正确参数调用<code>syscall()</code>（这个是<code>kern/syscall.c</code>下的而非之前<code>lib</code>中的）并将返回结果存放在<code>%eax</code>中返回给用户（调用者）。</p>
<p>我们还需要实现<code>kern/syscall.c</code>下的<code>syscall()</code>，使得调用号无效的时候返回<code>-E_INVAL</code>。通过系统调用函数处理<code>inc/syscall.h</code>中的所有系统调用。</p>
<ul>
<li><code>trap_dispatch()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>(tf -&gt; tf_trapno == T_PGFLT)&#123;</span><br><span class="line">		page_fault_handler(tf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tf -&gt; tf_trapno == T_BRKPT)&#123;</span><br><span class="line">		monitor(tf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tf -&gt; tf_trapno == T_SYSCALL)&#123;</span><br><span class="line">		<span class="keyword">int32_t</span> retval = syscall(tf-&gt;tf_regs.reg_eax,</span><br><span class="line">								 tf-&gt;tf_regs.reg_edx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_edi,</span><br><span class="line">								 tf-&gt;tf_regs.reg_esi);</span><br><span class="line">		<span class="keyword">if</span>(retval &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			panic(<span class="string">"[trap_dispatch] syscall : %e\n"</span>, retval);</span><br><span class="line">		&#125;</span><br><span class="line">		tf-&gt;tf_regs.reg_eax = retval;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">		panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		env_destroy(curenv);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>syscall()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Call the function corresponding to the 'syscallno' parameter.</span></span><br><span class="line">	<span class="comment">// Return any appropriate return value.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">	<span class="keyword">case</span> SYS_cputs:</span><br><span class="line">		sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, a2);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">		<span class="keyword">return</span> sys_cgetc();</span><br><span class="line">	<span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">		<span class="keyword">return</span> sys_getenvid();</span><br><span class="line">	<span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">		<span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现以后，我们可以通过<code>make run-hello</code>观察<code>hello</code>的输出。应该会首先答应”hello world”在控制台中，然后在用户模式下造成缺页错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">hello, world</span><br><span class="line"> env_tf :  f01f7000</span><br><span class="line"> trap called</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">[00001000] user fault va 00000048 ip 00800048</span><br><span class="line">TRAP frame at 0xf01f7000</span><br><span class="line">  edi  0x00000000</span><br><span class="line">  esi  0x00000000</span><br><span class="line">  ebp  0xeebfdfd0</span><br><span class="line">  oesp 0xefffffdc</span><br><span class="line">  ebx  0x00000000</span><br><span class="line">  edx  0xeebfde88</span><br><span class="line">  ecx  0x0000000d</span><br><span class="line">  eax  0x00000000</span><br><span class="line">  es   0x----0023</span><br><span class="line">  ds   0x----0023</span><br><span class="line">  trap 0x0000000e Page Fault</span><br><span class="line">  cr2  0x00000048</span><br><span class="line">  err  0x00000004 [user, read, not-present]</span><br><span class="line">  eip  0x00800048</span><br><span class="line">  cs   0x----001b</span><br><span class="line">  flag 0x00000092</span><br><span class="line">  esp  0xeebfdfb8</span><br><span class="line">  ss   0x----0023</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Destroyed the only environment - nothing more to do!</span><br></pre></td></tr></table></figure>
<p>同时<code>make grade</code>应该可以通过<code>testbss</code>案例。</p>
<h3 id="B-4-User-mode-startup"><a href="#B-4-User-mode-startup" class="headerlink" title="B.4 User-mode startup"></a>B.4 User-mode startup</h3><p>用户程序在<code>lib/entry.S</code>的顶部开始运行（所有的用户程序均是如此），经过一些设置之后，代码会调用<code>lib/libmain.c</code>中的<code>libmain()</code>。我们需要修改<code>libmain()</code>以初始化指向当前环境<code>struct Env</code>（在<code>envs[]</code>数组中）的全局指针<code>thisenv</code>（注意<code>lib/entry.S</code>已经定义了我们在part A中指向<code>UENVS</code>的映射<code>envs</code>）。</p>
<blockquote>
<p>提示：我们可以查看<code>inc/env.h</code>以及使用<code>sys_getenvid()</code>。</p>
</blockquote>
<p>随后<code>libmain</code>调用<code>umain</code>，对于<code>hello</code>程序而言，打印出”hello world”之后，其试图访问<code>thisenv-&gt;env_id</code>，这就是为什么hello程序会出现fault（我们还没有初始化<code>thisenv</code>）。</p>
<p><strong>exercise 8</strong><br>对用户库添加相应的代码然后重启内核，使得<code>hello</code>程序能够正常运行。</p>
<p>实际上我们需要修改<code>libmain()</code>函数使其初始化<code>thisenv</code>，指向<code>envs</code>中代表当前用户环境的<code>Env</code>结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">libmain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	thisenv = <span class="number">0</span>;</span><br><span class="line">	thisenv = envs + ENVX(sys_getenvid());</span><br><span class="line">	<span class="comment">// save the name of the program so that panic() can use it</span></span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">0</span>)</span><br><span class="line">		binaryname = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call user main routine</span></span><br><span class="line">	umain(argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// exit gracefully</span></span><br><span class="line">	<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现之后我们就可以通过<code>hello</code>测试案例了。</p>
<h3 id="B-5-Page-faults-and-memory-protection"><a href="#B-5-Page-faults-and-memory-protection" class="headerlink" title="B.5 Page faults and memory protection"></a>B.5 Page faults and memory protection</h3><p>内存保护是操作系统的一个重要功能，它能够确保一个有bug的程序不会破坏其他程序甚至操作系统内核。</p>
<p>操作系统通常依赖硬件支持以实现内存保护。操作系统告知硬件哪些虚拟地址是有效的，哪些是无效的。当程序试图访问一个无效的虚拟地址或者一个无权限的虚拟地址时，处理器在引起错误的位置停止程序并且带着相应的错误信息陷入内核。如果这个错误是可修复的，内核修复该错误并且让程序继续运行；如果错误是不可修复的，则程序将无法继续运行。</p>
<p>现在给出一个可修复错误的例子（<strong>栈扩充机制</strong>）：考虑一个可以自动拓展的堆栈。在许多系统中，内核最初分配一个<strong>堆栈页面</strong>，然后如果程序无法访问堆栈中更远的页面（esp指针减小到这一个页面的下限），内核将自动分配页面作为栈空间使得程序能够继续。这样内核仅分配程序需要的堆栈内存，使得用户程序可以认为其拥有任意大小的栈。</p>
<p>考虑系统调用，很多系统调用允许用户程序向内核传递指针，内核在处理系统调用的时候将指针解引用并执行系统调用。这带来了如下两个问题：</p>
<ol>
<li>内核的缺页错误潜在地比用户程序的缺页错误更加严重。如果内核在操作其私有数据结构的时候发生了缺页错误，那么内核产生bug，错误处理程序应该panic内核。但是当内核解引用由用户程序传递的指针时，<strong>需要某种方式来标记由解引用导致的缺页实际上代表的是用户程序引发的</strong>。</li>
<li>内核比用户程序具有更多的地址权限。在这种情况下用户程序可能会传递一个指针，这个指针指向的地址只能由内核读写而不能通过用户程序读写。在这种情况下内核不能对这个指针进行解引用（这样做显然会暴露内核的私有信息）。</li>
</ol>
<p>因此我们需要解决这两个问题，通过检查传递从用户空间传递到内核的指针是否应该被解引用。</p>
<p><strong>exercise 9</strong></p>
<ol>
<li>修改<code>kern/trap.c</code>，使得内核在内核代码触发缺页错误的时候panic。</li>
</ol>
<blockquote>
<p>提示：为了确认引发异常的代码是用户代码还是内核代码，可以检查<code>tf_cs</code>的寄存器值的低位。</p>
</blockquote>
<ol>
<li><p>阅读<code>kern/pmap.c</code>中的<code>user_mem_assert</code>然后在相同的的文件中实现<code>user_mem_check</code>。</p>
</li>
<li><p>修改<code>kern/syscall.c</code>来仔细检查系统调用的参数。</p>
</li>
<li><p>修改<code>kern/kedebug.c</code>中的<code>debuginfo_eip</code>函数，使其在<code>usd</code>, <code>stabs</code>, <code>stabstr</code>调用<code>user_mem_check</code>。</p>
</li>
</ol>
<ul>
<li>修改<code>kern/trap.c</code>中的<code>page_fault_handler()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read processor's CR2 register to find the faulting address</span></span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">		panic(<span class="string">"[page_fault_handler] Page fault in kernel.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// We've already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">	<span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">	cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过段寄存器的权限位分辨缺页错误是内核导致的还是用户导致的。</p>
<ul>
<li><code>user_mem_check</code></li>
</ul>
<p>仔细阅读注释，查看我们通过何种方式进行检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Check that an environment is allowed to access the range of memory</span></span><br><span class="line"><span class="comment">// [va, va+len) with permissions 'perm | PTE_P'.</span></span><br><span class="line"><span class="comment">// Normally 'perm' will contain PTE_U at least, but this is not required.</span></span><br><span class="line"><span class="comment">// 'va' and 'len' need not be page-aligned; you must test every page that</span></span><br><span class="line"><span class="comment">// contains any of that range.  You will test either 'len/PGSIZE',</span></span><br><span class="line"><span class="comment">// 'len/PGSIZE + 1', or 'len/PGSIZE + 2' pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A user program can access a virtual address if (1) the address is below</span></span><br><span class="line"><span class="comment">// ULIM, and (2) the page table gives it permission.  These are exactly</span></span><br><span class="line"><span class="comment">// the tests you should implement here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there is an error, set the 'user_mem_check_addr' variable to the first</span></span><br><span class="line"><span class="comment">// erroneous virtual address.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 if the user program can access this range of addresses,</span></span><br><span class="line"><span class="comment">// and -E_FAULT otherwise.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">user_mem_check(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="comment">// ! (1) the address is below ULIM</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">uintptr_t</span>)va &gt;= ULIM)&#123;</span><br><span class="line">		user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</span><br><span class="line">		<span class="keyword">return</span> -E_FAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">uintptr_t</span> start = (<span class="keyword">uintptr_t</span>)ROUNDDOWN(va, PGSIZE);</span><br><span class="line">	<span class="keyword">uintptr_t</span> end = (<span class="keyword">uintptr_t</span>)ROUNDUP(va+len, PGSIZE);</span><br><span class="line">	<span class="keyword">for</span>(;start &lt; end; start += PGSIZE)&#123;</span><br><span class="line">		<span class="comment">//get pte</span></span><br><span class="line">		<span class="keyword">pte_t</span> * pte = pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">void</span> *)start, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>((*pte &amp; (perm | PTE_P)) != (perm | PTE_P))&#123;</span><br><span class="line">			<span class="comment">// ! (2) the page table gives it permission</span></span><br><span class="line">			<span class="keyword">if</span>(start &lt;= (<span class="keyword">uintptr_t</span>)va)&#123;</span><br><span class="line">				user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(start &gt;= (<span class="keyword">uintptr_t</span>)va + len)&#123;</span><br><span class="line">				user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va + len;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				user_mem_check_addr = start;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> -E_FAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改<code>kern/syscall.c</code>中的<code>sys_cputs</code>相关部分</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Call the function corresponding to the 'syscallno' parameter.</span></span><br><span class="line">	<span class="comment">// Return any appropriate return value.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">	<span class="keyword">case</span> SYS_cputs:</span><br><span class="line">		<span class="comment">//check memory before dereference</span></span><br><span class="line">		user_mem_assert(curenv, (<span class="keyword">void</span> *)a1, (<span class="keyword">size_t</span>)a2, PTE_U);</span><br><span class="line">		sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, a2);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">		<span class="keyword">return</span> sys_cgetc();</span><br><span class="line">	<span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">		<span class="keyword">return</span> sys_getenvid();</span><br><span class="line">	<span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">		<span class="keyword">return</span> sys_env_destroy((<span class="keyword">envid_t</span>)a1);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print a string to the system console.</span></span><br><span class="line"><span class="comment">// The string is exactly 'len' characters long.</span></span><br><span class="line"><span class="comment">// Destroys the environment on memory errors.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sys_cputs(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">	<span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	user_mem_check(curenv, (<span class="keyword">void</span> *)s, len, PTE_U);</span><br><span class="line">	<span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">	cprintf(<span class="string">"%.*s"</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>debuginfo_eip()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debuginfo_eip(addr, info)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	Fill in the 'info' structure with information about the specified</span></span><br><span class="line"><span class="comment">//	instruction address, 'addr'.  Returns 0 if information was found, and</span></span><br><span class="line"><span class="comment">//	negative if not.  But even if it returns negative it has stored some</span></span><br><span class="line"><span class="comment">//	information into '*info'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">debuginfo_eip(<span class="keyword">uintptr_t</span> addr, struct Eipdebuginfo *info)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stab</span> *<span class="title">stabs</span>, *<span class="title">stab_end</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *stabstr, *stabstr_end;</span><br><span class="line">	<span class="keyword">int</span> lfile, rfile, lfun, rfun, lline, rline;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize *info</span></span><br><span class="line">	info-&gt;eip_file = <span class="string">"&lt;unknown&gt;"</span>;</span><br><span class="line">	info-&gt;eip_line = <span class="number">0</span>;</span><br><span class="line">	info-&gt;eip_fn_name = <span class="string">"&lt;unknown&gt;"</span>;</span><br><span class="line">	info-&gt;eip_fn_namelen = <span class="number">9</span>;</span><br><span class="line">	info-&gt;eip_fn_addr = addr;</span><br><span class="line">	info-&gt;eip_fn_narg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the relevant set of stabs</span></span><br><span class="line">	<span class="keyword">if</span> (addr &gt;= ULIM) &#123;</span><br><span class="line">		stabs = __STAB_BEGIN__;</span><br><span class="line">		stab_end = __STAB_END__;</span><br><span class="line">		stabstr = __STABSTR_BEGIN__;</span><br><span class="line">		stabstr_end = __STABSTR_END__;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// The user-application linker script, user/user.ld,</span></span><br><span class="line">		<span class="comment">// puts information about the application's stabs (equivalent</span></span><br><span class="line">		<span class="comment">// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and</span></span><br><span class="line">		<span class="comment">// __STABSTR_END__) in a structure located at virtual address</span></span><br><span class="line">		<span class="comment">// USTABDATA.</span></span><br><span class="line">		<span class="keyword">const</span> struct UserStabData *usd = (<span class="keyword">const</span> struct UserStabData *) USTABDATA;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure this memory is valid.</span></span><br><span class="line">		<span class="comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span></span><br><span class="line">		<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">		<span class="keyword">if</span>(user_mem_check(curenv, usd, <span class="keyword">sizeof</span>(struct UserStabData), PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		stabs = usd-&gt;stabs;</span><br><span class="line">		stab_end = usd-&gt;stab_end;</span><br><span class="line">		stabstr = usd-&gt;stabstr;</span><br><span class="line">		stabstr_end = usd-&gt;stabstr_end;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure the STABS and string table memory is valid.</span></span><br><span class="line">		<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">		<span class="keyword">if</span>(user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// String table validity checks</span></span><br><span class="line">	<span class="keyword">if</span> (stabstr_end &lt;= stabstr || stabstr_end[<span class="number">-1</span>] != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now we find the right stabs that define the function containing</span></span><br><span class="line">	<span class="comment">// 'eip'.  First, we find the basic source file containing 'eip'.</span></span><br><span class="line">	<span class="comment">// Then, we look in that source file for the function.  Then we look</span></span><br><span class="line">	<span class="comment">// for the line number.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Search the entire set of stabs for the source file (type N_SO).</span></span><br><span class="line">	lfile = <span class="number">0</span>;</span><br><span class="line">	rfile = (stab_end - stabs) - <span class="number">1</span>;</span><br><span class="line">	stab_binsearch(stabs, &amp;lfile, &amp;rfile, N_SO, addr);</span><br><span class="line">	<span class="keyword">if</span> (lfile == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Search within that file's stabs for the function definition</span></span><br><span class="line">	<span class="comment">// (N_FUN).</span></span><br><span class="line">	lfun = lfile;</span><br><span class="line">	rfun = rfile;</span><br><span class="line">	stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_FUN, addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lfun &lt;= rfun) &#123;</span><br><span class="line">		<span class="comment">// stabs[lfun] points to the function name</span></span><br><span class="line">		<span class="comment">// in the string table, but check bounds just in case.</span></span><br><span class="line">		<span class="keyword">if</span> (stabs[lfun].n_strx &lt; stabstr_end - stabstr)</span><br><span class="line">			info-&gt;eip_fn_name = stabstr + stabs[lfun].n_strx;</span><br><span class="line">		info-&gt;eip_fn_addr = stabs[lfun].n_value;</span><br><span class="line">		addr -= info-&gt;eip_fn_addr;</span><br><span class="line">		<span class="comment">// Search within the function definition for the line number.</span></span><br><span class="line">		lline = lfun;</span><br><span class="line">		rline = rfun;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Couldn't find function stab!  Maybe we're in an assembly</span></span><br><span class="line">		<span class="comment">// file.  Search the whole file for the line number.</span></span><br><span class="line">		info-&gt;eip_fn_addr = addr;</span><br><span class="line">		lline = lfile;</span><br><span class="line">		rline = rfile;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Ignore stuff after the colon.</span></span><br><span class="line">	info-&gt;eip_fn_namelen = strfind(info-&gt;eip_fn_name, <span class="string">':'</span>) - info-&gt;eip_fn_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Search within [lline, rline] for the line number stab.</span></span><br><span class="line">	<span class="comment">// If found, set info-&gt;eip_line to the right line number.</span></span><br><span class="line">	<span class="comment">// If not found, return -1.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//	There's a particular stabs type used for line numbers.</span></span><br><span class="line">	<span class="comment">//	Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span></span><br><span class="line">	<span class="comment">//	which one.</span></span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">	<span class="keyword">if</span> (lline &lt;= rline)</span><br><span class="line">	&#123;</span><br><span class="line">		info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Search backwards from the line number for the relevant filename</span></span><br><span class="line">	<span class="comment">// stab.</span></span><br><span class="line">	<span class="comment">// We can't just use the "lfile" stab because inlined functions</span></span><br><span class="line">	<span class="comment">// can interpolate code from a different file!</span></span><br><span class="line">	<span class="comment">// Such included source files use the N_SOL stab type.</span></span><br><span class="line">	<span class="keyword">while</span> (lline &gt;= lfile</span><br><span class="line">	       &amp;&amp; stabs[lline].n_type != N_SOL</span><br><span class="line">	       &amp;&amp; (stabs[lline].n_type != N_SO || !stabs[lline].n_value))</span><br><span class="line">		lline--;</span><br><span class="line">	<span class="keyword">if</span> (lline &gt;= lfile &amp;&amp; stabs[lline].n_strx &lt; stabstr_end - stabstr)</span><br><span class="line">		info-&gt;eip_file = stabstr + stabs[lline].n_strx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set eip_fn_narg to the number of arguments taken by the function,</span></span><br><span class="line">	<span class="comment">// or 0 if there was no containing function.</span></span><br><span class="line">	<span class="keyword">if</span> (lfun &lt; rfun)</span><br><span class="line">		<span class="keyword">for</span> (lline = lfun + <span class="number">1</span>;</span><br><span class="line">		     lline &lt; rfun &amp;&amp; stabs[lline].n_type == N_PSYM;</span><br><span class="line">		     lline++)</span><br><span class="line">			info-&gt;eip_fn_narg++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成后<code>make run-buggyhello</code>应该有如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[00001000] user_mem_check assertion failure for va 00000001</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Destroyed the only environment - nothing more to do!</span><br></pre></td></tr></table></figure>
<p>同时运行<code>backtrace</code>命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp effffea0  eip f01008a6  args 00000001 effffeb8 00000000 f01f7000 f01b5120</span><br><span class="line">      kern/monitor.c:137: monitor+317</span><br><span class="line">  ebp efffff10  eip f01030b5  args 00000000 efffff3c 00000000 f01f7000 f01f7000</span><br><span class="line">      kern/env.c:459: env_destroy+39</span><br><span class="line">  ebp efffff30  eip f0102a93  args f01f7000 00001000 00000001 00000004 f0103182</span><br><span class="line">      kern/pmap.c:619: user_mem_assert+71</span><br><span class="line">  ebp efffff50  eip f0103a93  args f01f7000 00000001 00000001 00000004 f011af98</span><br><span class="line">      kern/syscall.c:24: syscall+144</span><br><span class="line">  ebp efffff80  eip f0103943  args 00000000 00000001 00000001 00000000 00000000</span><br><span class="line">      kern/trap.c:197: trap+319</span><br><span class="line">  ebp efffffb0  eip f0103a03  args efffffbc 00000000 00000000 eebfdfb0 efffffdc</span><br><span class="line">      kern/syscall.c:68: syscall+0</span><br><span class="line">trap called</span><br><span class="line">Incoming TRAP frame at 0xeffffe2c</span><br><span class="line">kernel panic at kern/trap.c:265: [page_fault_handler] Page fault in kernel.</span><br></pre></td></tr></table></figure>
<p>为什么最终会发生页错误呢？我们发现我们访问了<code>0xeffffe2c</code>，观察<code>memlayout.h</code>我们得知在<code>USTACKTOP</code>上方从<code>0xeebfd000</code>开始有一块empty memory没有映射到任何物理爷。而<code>backtrace</code>最后访问这个虚拟地址就会发生一个无法处理的页错误。</p>
<p><strong>exercise 10</strong></p>
<p>运行<code>make run-evilhello</code>，我们的环境应该被销毁，但内核不应该发生panic，我们应该看到以下内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">00000000</span>] <span class="keyword">new</span> env <span class="number">00001000</span></span><br><span class="line"> env_tf :  f01f7000</span><br><span class="line"> trap called</span><br><span class="line">Incoming TRAP frame at <span class="number">0xefffffbc</span></span><br><span class="line"> env_tf :  f01f7000</span><br><span class="line"> trap called</span><br><span class="line">Incoming TRAP frame at <span class="number">0xefffffbc</span></span><br><span class="line">[<span class="number">00001000</span>] user_mem_check assertion failure <span class="keyword">for</span> va f010000c</span><br><span class="line">[<span class="number">00001000</span>] <span class="built_in">free</span> env <span class="number">00001000</span></span><br><span class="line">Destroyed the only environment - nothing more to <span class="keyword">do</span>!</span><br></pre></td></tr></table></figure>
<p>至此我们完成了实验内容。🎉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">divzero: OK (<span class="number">1.6</span>s)</span><br><span class="line">softint: OK (<span class="number">1.5</span>s)</span><br><span class="line">badsegment: OK (<span class="number">2.5</span>s)</span><br><span class="line">Part A score: <span class="number">30</span>/<span class="number">30</span></span><br><span class="line"></span><br><span class="line">faultread: OK (<span class="number">1.6</span>s)</span><br><span class="line">faultreadkernel: OK (<span class="number">2.4</span>s)</span><br><span class="line">faultwrite: OK (<span class="number">1.7</span>s)</span><br><span class="line">faultwritekernel: OK (<span class="number">2.1</span>s)</span><br><span class="line">breakpoint: OK (<span class="number">2.2</span>s)</span><br><span class="line">testbss: OK (<span class="number">2.0</span>s)</span><br><span class="line">hello: OK (<span class="number">1.5</span>s)</span><br><span class="line">buggyhello: OK (<span class="number">2.3</span>s)</span><br><span class="line">    (Old jos.out.buggyhello failure <span class="built_in">log</span> removed)</span><br><span class="line">buggyhello2: OK (<span class="number">1.8</span>s)</span><br><span class="line">    (Old jos.out.buggyhello2 failure <span class="built_in">log</span> removed)</span><br><span class="line">evilhello: OK (<span class="number">1.9</span>s)</span><br><span class="line">    (Old jos.out.evilhello failure <span class="built_in">log</span> removed)</span><br><span class="line">Part B score: <span class="number">50</span>/<span class="number">50</span></span><br><span class="line"></span><br><span class="line">Score: <span class="number">80</span>/<span class="number">80</span></span><br></pre></td></tr></table></figure>

                </article>
                <ul class="tags-postTags">
                    
                    <li>
                        <a href="/tags/operating-system/" rel="tag"># operating system</a>
                    </li>
                    
                    <li>
                        <a href="/tags/lab/" rel="tag"># lab</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </div>

    
    <nav id="gobottom" class="pagination">
        
        <a class="prev-post" title="Hunting Malware in Process Memory" href="/2020/03/10/memfor-8/">
            ← Hunting Malware in Process Memory
        </a>
        
        <span class="prev-next-post">·</span>
        
        <a class="next-post" title="Process Memory Internals" href="/2020/03/09/memfor-7/">
            Process Memory Internals →
        </a>
        
    </nav>

    
    <div class="inner">
        <div id="comment"></div>
    </div>
    
</div>

<div class="toc-bar">
    <div class="toc-btn-bar">
        <a href="#site-main" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M793.024 710.272a32 32 0 1 0 45.952-44.544l-310.304-320a32 32 0 0 0-46.4 0.48l-297.696 320a32 32 0 0 0 46.848 43.584l274.752-295.328 286.848 295.808z"/></svg>
        </a>
        <div class="toc-btn toc-switch">
            <svg class="toc-open" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M779.776 480h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M779.776 672h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M256 288a32 32 0 1 0 0 64 32 32 0 0 0 0-64M392.576 352h387.2a32 32 0 0 0 0-64h-387.2a32 32 0 0 0 0 64M256 480a32 32 0 1 0 0 64 32 32 0 0 0 0-64M256 672a32 32 0 1 0 0 64 32 32 0 0 0 0-64"/></svg>
            <svg class="toc-close hide" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 960c-247.039484 0-448-200.960516-448-448S264.960516 64 512 64 960 264.960516 960 512 759.039484 960 512 960zM512 128.287273c-211.584464 0-383.712727 172.128262-383.712727 383.712727 0 211.551781 172.128262 383.712727 383.712727 383.712727 211.551781 0 383.712727-172.159226 383.712727-383.712727C895.712727 300.415536 723.551781 128.287273 512 128.287273z"/><path d="M557.05545 513.376159l138.367639-136.864185c12.576374-12.416396 12.672705-32.671738 0.25631-45.248112s-32.704421-12.672705-45.248112-0.25631l-138.560301 137.024163-136.447897-136.864185c-12.512727-12.512727-32.735385-12.576374-45.248112-0.063647-12.512727 12.480043-12.54369 32.735385-0.063647 45.248112l136.255235 136.671523-137.376804 135.904314c-12.576374 12.447359-12.672705 32.671738-0.25631 45.248112 6.271845 6.335493 14.496116 9.504099 22.751351 9.504099 8.12794 0 16.25588-3.103239 22.496761-9.247789l137.567746-136.064292 138.687596 139.136568c6.240882 6.271845 14.432469 9.407768 22.65674 9.407768 8.191587 0 16.352211-3.135923 22.591372-9.34412 12.512727-12.480043 12.54369-32.704421 0.063647-45.248112L557.05545 513.376159z"/></svg>
        </div>
        <a href="#gobottom" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M231.424 346.208a32 32 0 0 0-46.848 43.584l297.696 320a32 32 0 0 0 46.4 0.48l310.304-320a32 32 0 1 0-45.952-44.544l-286.848 295.808-274.752-295.36z"/></svg>
        </a>
    </div>
    <div class="toc-main">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab3-User-Environments"><span class="toc-text">Lab3 User Environments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-实验介绍"><span class="toc-text">&gt; 实验介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-实验准备"><span class="toc-text">&gt; 实验准备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-A-User-Environments-and-Exception-Handling"><span class="toc-text">Part A: User Environments and Exception Handling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-1-Environment-State"><span class="toc-text">A.1 Environment State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-2-Allocating-the-Environment-Array"><span class="toc-text">A.2 Allocating the Environment Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-3-Creating-and-Running-Environments"><span class="toc-text">A.3 Creating and Running Environments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-4-Handling-Interrupts-and-Exceptions"><span class="toc-text">A.4 Handling Interrupts and Exceptions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-5-Basics-of-Protected-Control-Transfer"><span class="toc-text">A.5 Basics of Protected Control Transfer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-中断描述符表IDT"><span class="toc-text">&gt;&gt; 中断描述符表IDT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-任务状态段TSS"><span class="toc-text">&gt;&gt; 任务状态段TSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Nested-Exception-and-Interrupts"><span class="toc-text">&gt;&gt; Nested Exception and Interrupts</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-6-Setting-Up-the-IDT"><span class="toc-text">A.6 Setting Up the IDT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><span class="toc-text">Part B: Page Faults, Breakpoints Exceptions, and System Calls</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-1-Handling-Page-Faults"><span class="toc-text">B.1 Handling Page Faults</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-2-The-Breakpoint-Exception"><span class="toc-text">B.2 The Breakpoint Exception</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-3-System-Calls"><span class="toc-text">B.3 System Calls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-4-User-mode-startup"><span class="toc-text">B.4 User-mode startup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-5-Page-faults-and-memory-protection"><span class="toc-text">B.5 Page faults and memory protection</span></a></li></ol></li></ol>
    </div>
</div>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>




	</div>
	


<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            

<article class="read-next-card" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfvz62ikmj30u0140kjl.jpg)">
  <header class="read-next-card-header">
    <small class="read-next-card-header-sitetitle">&mdash; Icegrave &mdash;</small>
    <h3 class="read-next-card-header-title">Recent Posts</h3>
  </header>
  <div class="read-next-divider">
    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
      <path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/>
    </svg>
  </div>
  <div class="read-next-card-content">
    <ul>
      
      
      
      <li>
        <a href="/2020/03/10/memfor-8/">Hunting Malware in Process Memory</a>
      </li>
      
      
      
      <li>
        <a href="/2020/03/10/oslab3/">手把手带你MIT6.828 - Lab3</a>
      </li>
      
      
      
      <li>
        <a href="/2020/03/09/memfor-7/">Process Memory Internals</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </ul>
  </div>
  <footer class="read-next-card-footer">
    <a href="/archives">  MORE  → </a>
  </footer>
</article>

            
            
            

<article class="read-next-card" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfvz62ikmj30u0140kjl.jpg)">
    <header class="read-next-card-header tagcloud-card">
        <h3 class="read-next-card-header-title">Categories</h3>
    </header>
    <div class="read-next-card-content">
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memory-forensics/">memory forensics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/operating-system/">operating system</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/图形学基础/">图形学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li></ul>
    </div>
</article>


            
            
            

<article class="read-next-card" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfvz62ikmj30u0140kjl.jpg)">
	<header class="read-next-card-header tagcloud-card">
		<h3 class="read-next-card-header-title">Tag Cloud</h3>
	</header>
	<div class="read-next-card-content-ext">
		<a href="/tags/Fundamentals-of-Computer-Graphics/" style="font-size: 14px;">Fundamentals of Computer Graphics</a> <a href="/tags/iOS/" style="font-size: 14px;">iOS</a> <a href="/tags/iosre/" style="font-size: 14px;">iosre</a> <a href="/tags/lab/" style="font-size: 20.67px;">lab</a> <a href="/tags/memory-forensics/" style="font-size: 24px;">memory forensics</a> <a href="/tags/notes/" style="font-size: 24px;">notes</a> <a href="/tags/operating-system/" style="font-size: 20.67px;">operating system</a> <a href="/tags/工具/" style="font-size: 17.33px;">工具</a> <a href="/tags/随笔/" style="font-size: 14px;">随笔</a>
	</div>
</article>

            
        </div>
    </div>
</aside>

	




<div id="search" class="search-overlay">
    <div class="search-form">
        
        <div class="search-overlay-logo">
        	<img src="https://mubai.oss-cn-hangzhou.aliyuncs.com/icon.png" alt="Icegrave">
        </div>
        
        <input id="local-search-input" class="search-input" type="text" name="search" placeholder="Search ...">
        <a class="search-overlay-close" href="#"></a>
    </div>
    <div id="local-search-result"></div>
</div>

<footer class="site-footer outer">
	<div class="site-footer-content inner">
		<div class="copyright">
			<a href="/" title="Icegrave">Icegrave &copy; 2020</a>
			
				
			        <span hidden="true" id="/2020/03/10/oslab3/" class="leancloud-visitors" data-flag-title="手把手带你MIT6.828 - Lab3">
			            <span>阅读量 </span>
			            <span class="leancloud-visitors-count">0</span>
			        </span>
	    		
    		
		</div>
		<nav class="site-footer-nav">
			
			<a href="https://hexo.io" title="Hexo" target="_blank" rel="noopener">Hexo</a>
			<a href="https://github.com/xzhih/hexo-theme-casper" title="Casper" target="_blank" rel="noopener">Casper</a>
		</nav>
	</div>
</footer>
	


<script>
    if(window.navigator && navigator.serviceWorker) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for(let registration of registrations) {
                registration.unregister()
            }
        })
    }
</script>


<script id="scriptLoad" src="/js/allinone.min.js" async></script>


<script>
    document.getElementById('scriptLoad').addEventListener('load', function () {
        
        
            var bLazy = new Blazy();
        

        
        

        
        
        
            searchFunc("/");
        
        
    })
</script>



<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>




<script id="valineScript" src="//unpkg.com/valine/dist/Valine.min.js" async></script>
<script>
    document.getElementById('valineScript').addEventListener("load", function() {
        new Valine({
            el: '#comment' ,
            verify: false,
            notify: false,
            appId: 'PlliSVE5ISCj7XAYOowLuJDX-gzGzoHsz',
            appKey: 'CoE3u0Y1coO3kv6nHDpSuj4L',
            placeholder: 'nil',
            pageSize: 10,
            avatar: 'mm',
            visitor: true
        })
    });
</script>





</body>
</html>
