<!DOCTYPE html>
<html lang="zh-Hans">







<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="preconnect" href="//www.googletagmanager.com">
	<link rel="preconnect" href="//zz.bdstatic.com">
	<link rel="preconnect" href="//sp0.baidu.com">
	<link rel="preconnect" href="//www.google-analytics.com">
	<link rel="preconnect" href="//cdn1.lncld.net">
	<link rel="preconnect" href="//unpkg.com">
	<link rel="preconnect" href="//app-router.leancloud.cn">
	<link rel="preconnect" href="//9qpuwspm.api.lncld.net">
	<link rel="preconnect" href="//gravatar.loli.net">

	<title>手把手带你MIT6.828 - Lab2 | Icegrave</title>

	<meta name="HandheldFriendly" content="True">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
	<meta name="generator" content="hexo">
	<meta name="author" content="Heart-Shaped Box">
	<meta name="description" content>

	
	<meta name="keywords" content="mit6.828, memory management">
	

	
	<link rel="shortcut icon" href="https://mubai.oss-cn-hangzhou.aliyuncs.com/icon.png">
	<link rel="apple-touch-icon" href="https://mubai.oss-cn-hangzhou.aliyuncs.com/icon.png">
	

	
	<meta name="theme-color" content="#3c484e">
	<meta name="msapplication-TileColor" content="#3c484e">
	

	

	

	<meta property="og:site_name" content="Icegrave">
	<meta property="og:type" content="article">
	<meta property="og:title" content="手把手带你MIT6.828 - Lab2 | Icegrave">
	<meta property="og:description" content>
	<meta property="og:url" content="http://yoursite.com/2020/03/04/lab2/">

	
	<meta property="article:published_time" content="2020-03-04T10:03:00+08:00"> 
	<meta property="article:author" content="Heart-Shaped Box">
	<meta property="article:published_first" content="Icegrave, /2020/03/04/lab2/">
	

	
	
	<link rel="stylesheet" href="/css/allinonecss.min.css">

	
	
	
</head>
<body class="post-template">
	<div class="site-wrapper">
		




<header class="site-header post-site-header outer">
    <div class="inner">
        
<nav class="site-nav"> 
    <div class="site-nav-left">
        <ul class="nav">
            <li>
                
                <a href="/" title="Home">HOME</a>
                
            </li>
            
            
            <li>
                <a href="/about" title="ABOUT">ABOUT</a>
            </li>
            
            <li>
                <a href="/archives" title="ARCHIVES">ARCHIVES</a>
            </li>
            
            
        </ul> 
    </div>
    
    <div class="search-button-area">
        <a href="#search" class="search-button">Search ...</a>
    </div>
     
    <div class="site-nav-right">
        
        <a href="#search" class="search-button">Search ...</a>
         
        
<div class="social-links">
    
    <a class="social-link" title="weibo" href="https://weibo.com/" target="_blank" rel="noopener">
        <svg viewbox="0 0 1141 1024" xmlns="http://www.w3.org/2000/svg"><path d="M916.48 518.144q27.648 21.504 38.912 51.712t9.216 62.976-14.336 65.536-31.744 59.392q-34.816 48.128-78.848 81.92t-91.136 56.32-94.72 35.328-89.6 18.944-75.264 7.68-51.712 1.536-49.152-2.56-68.096-10.24-78.336-21.504-79.872-36.352-74.24-55.296-59.904-78.848q-16.384-29.696-22.016-63.488t-5.632-86.016q0-22.528 7.68-51.2t27.136-63.488 53.248-75.776 86.016-90.112q51.2-48.128 105.984-85.504t117.248-57.856q28.672-10.24 63.488-11.264t57.344 11.264q10.24 11.264 19.456 23.04t12.288 29.184q3.072 14.336 0.512 27.648t-5.632 26.624-5.12 25.6 2.048 22.528q17.408 2.048 33.792-1.536t31.744-9.216 31.232-11.776 33.28-9.216q27.648-5.12 54.784-4.608t49.152 7.68 36.352 22.016 17.408 38.4q2.048 14.336-2.048 26.624t-8.704 23.04-7.168 22.016 1.536 23.552q3.072 7.168 14.848 13.312t27.136 12.288 32.256 13.312 29.184 16.384zM658.432 836.608q26.624-16.384 53.76-45.056t44.032-64 18.944-75.776-20.48-81.408q-19.456-33.792-47.616-57.344t-62.976-37.376-74.24-19.968-80.384-6.144q-78.848 0-139.776 16.384t-105.472 43.008-72.192 60.416-38.912 68.608q-11.264 33.792-6.656 67.072t20.992 62.976 42.496 53.248 57.856 37.888q58.368 25.6 119.296 32.256t116.224 0.512 100.864-21.504 74.24-33.792zM524.288 513.024q20.48 8.192 38.912 18.432t32.768 27.648q10.24 12.288 17.92 30.72t10.752 39.424 1.536 42.496-9.728 38.912q-8.192 18.432-19.968 37.376t-28.672 35.328-40.448 29.184-57.344 18.944q-61.44 11.264-117.76-11.264t-88.064-74.752q-12.288-39.936-13.312-70.656t16.384-66.56q13.312-27.648 40.448-51.712t62.464-38.912 75.264-17.408 78.848 12.8zM361.472 764.928q37.888 3.072 57.856-18.432t21.504-48.128-15.36-47.616-52.736-16.896q-27.648 3.072-43.008 23.552t-17.408 43.52 9.728 42.496 39.424 21.504zM780.288 6.144q74.752 0 139.776 19.968t113.664 57.856 76.288 92.16 27.648 122.88q0 33.792-16.384 50.688t-35.328 17.408-35.328-14.336-16.384-45.568q0-40.96-22.528-77.824t-59.392-64.512-84.48-43.52-96.768-15.872q-31.744 0-47.104-15.36t-14.336-34.304 18.944-34.304 51.712-15.36zM780.288 169.984q95.232 0 144.384 48.64t49.152 146.944q0 30.72-10.24 43.52t-22.528 11.264-22.528-14.848-10.24-35.84q0-60.416-34.816-96.256t-93.184-35.84q-19.456 0-28.672-10.752t-9.216-23.04 9.728-23.04 28.16-10.752z"/></svg>
    </a>
    
    
    <a class="social-link" title="github" href="https://github.com/Icegrave0391" target="_blank" rel="noopener">
        <svg viewbox="0 0 1049 1024" xmlns="http://www.w3.org/2000/svg"><path d="M524.979332 0C234.676191 0 0 234.676191 0 524.979332c0 232.068678 150.366597 428.501342 358.967656 498.035028 26.075132 5.215026 35.636014-11.299224 35.636014-25.205961 0-12.168395-0.869171-53.888607-0.869171-97.347161-146.020741 31.290159-176.441729-62.580318-176.441729-62.580318-23.467619-60.841976-58.234462-76.487055-58.234463-76.487055-47.804409-32.15933 3.476684-32.15933 3.476685-32.15933 53.019436 3.476684 80.83291 53.888607 80.83291 53.888607 46.935238 79.963739 122.553122 57.365291 152.97411 43.458554 4.345855-33.897672 18.252593-57.365291 33.028501-70.402857-116.468925-12.168395-239.022047-57.365291-239.022047-259.012982 0-57.365291 20.860106-104.300529 53.888607-140.805715-5.215026-13.037566-23.467619-66.926173 5.215027-139.067372 0 0 44.327725-13.906737 144.282399 53.888607 41.720212-11.299224 86.917108-17.383422 131.244833-17.383422s89.524621 6.084198 131.244833 17.383422C756.178839 203.386032 800.506564 217.29277 800.506564 217.29277c28.682646 72.1412 10.430053 126.029806 5.215026 139.067372 33.897672 36.505185 53.888607 83.440424 53.888607 140.805715 0 201.64769-122.553122 245.975415-239.891218 259.012982 19.121764 16.514251 35.636014 47.804409 35.636015 97.347161 0 70.402857-0.869171 126.898978-0.869172 144.282399 0 13.906737 9.560882 30.420988 35.636015 25.205961 208.601059-69.533686 358.967656-265.96635 358.967655-498.035028C1049.958663 234.676191 814.413301 0 524.979332 0z"/></svg>
    </a>
    
    
    <a class="social-link" title="facebook" href="https://facebook" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

    </a>
    
    
    <a class="social-link" title="twitter" href="https://twitter.com" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

    </a>
    
    
    
    
</div>
    </div>
</nav>
    </div>
</header>


<div id="site-main" class="site-main outer" role="main">
    <div class="inner">
        <header class="post-full-header">
            <div class="post-full-meta">
                <time class="post-full-meta-date" datetime="2020-03-04T02:31:52.000Z">
                    2020-03-04
                </time>
                
                <span class="date-divider">/</span>
                
                <a href="/categories/operating-system/">operating system</a>&nbsp;&nbsp;
                
                
            </div>
            <h1 class="post-full-title">手把手带你MIT6.828 - Lab2</h1>
        </header>
        <div class="post-full ">
            
            <figure class="post-full-image" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfwldfuklj31li0u0hdu.jpg)">
            </figure>
            
            <div class="post-full-content">
                <article id="photoswipe" class="markdown-body">
                    <h1 id="Lab2-Memory-Management"><a href="#Lab2-Memory-Management" class="headerlink" title="Lab2 Memory Management"></a>Lab2 Memory Management</h1><p>官方文档: <a href="https://pdos.csail.mit.edu/6.828/2018/lec/" target="_blank" rel="noopener">lectures</a></p>
<h3 id="gt-实验介绍"><a href="#gt-实验介绍" class="headerlink" title="&gt; 实验介绍"></a>&gt; 实验介绍</h3><p>在本次实验中，我们将为操作系统编写内存管理代码。内存管理包括两个组件：</p>
<ol>
<li>第一个是内核的物理内存分配器，它可以使内核分配并释放内存。我们的分配器以4096Bytes为单位进行操作，该单位称为页面（Page）。</li>
</ol>
<p>我们将维护一个数据结构，这个数据结构能够记录哪些物理pages是空闲的，哪些是已经分配的，以及多少个进程正在共享每个分配的页。同时我们需要编写程序来分配和释放内存页面。</p>
<ol>
<li>第二个组件是虚拟内存(virtual memory)。它将内核与用户软件使用的虚拟内存映射到物理内存中的地址。当指令使用内存时，x86硬件的内存管理单元(MMU)执行这个映射过程。</li>
</ol>
<p>我们将根据规范来修改jos以设置MMU的页表。</p>
<h3 id="gt-实验准备"><a href="#gt-实验准备" class="headerlink" title="&gt; 实验准备"></a>&gt; 实验准备</h3><p>根据官方网站的提示，将lab2分支进行merge，合并到lab1中。</p>
<p>实验二包括如下的新文件：</p>
<ul>
<li>inc/memlayout.h 描述了虚拟地址空间的结构</li>
<li>kern/pmap.c 需要修改、添加代码以完成实验</li>
<li>kern/pmap.h 定义了PageInfo结构 用来管理物理页状态</li>
<li>kern/kclock.h</li>
<li>kern/kclock.c 操作电池供电的时钟以及CMOS RAM硬件</li>
</ul>
<p>个人建议在实验之前再次对段/页式管理有所了解（附上链接）：</p>
<p>80386内存的基本概念和方式：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s02_01.htm" target="_blank" rel="noopener">Memory Organization</a></p>
<p>这个章节中包含了段/页式管理，详细阅读：<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c05.htm" target="_blank" rel="noopener">Memory Management</a></p>
<h2 id="Part1-Physical-Page-Management"><a href="#Part1-Physical-Page-Management" class="headerlink" title="Part1: Physical Page Management"></a>Part1: Physical Page Management</h2><p>操作系统必须追踪物理内存从而知晓哪些内存是空闲的，哪些内存是正在使用的。JOS使用页面粒度(page granularity)管理PC的物理内存，以便利用MMU映射和保护每一片被分配的内存。</p>
<p>首先我们<strong>需要实现一个物理内存分配器</strong>(physical page allocator)。它将根据<code>struct PageInfo</code>链表进行空闲页面的追踪。</p>
<p>注意：<strong>我们必须先实现物理页分配器</strong>，然后才能编写其余的虚拟内存实现。因为我们的页表管理代码将需要<strong>分配用于储存页表的物理内存</strong>。</p>
<p>在继续之前，我们仍然需要一些背景知识，这可能仍然有些painful…</p>
<h3 id="gt-bootloader读入kernel后的内存分布"><a href="#gt-bootloader读入kernel后的内存分布" class="headerlink" title="&gt; bootloader读入kernel后的内存分布"></a>&gt; bootloader读入kernel后的内存分布</h3><p><img alt="image-20200304125040479" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gchsvxxlc1j30j505qmy1.jpg" data-index="0" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gchsvxxlc1j30j505qmy1.jpg"></p>
<p>上图的代码是kernel刚刚被读入内存，还没有开启保护方式的结构。</p>
<h4 id="gt-gt-回顾Lab1"><a href="#gt-gt-回顾Lab1" class="headerlink" title="&gt;&gt; 回顾Lab1"></a>&gt;&gt; 回顾Lab1</h4><p>通过lab1，我们知道了，jos启动的过程实际上就是把bootsector的内容读到了0x7c00的位置（注意：bootsector的代码在编译的时候已经故意将逻辑地址的首地址定在了0x7c00上），bootsector中的代码开始执行的时候会从磁盘上紧接着自己的第二个扇区开始一直读8个扇区(一共8x512 = 4K，ELF头的大小)一直到0x10000(64KB)的地方，然后通过对ELF头的解析，得到kernel模块编译出来之后占的大小，并将kernel读到物理内存0x100000(1MB)的地方。然后设置好GDT并且调用<code>i386_init()</code>函数，而<code>i386_init()</code>函数将在自己的BSS区域清零后，调用<code>cons_init()</code>函数设置好屏幕显示设备为cprintf的运行做好准备。</p>
<p>之后就会调用<code>i386_detect_memory()</code>函数和<code>i386_vm_init()</code>函数。前者的主要功能是读CMOS取得物理内存的实际大小，后者是本次lab的主要函数，将在之后进行讨论。当然<code>i386_init()</code>最后会调用<code>monitor(NULL)</code>，进入循环处理用户终端的交互。</p>
<p>调用<code>i386_init()</code>之后，系统将会重载GDT，新的GDT：</p>
<p><img alt="image-20200304144728023" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gchw9gn2sdj30h002i0sy.jpg" data-index="1" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gchw9gn2sdj30h002i0sy.jpg"></p>
<p><strong>新的GDT后两项的base是-KERNBASE</strong>。如果KERNBASE=0xf0000000，则GDT的base为0x00100000，通过保护模式的段式地址转换机制(pa = la+base)，将程序内的KERNBASE开始的逻辑地址转换成物理地址。</p>
<h3 id="gt-JOS分段和分页"><a href="#gt-JOS分段和分页" class="headerlink" title="&gt; JOS分段和分页"></a>&gt; JOS分段和分页</h3><p>同时我们需要知道JOS是如何使用分段和分页的：[How we will use paging (and segments) in JOS](<a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-josmem.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2018/lec/l-josmem.html</a></p>
<p>虚拟内存是将很小的物理内存映射到很大的虚拟内存空间，这个映射关系需要一个输入地址和一个输出地址才能作用。<strong>物理地址</strong>是物理内存中真实的地址，可以直接由硬件寻址得到；<strong>虚拟地址/线性地址</strong>是物理地址通过转换得到的，用于虚拟内存空间索引的地址。</p>
<p><img alt="image-20200304125540629" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcht15732bj30hk0cl0st.jpg" data-index="2" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcht15732bj30hk0cl0st.jpg"></p>
<p><code>mmu.h</code>对我们线性地址的结构有了详细的描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A linear address 'la' has a three-part structure as follows:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +--------10------+-------10-------+---------12----------+</span></span><br><span class="line"><span class="comment">// | Page Directory |   Page Table   | Offset within Page  |</span></span><br><span class="line"><span class="comment">// |      Index     |      Index     |                     |</span></span><br><span class="line"><span class="comment">// +----------------+----------------+---------------------+</span></span><br><span class="line"><span class="comment">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span></span><br><span class="line"><span class="comment">//  \---------- PGNUM(la) ----------/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The PDX, PTX, PGOFF, and PGNUM macros decompose linear addresses as shown.</span></span><br><span class="line"><span class="comment">// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),</span></span><br><span class="line"><span class="comment">// use PGADDR(PDX(la), PTX(la), PGOFF(la)).</span></span><br></pre></td></tr></table></figure>
<p>我们的线性地址分为三段：</p>
<ul>
<li><code>Page directory index</code>：页目录的序号(10位) -&gt; 2^10个页表</li>
<li><code>Page table index</code>：页表的序号(10位) -&gt; 2^10页</li>
<li><code>Page offset</code>：地址在页内的偏移(12位) -&gt; 2^12 = 4K</li>
</ul>
<p>也就是说，每个页表有1024个页，每个页目录有1024个页表，每一页的大小是4KB。</p>
<p><code>memlayout.h</code>中可以看整个虚拟内存空间的分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Virtual memory map:                                Permissions</span></span><br><span class="line"><span class="comment"> *                                                    kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    4 Gig --------&gt;  +------------------------------+</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     |   Remapped Physical Memory   | RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span></span><br><span class="line"><span class="comment"> *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span></span><br><span class="line"><span class="comment"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span></span><br><span class="line"><span class="comment"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span></span><br><span class="line"><span class="comment"> *                     |          RO PAGES            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span></span><br><span class="line"><span class="comment"> *                     |           RO ENVS            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span></span><br><span class="line"><span class="comment"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebff000</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span></span><br><span class="line"><span class="comment"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span></span><br><span class="line"><span class="comment"> *                     |      Normal User Stack       | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebfd000</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span></span><br><span class="line"><span class="comment"> *                     |     Program Data &amp; Heap      |</span></span><br><span class="line"><span class="comment"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |  User STAB Data (optional)   |                 PTSIZE</span></span><br><span class="line"><span class="comment"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *    0 ------------&gt;  +------------------------------+                 --+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.</span></span><br><span class="line"><span class="comment"> *     "Empty Memory" is normally unmapped, but user programs may map pages</span></span><br><span class="line"><span class="comment"> *     there if desired.  JOS user programs map pages temporarily at UTEMP.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>0xf0000000</code>以上：<code>Remapped physical memory</code>，物理内存的原样映射，这一部分为虚拟地址</li>
<li><code>0xefc00000</code>以上：内核栈区域，存放各个CPU的内核栈。<ul>
<li><code>0xef800000</code>：<code>ULIM</code>，内核内存区和用户内存区的分界线，这以上用户不可读写</li>
</ul>
</li>
<li><code>0xef400000</code>以上：页表区域<ul>
<li><code>0xef400000</code>：<code>UVPT</code>，页表区域的开始。</li>
</ul>
</li>
<li><code>0xef000000</code>以上：页区域<ul>
<li><code>0xef000000</code>：<code>UPAGES</code>，页区域的开始。</li>
</ul>
</li>
<li><code>0xeec00000</code>以上：当前进程的环境变量区域<ul>
<li><code>0xeec00000</code>：<code>UTOP</code>，用户只读区和读写区的分界线，这以上到<code>ULIM</code>之间用户只有读权限</li>
</ul>
</li>
<li><code>`0xeebff000 1 PGSIZE</code>：用户的异常栈</li>
<li><code>0xeebfe000 一段留空内存</code></li>
<li><code>0xeebfd000 1 PGSIZE</code>：用户栈，可以增长</li>
<li><code>0x00800000</code>以上：用户的堆区域和程序数据</li>
<li>以下：用户的符号表区域和空内存</li>
</ul>
<p><strong>exercise 1:</strong></p>
<p>我们需要实现<code>kern/pmap.c</code>中的以下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot_alloc()</span><br><span class="line">mem_init()   <span class="comment">//（完成直到调用check_page_free_list(1)为止）</span></span><br><span class="line">page_init()</span><br><span class="line">page_alloc()</span><br><span class="line">page_free()</span><br></pre></td></tr></table></figure>
<p>完成后，我们可以在boot jos的过程中使用<code>check_page_free_list()</code>以及<code>check_page_alloc()</code>来检查我们的物理内存分配器。</p>
<p>tips：使用assert()进行断言验证。</p>
<ul>
<li><code>boot_alloc()</code></li>
</ul>
<p>这个函数的解释是，<strong>建立在虚拟内存系统过程中用来为数据结构分配内存空间</strong>。</p>
<p>值得注意的是，<code>end</code>变量是在<code>kernel.ld</code>中的<code>.bss</code>段定义的，也就是说其<strong>首次调用的时候，从内核的bss段结束处分配一个内存块。</strong></p>
<p>这个bss段在虚拟地址空间<code>0xf0000000</code>以上的部分，也就是上图中<strong>物理地址的直接映射区</strong>。从这个地方开始，我们就开始建立用于管理虚拟内存的内核数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This simple physical memory allocator is used only while JOS is setting</span></span><br><span class="line"><span class="comment">// up its virtual memory system.  page_alloc() is the real allocator.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If n&gt;0, allocates enough pages of contiguous physical memory to hold 'n'</span></span><br><span class="line"><span class="comment">// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If n==0, returns the address of the next free page without allocating</span></span><br><span class="line"><span class="comment">// anything.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If we're out of memory, boot_alloc should panic.</span></span><br><span class="line"><span class="comment">// This function may ONLY be used during initialization,</span></span><br><span class="line"><span class="comment">// before the page_free_list list has been set up.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">boot_alloc(<span class="keyword">uint32_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *nextfree;	<span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">	<span class="keyword">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line">	<span class="comment">// 'end' is a magic symbol automatically generated by the linker, &lt;-在kernel.ld中</span></span><br><span class="line">	<span class="comment">// which points to the end of the kernel's bss segment:</span></span><br><span class="line">	<span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line">	<span class="comment">// to any kernel code or global variables.</span></span><br><span class="line">	<span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">		nextfree = ROUNDUP((<span class="keyword">char</span> *) end, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></span><br><span class="line">	<span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">	<span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 2: Your code here.</span></span><br><span class="line">	<span class="comment">//return address of next free page</span></span><br><span class="line">	<span class="keyword">if</span>(n ==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> nextfree;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//allocate</span></span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree = ROUNDUP((<span class="keyword">char</span> *)(nextfree + n), PGSIZE);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mem_init()</code></li>
</ul>
<p>这个函数一上来就调用<code>boot_alloc()</code>分配了一页的空闲内存并且初始化，该区域的指针为<code>kern_pgdir</code>，换句话说<strong>这就是我们的页目录</strong><code>page directory</code>。</p>
<p>接下来我们需要做的工作是为页数组<code>pages</code>分配虚拟内存，<code>pages</code>以及其数据结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Page descriptor structures, mapped at UPAGES.</span></span><br><span class="line"><span class="comment"> * Read/write to the kernel, read-only to user programs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each struct PageInfo stores metadata for one physical page.</span></span><br><span class="line"><span class="comment"> * Is it NOT the physical page itself, but there is a one-to-one</span></span><br><span class="line"><span class="comment"> * correspondence between physical pages and struct PageInfo's.</span></span><br><span class="line"><span class="comment"> * You can map a struct PageInfo * to the corresponding physical address</span></span><br><span class="line"><span class="comment"> * with page2pa() in kern/pmap.h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> &#123;</span></span><br><span class="line">	<span class="comment">// Next page on the free list.</span></span><br><span class="line">  <span class="comment">//pp_link 是下一项地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pp_ref is the count of pointers (usually in page table entries)</span></span><br><span class="line">	<span class="comment">// to this page, for pages allocated using page_alloc.</span></span><br><span class="line">	<span class="comment">// Pages allocated at boot time using pmap.c's</span></span><br><span class="line">	<span class="comment">// boot_alloc do not have valid reference count fields.</span></span><br><span class="line">	<span class="comment">//pp_ref 是引用数量，凡是调用page_alloc 分配了该页的进程都会引用</span></span><br><span class="line">	<span class="keyword">uint16_t</span> pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span>		<span class="comment">// Physical page state array</span></span><br><span class="line"><span class="keyword">size_t</span> npages;			<span class="comment">// Amount of physical memory (in pages)</span></span><br><span class="line">										<span class="comment">//npages在kernel中i386_detect_memory的时候被赋值</span></span><br></pre></td></tr></table></figure>
<p>也就是说，<code>PageInfo</code>该结构体就是一个能够与物理内存映射的页面。<code>pages</code>数组就是每一个分页的信息，可以通过函数将其转换成物理地址，换句话说该数组中的每一个元素都映射到一个物理页面。我们这里就将所有物理内存做一个到pages中的映射。</p>
<p>我们直接调用<code>boot_alloc()</code>即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span></span><br><span class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line"><span class="comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span></span><br><span class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">n = npages * <span class="keyword">sizeof</span>(struct PageInfo);</span><br><span class="line">pages = (struct PageInfo *)boot_alloc(n);</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, n);</span><br></pre></td></tr></table></figure>
<p>该步骤完毕后，所有的物理内存都已经按照页面大小划分成了页面，并依次存放在了pages中。</p>
<ul>
<li><code>page_init()</code></li>
</ul>
<p>我们刚才已经为页表数组分配了空间并初始化，这一步我们需要初始化页的数据结构以及<strong>初始化能够分配的空闲物理空间页的链表(memory free list)</strong>。</p>
<p>原始代码已经给出了，但是我们需要将其进行修改，因为该代码将所有物理内存页都标记为free，这就导致一些问题：</p>
<ol>
<li>物理页面0处应该是used，这部分保存着实模式的IDT和BIOS的数据结构，这些结构我们可能之后还会用到。</li>
<li>还记得lab1中为了向后兼容8086而留下的<code>I/O hole</code>吗？这一部分内存是不能够被使用的，也就不能标记为free。</li>
<li><code>I/O hole</code>之后的extended memory（从<code>0x00100000</code>(1MB)开始，参考lab1笔记的<code>PC物理空间</code>部分），这些内存中有一部分被kernel占用了，存放kernel的代码和数据结构，不能被标记为free。</li>
</ol>
<p>对于可用的空间，我们有<code>npages_basemem</code>，这是在如下的<code>i386_detect_memory</code>函数detect内存时确定的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">i386_detect_memory(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> basemem, extmem, ext16mem, totalmem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use CMOS calls to measure available base &amp; extended memory.</span></span><br><span class="line">	<span class="comment">// (CMOS calls return results in kilobytes.)</span></span><br><span class="line">	basemem = nvram_read(NVRAM_BASELO);</span><br><span class="line">	extmem = nvram_read(NVRAM_EXTLO);</span><br><span class="line">	ext16mem = nvram_read(NVRAM_EXT16LO) * <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Calculate the number of physical pages available in both base</span></span><br><span class="line">	<span class="comment">// and extended memory.</span></span><br><span class="line">	<span class="keyword">if</span> (ext16mem)</span><br><span class="line">		totalmem = <span class="number">16</span> * <span class="number">1024</span> + ext16mem;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (extmem)</span><br><span class="line">		totalmem = <span class="number">1</span> * <span class="number">1024</span> + extmem;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		totalmem = basemem;</span><br><span class="line"></span><br><span class="line">	npages = totalmem / (PGSIZE / <span class="number">1024</span>);</span><br><span class="line">	npages_basemem = basemem / (PGSIZE / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"Physical memory: %uK available, base = %uK, extended = %uK\n"</span>,</span><br><span class="line">		totalmem, basemem, totalmem - basemem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的重点就是，如何知道extended memory起始的哪部分区域被kernel占用？实际上我们可以调用<code>boot_alloc(0)</code>得知我们分配的页目录的最后的区域，这个区域之后就全是空闲了。</p>
<p>最终我们完成的<code>page_init()</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line">	<span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line">	<span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">	<span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">	<span class="comment">//     in case we ever need them.  (Currently we don't, but...)</span></span><br><span class="line">	<span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">	<span class="comment">//     is free.</span></span><br><span class="line">	<span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">	<span class="comment">//     never be allocated.</span></span><br><span class="line">	<span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">	<span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">	<span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">	<span class="comment">//     page tables and other data structures?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Change the code to reflect this.</span></span><br><span class="line">	<span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">	<span class="comment">// free pages!</span></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="comment">// for (i = 0; i &lt; npages; i++) &#123;</span></span><br><span class="line">	<span class="comment">// 	pages[i].pp_ref = 0;</span></span><br><span class="line">	<span class="comment">// 	pages[i].pp_link = page_free_list;</span></span><br><span class="line">	<span class="comment">// 	page_free_list = &amp;pages[i];</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// 跳过page[0]，分配npages_basemem数量</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++)&#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 无视I/O hole，这部分之前使用了npages_basemem所以不用操作</span></span><br><span class="line">	<span class="comment">// 从extended_memory的kernel使用之后的位置开始分配</span></span><br><span class="line">			<span class="comment">// 首先取出最后一块目录项的地址</span></span><br><span class="line">	<span class="keyword">physaddr_t</span> next_page = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line">			<span class="comment">// 得到索引</span></span><br><span class="line">	<span class="keyword">size_t</span> idx_free = next_page / PGSIZE;</span><br><span class="line">	<span class="keyword">for</span>(i = idx_free; i &lt; npages; i++)&#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link =page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步完成之后，我们就已经配置好了一个<code>page_free_list</code>，也就是说我们初始化了一个物理内存的所有可用空间页的链表。</p>
<ul>
<li><code>page_alloc()</code></li>
</ul>
<p>这个函数的作用很简单，就是请求页面，即从<code>page_free_list</code>中分配一个空闲的主存页，我们只需要按照注释实现功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">alloc_page</span> = <span class="title">page_free_list</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(!page_free_list)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// move page_free_list</span></span><br><span class="line">	page_free_list = page_free_list -&gt; pp_link;</span><br><span class="line">	<span class="comment">// init free page</span></span><br><span class="line">	alloc_page -&gt; pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;</span><br><span class="line">    <span class="comment">// page2kva 是将输入的PageInfo结构体转换成对应的pages[]虚拟地址</span></span><br><span class="line">    <span class="comment">//（因为pages都是通过boot_alloc分配在kernel区，所以是kva）</span></span><br><span class="line">    <span class="comment">// kva 是kernel virtual address的缩写</span></span><br><span class="line">		<span class="built_in">memset</span>(page2kva(alloc_page), <span class="number">0</span>, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> alloc_page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个部分完成后，我们就实现了分配空闲内存页的操作。</p>
<ul>
<li><code>page_free()</code></li>
</ul>
<p>同样这个函数就是字面意思，释放一块空闲页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return a page to the free list.</span></span><br><span class="line"><span class="comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">	<span class="keyword">if</span>(pp -&gt; pp_ref)&#123;</span><br><span class="line">		panic(<span class="string">"[page_free] page : %p is still being used"</span>, pp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pp -&gt; pp_link)&#123;</span><br><span class="line">		panic(<span class="string">"[page_free] page : %p is already freed"</span>, pp);</span><br><span class="line">	&#125;</span><br><span class="line">	pp -&gt; pp_link = page_free_list;</span><br><span class="line">	page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part2-Virtual-Memory"><a href="#Part2-Virtual-Memory" class="headerlink" title="Part2: Virtual Memory"></a>Part2: Virtual Memory</h2><p><strong>exercise 2: </strong></p>
<p>阅读<a href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm" target="_blank" rel="noopener">Intel 80386 Reference Manual</a>第五章以及第六章。这两章的主要内容都是段式和页式管理的方式，以及80386的保护模式。关键内容将在下面呈现：</p>
<h3 id="gt-段式管理-Segment"><a href="#gt-段式管理-Segment" class="headerlink" title="&gt; 段式管理-Segment"></a>&gt; 段式管理-Segment</h3><p>回顾一下lab1中我们介绍了段式管理的基本流程：程序首先将对应的<strong>段选择子（数组索引）加载到段寄存器</strong>中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，然后<strong>根据段寄存器的段选择子再确定最终要使用的段描述符</strong>。结合段描述符中包含的信息加上指令自身的地址构造出实际的物理地址。</p>
<p>可能这段话有些抽象，我们需要详细说明这个过程。</p>
<h4 id="gt-gt-描述符-Descriptors"><a href="#gt-gt-描述符-Descriptors" class="headerlink" title="&gt;&gt; 描述符(Descriptors)"></a>&gt;&gt; 描述符(Descriptors)</h4><p>在分段保护方式下，<strong>每一个段都需要很多相应的描述信息（包括但不限于段基址、段大小、特权级等）</strong>，描述符是用来统一的描述这些数据。注意：描述符是由编译器、链接器、加载器或者操作系统创建的，而非应用程序的程序员创建的。</p>
<p>对于一个描述符（<code>64位</code>），我们将其分为4个16位（蓝色标记），其结构如图：</p>
<p><img alt="image-20200305101256359" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcity4nq0jj30hg0bpwer.jpg" data-index="3" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcity4nq0jj30hg0bpwer.jpg"></p>
<ul>
<li>第一个16位：段界限（segment limit）。段界限用于限定段的大小，但是要注意的是段界限实际上有20位，它需要和描述符中另一段4bits的数据拼接（如上图）。</li>
<li>第二个16位：段基址（segment base）。段基址用于描述段在虚拟地址的起始地址。同样显然虚拟地址应该是32位的，它也需要和描述符中的其他数据位拼接（如上图）</li>
<li><p>第三个16位：</p>
<ul>
<li><code>P</code>：<strong>存在位</strong>，表示该描述符对应的段是否已经读入内存。</li>
<li><code>DPL</code>：长度为两位，表示该段所属的特权级</li>
<li><code>1</code>或<code>0</code>：记录段的类型是存储段还是系统段</li>
<li><code>TYPE</code>：记录段的属性<ul>
<li>如果是存储段，那么是代码段还是数据段</li>
<li>段的读写权限如何</li>
</ul>
</li>
<li><code>A</code>：访问位，记录段是否被访问过</li>
</ul>
</li>
<li><p>第四个16位：</p>
<ul>
<li><code>G</code>：<strong>粒度位</strong>，G=0说明段长度的单位是<code>Byte</code>，而G=1说明单位是<code>page</code>。</li>
<li><code>X</code>：用于区分32位和16位访问方式。</li>
<li><code>O</code>和<code>AVL</code>：保留位和系统专用位</li>
<li><code>LIMIT</code>：段界限的16-19位</li>
</ul>
</li>
</ul>
<p>这样，有了段描述符，我们就能描述一个段的全部信息。</p>
<h4 id="gt-gt-段描述符表-Descriptor-Table"><a href="#gt-gt-段描述符表-Descriptor-Table" class="headerlink" title="&gt;&gt; 段描述符表(Descriptor Table)"></a>&gt;&gt; 段描述符表(Descriptor Table)</h4><p>顾名思义，段描述符表就是用来存储段描述符的数据结构，它是由8Bytes为一个单位的元素组成的数组。实际上有如下两种段描述符表：</p>
<ul>
<li><p>LDT：局部描述符表。<strong>每一个进程都有一个局部描述符表</strong>，存放在系统的特定的位置。LDT中存有进程对应的代码以及数据段位置等信息。</p>
</li>
<li><p>GDT：全局描述符表。全局描述符表一定是存在且唯一的。他存放操作系统内核所使用的描述符以及所有系统段的描述符。同时可以通过GDT索引LDT。</p>
</li>
</ul>
<p><img alt="image-20200305102057147" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gciu6gqjzrj30h00czt8r.jpg" data-index="4" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gciu6gqjzrj30h00czt8r.jpg"></p>
<h4 id="gt-gt-描述符表寄存器-GDTR-LDTR"><a href="#gt-gt-描述符表寄存器-GDTR-LDTR" class="headerlink" title="&gt;&gt; 描述符表寄存器(GDTR/LDTR)"></a>&gt;&gt; 描述符表寄存器(GDTR/LDTR)</h4><p>显然，描述符表寄存器是处理器用于定位GDT和LDT在内存中的位置的寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdtr</span> &#123;</span></span><br><span class="line">	u16 limite;    <span class="comment">//描述符表的表限长</span></span><br><span class="line">	u32 base;      <span class="comment">//描述符表的基址</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>
<p>机器刚刚加电，或者处理器复位后，表基址被默认设置为0，而表限长默认设置为0xffff。在保护模式初始化的过程中，必须给GDTR加载新的值。可以使用lgdt指令为GDTR加载新的值。</p>
<h4 id="gt-gt-段选择子-Selectors"><a href="#gt-gt-段选择子-Selectors" class="headerlink" title="&gt;&gt; 段选择子(Selectors)"></a>&gt;&gt; 段选择子(Selectors)</h4><p>段选择子（2Bytes）用于<strong>选择特定的描述符表以及表中特定的描述符</strong>。段选择子一般都是被放置于段寄存器中，段选择子由<strong>13位的索引</strong>、<strong>1位的表指示位</strong>以及<strong>2位的请求特权级</strong>三部分组成。其中<strong>索引指定了描述符</strong>；<strong>表指示位选择应该访问的描述符表</strong>-0代表全局描述符表，1代表局部描述符表；<strong>请求特权级用于段级的保护机制</strong>，自0到4分别代表ring 0 到ring 3。结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">selector</span> &#123;</span></span><br><span class="line">    u16 index:<span class="number">13</span>;      <span class="comment">//用于指定描述符</span></span><br><span class="line">    u16 ti:<span class="number">1</span>;          <span class="comment">//用于访问描述符表 0-GDT   1-LDT</span></span><br><span class="line">    u16 rpl:<span class="number">2</span>;         <span class="comment">//请求特权级保护机制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gt-页式管理-Pages"><a href="#gt-页式管理-Pages" class="headerlink" title="&gt; 页式管理(Pages)"></a>&gt; 页式管理(Pages)</h3><h4 id="gt-gt-Linear-Address"><a href="#gt-gt-Linear-Address" class="headerlink" title="&gt;&gt; Linear Address"></a>&gt;&gt; Linear Address</h4><p>对于虚拟地址的构成，再次将上文的图片搬上来：</p>
<p><img alt="image-20200305150546864" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcj2etkyucj30h507ft8n.jpg" data-index="5" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcj2etkyucj30h507ft8n.jpg"></p>
<h4 id="gt-gt-页表-Page-Tables"><a href="#gt-gt-页表-Page-Tables" class="headerlink" title="&gt;&gt;页表(Page Tables)"></a>&gt;&gt;页表(Page Tables)</h4><p>页表可以理解为是32bits的页说明符(Page specifiers)的数组。页表本身就是一页，就代表了它本身占用4KB的内存以及其中包含1KB的元素（每个页说明符元素占32-bits）。</p>
<p>而80386可以采用多级页表，比如上图的二级页表。这种情况MMU在索引一个线性地址LA的时候，首先取出LA中的页目录DIR(高10位)，然后这种情况下<code>cr3</code>寄存器（也称为页目录基址寄存器page directory base register（PDBR））中存放的是当前页目录的首地址，通过DIR页目录的内容索引到LA所在的<strong>页表首地址</strong>。然后再通过LA中间部分的10位PAGE位（<strong>页表索引部分</strong>），根据DIR找到的页表首地址结合找到页表项。</p>
<p>该过程中，页目录表项被称为DIR Entry，页表表项被称为Page Table Entry。结构在上图已经非常清晰。</p>
<h4 id="gt-gt-页表项-Page-Table-Entries"><a href="#gt-gt-页表项-Page-Table-Entries" class="headerlink" title="&gt;&gt;页表项(Page-Table Entries)"></a>&gt;&gt;页表项(Page-Table Entries)</h4><p>无论是哪一级别的页表，其中的表项的形式都是相同的（无论是DIR Entry还是Page Table Entry），如下所示：</p>
<p><img alt="image-20200305152142276" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcj2ve1m96j30ft04zq2v.jpg" data-index="6" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcj2ve1m96j30ft04zq2v.jpg"></p>
<p>注：如果是两级页表，那DIR Entry(PDE)中的<code>page frame address</code>部分就是索引到的页表的地址，Page Table Entry(PTE)中的该部分则是索引到的物理页（page frame）。</p>
<p>而最低12位就是权限位，表示该项的各种权限。其中最低位<code>P</code>（Present Bit）代表该entry项是否可以用于地址转换，如果为0则表示不可以使用。</p>
<h3 id="2-1-Virtual-Linear-and-Physical-Addresses"><a href="#2-1-Virtual-Linear-and-Physical-Addresses" class="headerlink" title="2.1 Virtual, Linear and Physical Addresses"></a>2.1 Virtual, Linear and Physical Addresses</h3><p>x86中，虚拟地址（virtual address）是由段选择子和段内偏移组成的（段式管理），而线性地址（linear address）是段翻译机制翻译后得到的地址，之所以该地址不能称为物理地址，是因为还未经过页翻译机制。线性地址经过页翻译之后，得到物理地址也就是内存的实际位置：</p>
<p><img alt="image-20200305153427296" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcj38nqj5yj30h403t74e.jpg" data-index="7" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcj38nqj5yj30h403t74e.jpg"></p>
<p><strong>在JOS中默认的boot过程中，我们通过boot.S设置了GDT，GDT中每个描述符的段基址base为0且段限长limit为0xffffffff，也就是说lab2中，我们不涉及内存的分段机制。</strong></p>
<p>回忆lab1的part3：<code>kern/entrypgdir.c</code>将物理地址的0x00000000-0x00400000（<code>4M</code>）映射为虚拟地址0xf0000000-0xf0400000（<code>4M</code>），同时也将0x00000000-0x00400000的虚拟地址翻译为0x00000000-0x00400000。</p>
<p>本实验中，我们要映射物理内存的最低256M到<code>0xf0000000</code>(KERNBASE)开始的虚拟地址。此外还要映射其它一些虚拟地址空间。</p>
<p><strong>exercise 3:</strong></p>
<p>我们首先进入qemu-gdb进入调试状态，输入<code>ctrl-a c</code>进入qemu monitor。在这里我们需要用到如下几条指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xp/Nx paddr -- 查看paddr物理地址处开始的，N个字的16进制的表示结果。</span><br><span class="line">info registers -- 展示所有内部寄存器的状态。</span><br><span class="line">info mem -- 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。</span><br><span class="line">info pg -- 展示当前页表的结构。</span><br></pre></td></tr></table></figure>
<p>gdb的<code>x/Nx addr</code>指令是用来查看指定虚拟地址的数据的。</p>
<p>我们这里将存在映射关系的虚拟地址与物理地址的内容进行对比，观察是否一致：</p>
<p><img alt="image-20200305160716822" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcj46t9za7j318f04d0ur.jpg" data-index="8" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcj46t9za7j318f04d0ur.jpg"></p>
<p>使用<code>(qemu)info mem</code>看看内存映射关系以及权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info mem</span><br><span class="line">0000000000000000-0000000000400000 0000000000400000 -r-</span><br><span class="line">00000000f0000000-00000000f0400000 0000000000400000 -rw</span><br></pre></td></tr></table></figure>
<p>刚进入kernel保护模式时，使用<code>(qemu)info pg</code>查看当前页表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info pg</span><br><span class="line">VPN range     Entry         Flags        Physical page</span><br><span class="line">[00000-003ff]  PDE[000]     ---------P</span><br><span class="line">  [00000-003ff]  PTE[000-3ff] --------WP 00000-003ff</span><br><span class="line">[f0000-f03ff]  PDE[3c0]     --------WP</span><br><span class="line">  [f0000-f03ff]  PTE[000-3ff] --------WP 00000-003ff</span><br></pre></td></tr></table></figure>
<p>kernal运行完之后加载完成后再次使用命令<code>(qemu)info pg</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info pg</span><br><span class="line">VPN range     Entry         Flags        Physical page</span><br><span class="line">[00000-003ff]  PDE[000]     ----A----P</span><br><span class="line">  [00000-00000]  PTE[000]     --------WP 00000</span><br><span class="line">  [00001-0009f]  PTE[001-09f] ---DA---WP 00001-0009f</span><br><span class="line">  [000a0-000b7]  PTE[0a0-0b7] --------WP 000a0-000b7</span><br><span class="line">  [000b8-000b8]  PTE[0b8]     ---DA---WP 000b8</span><br><span class="line">  [000b9-000ff]  PTE[0b9-0ff] --------WP 000b9-000ff</span><br><span class="line">  [00100-00102]  PTE[100-102] ----A---WP 00100-00102</span><br><span class="line">  [00103-00111]  PTE[103-111] --------WP 00103-00111</span><br><span class="line">  [00112-00112]  PTE[112]     ---DA---WP 00112</span><br><span class="line">  [00113-00114]  PTE[113-114] --------WP 00113-00114</span><br><span class="line">  [00115-003ff]  PTE[115-3ff] ---DA---WP 00115-003ff</span><br><span class="line">[f0000-f03ff]  PDE[3c0]     ----A---WP</span><br><span class="line">  [f0000-f0000]  PTE[000]     --------WP 00000</span><br><span class="line">  [f0001-f009f]  PTE[001-09f] ---DA---WP 00001-0009f</span><br><span class="line">  [f00a0-f00b7]  PTE[0a0-0b7] --------WP 000a0-000b7</span><br><span class="line">  [f00b8-f00b8]  PTE[0b8]     ---DA---WP 000b8</span><br><span class="line">  [f00b9-f00ff]  PTE[0b9-0ff] --------WP 000b9-000ff</span><br><span class="line">  [f0100-f0102]  PTE[100-102] ----A---WP 00100-00102</span><br><span class="line">  [f0103-f0111]  PTE[103-111] --------WP 00103-00111</span><br><span class="line">  [f0112-f0112]  PTE[112]     ---DA---WP 00112</span><br><span class="line">  [f0113-f0114]  PTE[113-114] --------WP 00113-00114</span><br><span class="line">  [f0115-f03ff]  PTE[115-3ff] ---DA---WP 00115-003ff</span><br></pre></td></tr></table></figure>
<p>一旦我们进入了保护模式，我们就无法直接使用物理地址或者线性地址，MMU会将所有内存引用转换为虚拟地址。</p>
<p>JOS的kernel通常需要将地址作为不透明值或者integer进行操作，而不对其进行解引用（比如在物理内存分配器中）。为了记录代码，JOS内核有两种表示方式：</p>
<ul>
<li><code>uintptr_t</code>：代表虚拟地址，同普通指针一样</li>
<li><code>physaddr_t</code>：代表物理地址</li>
</ul>
<p>实际上他们都只是<code>uint32_t</code>的别名。</p>
<p>注意：我们不能直接对int类型进行解引用，而是先转换为指针类型。而且对于<code>physaddr_t</code>转换成的指针类型不能解引用，因为MMU会将其视为虚拟地址，这样导致我们无法得到正确的内容。</p>
<p><strong>Question:</strong> </p>
<p>假定下面的代码正确，x应该是什么类型？<code>physaddr_t</code>还是<code>uintaddr_t</code>？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mystery_t</span> x;</span><br><span class="line"><span class="keyword">char</span>* value = return_a_pointer();</span><br><span class="line">*value = <span class="number">10</span>;</span><br><span class="line">x = (<span class="keyword">mystery_t</span>) value;</span><br></pre></td></tr></table></figure>
<p>肯定是<code>uintaddr_t</code>，因为第三行可以对指针value进行解引用，所以value肯定是虚拟地址。</p>
<p>JOS的kernel有些时候需要读写物理地址，可以通过宏KADDR(pa)实现将物理地址+KERNBASE转换为内核虚拟地址。同理，有时候需要能通过内核虚拟地址找到物理地址，-KERNBASE，通过宏PADDR(va)实现。</p>
<h3 id="2-2-Reference-Counting"><a href="#2-2-Reference-Counting" class="headerlink" title="2.2 Reference Counting"></a>2.2 Reference Counting</h3><p>在之后的实验中，我们可能将同一个物理页同时映射到很多虚拟地址，我们必须维护<code>struct PageInfo</code>结构体中的<code>pp_ref</code>来保持引用计数。当引用计数为0的时候，页面就可以被释放。</p>
<p>一般来说，这个引用计数等同于物理页面在<code>UTOP</code>以下的区域出现的次数（这个以上的区域的物理页面大多数都是在启动的时候被内核分配，而且不会被释放）。</p>
<p>同样地，引用计数也可以追踪指向页目录的数量，以及页目录对页表项的引用计数。</p>
<h3 id="2-3-Page-Table-Management"><a href="#2-3-Page-Table-Management" class="headerlink" title="2.3 Page Table Management"></a>2.3 Page Table Management</h3><p>在这个环节中，我们需要编写管理页表的例程：插入以及删除线性地址到物理地址的映射，同时还需要创建页表。</p>
<p><strong>exercise 4:</strong></p>
<p>在<code>kern/pmap.c</code>中，实现以下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pgdir_walk()</span><br><span class="line">boot_map_region()        </span><br><span class="line">page_lookup()</span><br><span class="line">page_remove()        </span><br><span class="line">page_insert()</span><br><span class="line"><span class="comment">//最终通过mem_init()中的check_page()进行检查</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>pgdir_walk()</code></li>
</ul>
<p>这个函数的以一个线性地址<code>va</code>和一个页目录<code>pgdir</code>作为参数，返回该线性地址对应的页面所在页表项(PTE)的地址。</p>
<p>我们需要使用线性地址进行页目录索引，索引到对应的页表地址。如果索引到的页表还没被创建且<code>create</code>参数为1，则我们创建以个新的页表。进而我们获取页表项索引，通过页表结合表项索引，得到页表项。</p>
<p>有一点需要注意的是，页表项实际上都是在KERNBASE之上，我们必须返回一个<code>kva(kernel virtual address)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given 'pgdir', a pointer to a page directory, pgdir_walk returns</span></span><br><span class="line"><span class="comment">// a pointer to the page table entry (PTE) for linear address 'va'.</span></span><br><span class="line"><span class="comment">// This requires walking the two-level page table structure.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The relevant page table page might not exist yet.</span></span><br><span class="line"><span class="comment">// If this is true, and create == false, then pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span></span><br><span class="line"><span class="comment">//    - If the allocation fails, pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">//    - Otherwise, the new page's reference count is incremented,</span></span><br><span class="line"><span class="comment">//	the page is cleared,</span></span><br><span class="line"><span class="comment">//	and pgdir_walk returns a pointer into the new page table page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 1: you can turn a PageInfo * into the physical address of the</span></span><br><span class="line"><span class="comment">// page it refers to with page2pa() from kern/pmap.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 2: the x86 MMU checks permission bits in both the page directory</span></span><br><span class="line"><span class="comment">// and the page table, so it's safe to leave permissions in the page</span></span><br><span class="line"><span class="comment">// directory more permissive than strictly necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 3: look at inc/mmu.h for useful macros that manipulate page</span></span><br><span class="line"><span class="comment">// table and page directory entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// page directory index and entry</span></span><br><span class="line">	<span class="keyword">uint32_t</span> pd_idx = PDX(va);</span><br><span class="line">	<span class="keyword">pde_t</span> pd_entry = pgdir[pd_idx];</span><br><span class="line">	<span class="comment">// page table index and entry</span></span><br><span class="line">	<span class="keyword">uint32_t</span> pt_idx = PTX(va);</span><br><span class="line">	<span class="comment">// page directory entry -&gt;page table does not exists</span></span><br><span class="line">	<span class="keyword">if</span>((pd_entry &amp; PTE_P) != <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!create)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//create page table</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">pg_new</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">		<span class="keyword">if</span>(pg_new == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		pg_new -&gt; pp_ref += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">physaddr_t</span> pg_pa = page2pa(pg_new);</span><br><span class="line">		<span class="comment">// add to page directory entry</span></span><br><span class="line">		pgdir[pd_idx] = pg_pa | PTE_P | PTE_W | PTE_U;</span><br><span class="line">		<span class="comment">// return (pte_t *)(KADDR(PTE_ADDR(pd_entry)))+ pt_idx;</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">pte_t</span> *)page2kva(pg_new) + pt_idx;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//pte_t : page table entry      pte_t* : page table addr</span></span><br><span class="line">	<span class="comment">// 取得pte_t* 仿照其他函数获取pte_t* 的过程</span></span><br><span class="line">	<span class="comment">// 这个操作只能return Kernel Virtual Address（物理地址0-4M是不可写的）</span></span><br><span class="line">	<span class="keyword">pte_t</span> * pg_table = KADDR(PTE_ADDR(pd_entry));</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">pte_t</span> *)(pg_table + pt_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这里要分析一下，当<code>!(pd_entry &amp; PTE_P)</code>的情况：也就是说这个时候通过页目录无法索引一个有效的页表，此时我们需要创建一个页表。</p>
<p>创建页表调用<code>page_alloc()</code>分配一个空闲页面当作我们的页表即可。（空闲页面4K，页表项32bits = 4B，那么一个页面正好能装下1K个页表项）</p>
<p>完成后，我们就实现了通过虚拟地址以及页目录首址来获取相应的页表项(PTE)地址的功能。</p>
<ul>
<li><code>boot_map_region()</code></li>
</ul>
<p>这个函数的作用是将一段虚拟内存映射到同样长度的物理内存(都经过页面对齐)。而且映射是以页面为单位。</p>
<p>实际上这个函数的使用过程中只会映射<code>UTOP</code>之上的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span></span><br><span class="line"><span class="comment">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span></span><br><span class="line"><span class="comment">// va and pa are both page-aligned.</span></span><br><span class="line"><span class="comment">// Use permission bits perm|PTE_P for the entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is only intended to set up the ``static'' mappings</span></span><br><span class="line"><span class="comment">// above UTOP. As such, it should *not* change the pp_ref field on the</span></span><br><span class="line"><span class="comment">// mapped pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_region(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">size_t</span> page_num = size / PGSIZE, i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; page_num; i++)&#123;</span><br><span class="line">		<span class="keyword">pte_t</span> * pt_entry = pgdir_walk(pgdir, (<span class="keyword">void</span>*)(va + i * PGSIZE), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// set PTE -&gt; pa</span></span><br><span class="line">		*pt_entry = (pa + i * PGSIZE) | perm | PTE_P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>page_lookup</code></li>
</ul>
<p>这个函数的功能是，给定一个虚拟地址<code>va</code>以及相应的页目录地址<code>pgdir</code>，我们查找该虚拟地址的页表地址和物理地址，然后将<code>PageInfo</code>返回即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the page mapped at virtual address 'va'.</span></span><br><span class="line"><span class="comment">// If pte_store is not zero, then we store in it the address</span></span><br><span class="line"><span class="comment">// of the pte for this page.  This is used by page_remove and</span></span><br><span class="line"><span class="comment">// can be used to verify page permissions for syscall arguments,</span></span><br><span class="line"><span class="comment">// but should not be used by most callers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return NULL if there is no page mapped at va.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk and pa2page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">pte_t</span> *pt_entry = pgdir_walk(pgdir, va, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// no page mapped at va</span></span><br><span class="line">	<span class="keyword">if</span>(!pt_entry)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(pte_store)&#123;</span><br><span class="line">		*pte_store = pt_entry;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pa2page(PTE_ADDR(*pt_entry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>page_remove()</code></li>
</ul>
<p>这个函数的作用是解引用，给定虚拟地址<code>va</code>以及页目录<code>pgdir</code>，我们将其页表中对应的页（如果有）进行解引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unmaps the physical page at virtual address 'va'.</span></span><br><span class="line"><span class="comment">// If there is no physical page at that address, silently does nothing.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Details:</span></span><br><span class="line"><span class="comment">//   - The ref count on the physical page should decrement.</span></span><br><span class="line"><span class="comment">//   - The physical page should be freed if the refcount reaches 0.</span></span><br><span class="line"><span class="comment">//   - The pg table entry corresponding to 'va' should be set to 0.</span></span><br><span class="line"><span class="comment">//     (if such a PTE exists)</span></span><br><span class="line"><span class="comment">//   - The TLB must be invalidated if you remove an entry from</span></span><br><span class="line"><span class="comment">//     the page table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The TA solution is implemented using page_lookup,</span></span><br><span class="line"><span class="comment">// 	tlb_invalidate, and page_decref.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">pte_t</span> * ptestore_temp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">pg_entry</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">ptestore_temp</span>);</span></span><br><span class="line">	<span class="comment">// PTE does not exist</span></span><br><span class="line">	<span class="keyword">if</span>(!pg_entry) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	page_decref(pg_entry);</span><br><span class="line">	*ptestore_temp = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// invalidate a TLB entry</span></span><br><span class="line">	tlb_invalidate(pgdir, va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>page_insert()</code></li>
</ul>
<p>这个函数是将给定的虚拟地址<code>va</code>对应的页面映射到给定的物理页面<code>pp</code>。</p>
<p>注意一个case：就是我们对同一个<code>pp</code>和同一个<code>va</code>进行两次重复的insert，如果我们先使用<code>page_remove()</code>再增加<code>pp</code>的引用数，那会导致<code>pp</code>进入了<code>free_list</code>但是引用数+1后不为0。所以我们必须先增加引用数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map the physical page 'pp' at virtual address 'va'.</span></span><br><span class="line"><span class="comment">// The permissions (the low 12 bits) of the page table entry</span></span><br><span class="line"><span class="comment">// should be set to 'perm|PTE_P'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Requirements</span></span><br><span class="line"><span class="comment">//   - If there is already a page mapped at 'va', it should be page_remove()d.</span></span><br><span class="line"><span class="comment">//   - If necessary, on demand, a page table should be allocated and inserted</span></span><br><span class="line"><span class="comment">//     into 'pgdir'.</span></span><br><span class="line"><span class="comment">//   - pp-&gt;pp_ref should be incremented if the insertion succeeds.</span></span><br><span class="line"><span class="comment">//   - The TLB must be invalidated if a page was formerly present at 'va'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Corner-case hint: Make sure to consider what happens when the same</span></span><br><span class="line"><span class="comment">// pp is re-inserted at the same virtual address in the same pgdir.</span></span><br><span class="line"><span class="comment">// However, try not to distinguish this case in your code, as this</span></span><br><span class="line"><span class="comment">// frequently leads to subtle bugs; there's an elegant way to handle</span></span><br><span class="line"><span class="comment">// everything in one code path.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RETURNS:</span></span><br><span class="line"><span class="comment">//   0 on success</span></span><br><span class="line"><span class="comment">//   -E_NO_MEM, if page table couldn't be allocated</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The TA solution is implemented using pgdir_walk, page_remove,</span></span><br><span class="line"><span class="comment">// and page2pa.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// page table could not be allocated</span></span><br><span class="line">	<span class="keyword">pte_t</span> * pt_entry = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(!pt_entry) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	pp -&gt; pp_ref += <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//remove page</span></span><br><span class="line">	<span class="keyword">if</span>((*pt_entry) &amp; PTE_P)&#123;</span><br><span class="line">		page_remove(pgdir, va);</span><br><span class="line">	&#125;</span><br><span class="line">	*pt_entry = page2pa(pp) | perm | PTE_P;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现这些，我们就可以通过<code>check_page()</code>函数了，大功告成。</p>
<p><img alt="image-20200306161147186" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gck9xtm008j30hp065q46.jpg" data-index="9" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gck9xtm008j30hp065q46.jpg"></p>
<h2 id="Part3-Kernel-Address-Space"><a href="#Part3-Kernel-Address-Space" class="headerlink" title="Part3: Kernel Address Space"></a>Part3: Kernel Address Space</h2><p>这一部分我们终于可以讨论内核地址空间了。JOS将32位的线性地址空间分成了两部分：</p>
<ul>
<li><p>用户环境（在Lab3中涉及）：将控制低地址空间</p>
</li>
<li><p>内核：总是完全地控制高地址空间</p>
</li>
</ul>
<p>将内核与用户环境分隔是在<code>inc/memlayout.h</code>中进行定义的，且为内核保留了大于256MB的虚拟地址空间。（实际上这解释了为什么我们需要在lab1中给内核提供如此高的链接地址：否则内核的虚拟地址空间将没有足够的空间同时映射到其下方的用户环境中）</p>
<h3 id="3-1-Permissions-and-Fault-Isolation"><a href="#3-1-Permissions-and-Fault-Isolation" class="headerlink" title="3.1 Permissions and Fault Isolation"></a>3.1 Permissions and Fault Isolation</h3><p>尽管内核与用户的内存都位于同一地址空间，我们仍然需要在x86页表中使用权限位去保证用户代码仅能够访问低地址空间。否则用户代码可能会覆写内核数据，这就会有潜在的冲突，此外用户代码还可能能窃取其他用户、内核的私有数据。注意可写权限位<code>PTW_W</code>会同时影响用户代码以及内核代码。</p>
<p>用户的环境将不具备任何内存权限在<code>ULIM</code>之上，而内核是可以读写这些内存的。对于<code>[UTOP, ULIM)</code>这个范围的地址，用户环境和内核的权限是相同的：均是只能读不能写。这段内存的主要作用是向用户暴露内核中的一些只读的数据结构。最后，<code>UTOP</code>以下的地址空间将是用户环境使用的，用户环境可以自行设置这些内存的权限。</p>
<h3 id="3-2-Initializing-the-Kernel-Address-Space"><a href="#3-2-Initializing-the-Kernel-Address-Space" class="headerlink" title="3.2 Initializing the Kernel Address Space"></a>3.2 Initializing the Kernel Address Space</h3><p>在这个部分，我们需要设置<code>UTOP</code>之上的内核地址空间。<code>inc/memlayout.h</code>展示了我们可能需要的layout结构，这个结构在文章开头的<em>JOS分段与分页</em>这一节已经进行了详细描述。</p>
<p><strong>exercise 5:</strong></p>
<p>补全<code>mem_init()</code>函数在调用<code>check_page()</code>之后未完成的缺失部分。在我们完善了<code>mem_init()</code>之后，将可以通过<code>check_kern_pgdir()</code>以及<code>check_page_installed_pgdir()</code>的检查。</p>
<p>跟着注释读一遍，就没有什么难度了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map 'pages' read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"><span class="comment">// 将pages数组映射到UPAGE地址区域以上</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, npages * <span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U | PTE_P);</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Use the physical memory that 'bootstack' refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a "guard page".</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, (KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"><span class="keyword">size_t</span> KERNSIZE = (<span class="keyword">unsigned</span>)<span class="number">0xffffffff</span> - KERNBASE;</span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, KERNSIZE, <span class="number">0</span>, PTE_W | PTE_P);</span><br></pre></td></tr></table></figure>
<p>这里我们同样就大功告成了，再次启动qemu信息如下：（请选择性忽略我debug过程中的log）</p>
<p><img alt="image-20200307132808176" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gclatuiullj30k00bqmxn.jpg" data-index="10" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gclatuiullj30k00bqmxn.jpg"></p>
<p>再次，我们回顾一下<code>mem_init()</code>的全过程，这就是jos设置页表管理内存的全过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up a two-level page table:</span></span><br><span class="line"><span class="comment">//    kern_pgdir is its linear (virtual) address of the root</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function only sets up the kernel part of the address space</span></span><br><span class="line"><span class="comment">// (ie. addresses &gt;= UTOP).  The user part of the address space</span></span><br><span class="line"><span class="comment">// will be set up later.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// From UTOP to ULIM, the user is allowed to read but not write.</span></span><br><span class="line"><span class="comment">// Above ULIM the user cannot read or write.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">mem_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> cr0;</span><br><span class="line">	<span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">	i386_detect_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remove this line when you're ready to test this function.</span></span><br><span class="line">	<span class="comment">//panic("mem_init: This function is not finished\n");</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// create initial page directory.</span></span><br><span class="line">	kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">	cprintf(<span class="string">"kern_pgdir info: %x\n"</span>,kern_pgdir);</span><br><span class="line">	cprintf(<span class="string">"kern_pgdir address: %x\n"</span>, &amp;kern_pgdir);</span><br><span class="line">	cprintf(<span class="string">"[mem_init] kern_pgdir[0] addr: %x\n"</span>, PTE_ADDR(kern_pgdir[<span class="number">0</span>]));</span><br><span class="line">	<span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// Recursively insert PD in itself as a page table, to form</span></span><br><span class="line">	<span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line">	<span class="comment">// (For now, you don't have understand the greater purpose of the</span></span><br><span class="line">	<span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	<span class="comment">// UVPT是页表区域的开始</span></span><br><span class="line">	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span></span><br><span class="line">	<span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line">	<span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line">	<span class="comment">// array.  'npages' is the number of physical pages in memory.  Use memset</span></span><br><span class="line">	<span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line">	<span class="comment">// Your code goes here:</span></span><br><span class="line">	n = npages * <span class="keyword">sizeof</span>(struct PageInfo);</span><br><span class="line">	pages = (struct PageInfo *)boot_alloc(n);</span><br><span class="line">	<span class="built_in">memset</span>(pages, <span class="number">0</span>, n);</span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// Now that we've allocated the initial kernel data structures, we set</span></span><br><span class="line">	<span class="comment">// up the list of free physical pages. Once we've done so, all further</span></span><br><span class="line">	<span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line">	<span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line">	<span class="comment">// or page_insert</span></span><br><span class="line">	page_init();</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">1</span>);</span><br><span class="line">	check_page_alloc();</span><br><span class="line">	check_page();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// Map 'pages' read-only by the user at linear address UPAGES</span></span><br><span class="line">	<span class="comment">// Permissions:</span></span><br><span class="line">	<span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line">	<span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">	<span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line">	<span class="comment">// Your code goes here:</span></span><br><span class="line">	<span class="comment">// 将pages数组映射到UPAGE地址区域以上</span></span><br><span class="line">	boot_map_region(kern_pgdir, UPAGES, npages * <span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U | PTE_P);</span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// Use the physical memory that 'bootstack' refers to as the kernel</span></span><br><span class="line">	<span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line">	<span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">	<span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line">	<span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line">	<span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line">	<span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line">	<span class="comment">//       overwrite memory.  Known as a "guard page".</span></span><br><span class="line">	<span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">	<span class="comment">// Your code goes here:</span></span><br><span class="line">	boot_map_region(kern_pgdir, (KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);</span><br><span class="line">	<span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line">	<span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line">	<span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line">	<span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line">	<span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line">	<span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line">	<span class="comment">// Your code goes here:</span></span><br><span class="line">	<span class="keyword">size_t</span> KERNSIZE = (<span class="keyword">unsigned</span>)<span class="number">0xffffffff</span> - KERNBASE;</span><br><span class="line">	boot_map_region(kern_pgdir, KERNBASE, KERNSIZE, <span class="number">0</span>, PTE_W | PTE_P);</span><br><span class="line">	<span class="comment">// Check that the initial page directory has been set up correctly.</span></span><br><span class="line">	check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Switch from the minimal entry page directory to the full kern_pgdir</span></span><br><span class="line">	<span class="comment">// page table we just created.	Our instruction pointer should be</span></span><br><span class="line">	<span class="comment">// somewhere between KERNBASE and KERNBASE+4MB right now, which is</span></span><br><span class="line">	<span class="comment">// mapped the same way by both page tables.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If the machine reboots at this point, you've probably set up your</span></span><br><span class="line">	<span class="comment">// kern_pgdir wrong.</span></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// entry.S set the really important flags in cr0 (including enabling</span></span><br><span class="line">	<span class="comment">// paging).  Here we configure the rest of the flags that we care about.</span></span><br><span class="line">	cr0 = rcr0();</span><br><span class="line">	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">	cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">	lcr0(cr0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Some more checks, only possible after kern_pgdir is installed.</span></span><br><span class="line">	check_page_installed_pgdir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Question</strong></p>
<ul>
<li>What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:</li>
</ul>
<p>这个我们需要填写在<code>mem_init()</code>过程中映射的地址</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Entry</th>
<th style="text-align:center">Base Virtual Address</th>
<th style="text-align:center">Points to (logically)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1023</td>
<td style="text-align:center">0xFFC00000</td>
<td style="text-align:center">Physical Memory</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">……….</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">960</td>
<td style="text-align:center">0xF0000000</td>
<td style="text-align:center">First 4 MB on Physical Memory</td>
</tr>
<tr>
<td style="text-align:center">959</td>
<td style="text-align:center">0xEFC00000</td>
<td style="text-align:center">Kernel Stack</td>
</tr>
<tr>
<td style="text-align:center">957</td>
<td style="text-align:center">0xEF400000</td>
<td style="text-align:center">Kernel Page Directory</td>
</tr>
<tr>
<td style="text-align:center">956</td>
<td style="text-align:center">0xEF000000</td>
<td style="text-align:center">Pages</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</li>
</ul>
<p>虽然用户环境和内核都在同样的地址空间中，但用户显然无法访问内核区域的内存的。回忆我们在<code>mem_init()</code>过程中对所有的映射设置了特权级，没有<code>PTE_U</code>特权的页显然是用户无法访问的。</p>
<ul>
<li>What is the maximum amount of physical memory that this operating system can support? Why?</li>
</ul>
<p>操作系统虚拟内存空间部分分布如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="line">*                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</span><br><span class="line">*    UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="line">*                     |          RO PAGES            | R-/R-  PTSIZE</span><br><span class="line">*    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br></pre></td></tr></table></figure>
<p>回顾我们实验的第一部分，我们建立了一个物理内存分配器。在<code>page_init()</code>函数中，我们将所有可用的物理内存按照页面进行划分并且存放在了<code>pages</code>结构体数组中。在第三部分设置操作系统内核虚拟空间的过程中，我们在<code>mem_init()</code>配置页表的过程中使用<code>boot_map_regions()</code>将<code>pages</code>映射到了<code>UPAGES</code>以上的区域。</p>
<p>那么程序空间是利用虚拟地址进行访问<code>pages</code>的，此时对应虚拟空间的<code>R0 PAGES</code>，大小为<code>0xef000000-0xef400000(4MB)</code>。一旦超过4MB就越界到了<code>UVPT</code>这个空间，而<code>UVPT</code>这个空间是映射在了<code>kern_pgdir</code>中。</p>
<p>也就是说，虚拟空间访问<code>UPAGES</code>最多只有4MB，而<code>pages</code>的每个元素是<code>struct PageInfo</code>类型的结构体，占8B空间，其每一个元素对应的一个页面有4KB大。因此一共支持物理空间2GB。</p>
<ul>
<li>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?（内存管理的开销问题，如果我们有能支持的最大的物理内存，管理内存的开销是什么？且如何减少？）</li>
</ul>
<p>经过上一问的分析，操作系统支持虚拟空间最多寻址512KB个页面，也就是有512个页表（一个页表能够寻址<code>2^10</code>个页面）。再次回顾我们在2.3节进行页表管理的时候，对于每一个<code>kern_dir</code>未初始化的页表项，我们都通过<code>page_alloc()</code>分配一个页表。也就是说实际上每一个页表的大小都是<code>PGSIZE</code>。那么页表所需的空间开销就是<code>PGSIZE * 512 = 2MB</code>，再加上4KB的页目录以及刚才所需4MB的空间存放所有<code>PageInfo</code>，总共的空间开销就是<code>6MB + 4KB</code>。</p>
<p>如果想降低开销的话，可以把<code>PGSIZE</code>设置的大一些。</p>
<ul>
<li>Revisit the page table setup in <code>kern/entry.S</code> and <code>kern/entrypgdir.c</code>. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?（在我们刚开启分页机制的时候，程序还运行在低地址1MB上，控制流在什么时候跳转到KERNBASE以上？为什么在打开分页机制之后我们仍能够运行在物理地址的低地址上？）</li>
</ul>
<p>我们查看<code>entry.S</code>的关键代码，这部分代码实际上是<code>obj/kern/kernal.asm</code>中的entry部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">	movw	$0x1234,0x472			# warm boot</span><br><span class="line"></span><br><span class="line">	# We haven&apos;t set up virtual memory yet, so we&apos;re running from</span><br><span class="line">	# the physical address the boot loader loaded the kernel at: 1MB</span><br><span class="line">	# (plus a few bytes).  However, the C code is linked to run at</span><br><span class="line">	# KERNBASE+1MB.  Hence, we set up a trivial page directory that</span><br><span class="line">	# translates virtual addresses [KERNBASE, KERNBASE+4MB) to</span><br><span class="line">	# physical addresses [0, 4MB).  This 4MB region will be</span><br><span class="line">	# sufficient until we set up our real page table in mem_init</span><br><span class="line">	# in lab 2.</span><br><span class="line"></span><br><span class="line">	# Load the physical address of entry_pgdir into cr3.  entry_pgdir</span><br><span class="line">	# is defined in entrypgdir.c.</span><br><span class="line">	movl	$(RELOC(entry_pgdir)), %eax</span><br><span class="line">	movl	%eax, %cr3</span><br><span class="line">	# Turn on paging.</span><br><span class="line">	movl	%cr0, %eax</span><br><span class="line">	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">	movl	%eax, %cr0</span><br><span class="line"></span><br><span class="line">	# Now paging is enabled, but we&apos;re still running at a low EIP</span><br><span class="line">	# (why is this okay?).  Jump up above KERNBASE before entering</span><br><span class="line">	# C code.</span><br><span class="line">	mov	$relocated, %eax</span><br><span class="line">	jmp	*%eax</span><br></pre></td></tr></table></figure>
<p>我们可以看到最后五行，也就是执行指令<code>movl %eax, %cr0</code>之后，控制流就使用<code>jmp</code>指令跳转到了<code>KERNBASE</code>以上的高地址部分。之所以打开分也机制我们还能在低地址运行，是由于实际上低地址和<code>KERNBASE</code>以上的高地址区域都被映射在同一片物理内存中。所以运行无误。</p>
<p>完成了上述的所有问题，就也可以使用<code>make grade</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  Physical page allocator: OK</span><br><span class="line">  Page management: OK</span><br><span class="line">  Kernel page directory: OK</span><br><span class="line">  Page management 2: OK</span><br><span class="line">Score: 70/70</span><br></pre></td></tr></table></figure>
<p>舒服了。完结撒花🎉</p>

                </article>
                <ul class="tags-postTags">
                    
                    <li>
                        <a href="/tags/operating-system/" rel="tag"># operating system</a>
                    </li>
                    
                    <li>
                        <a href="/tags/lab/" rel="tag"># lab</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </div>

    
    <nav id="gobottom" class="pagination">
        
        <a class="prev-post" title href="/2020/03/07/memfor/">
            ← 
        </a>
        
        <span class="prev-next-post">·</span>
        
        <a class="next-post" title="手把手带你MIT6.828 - Lab1" href="/2020/03/02/os/">
            手把手带你MIT6.828 - Lab1 →
        </a>
        
    </nav>

    
    <div class="inner">
        <div id="comment"></div>
    </div>
    
</div>

<div class="toc-bar">
    <div class="toc-btn-bar">
        <a href="#site-main" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M793.024 710.272a32 32 0 1 0 45.952-44.544l-310.304-320a32 32 0 0 0-46.4 0.48l-297.696 320a32 32 0 0 0 46.848 43.584l274.752-295.328 286.848 295.808z"/></svg>
        </a>
        <div class="toc-btn toc-switch">
            <svg class="toc-open" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M779.776 480h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M779.776 672h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M256 288a32 32 0 1 0 0 64 32 32 0 0 0 0-64M392.576 352h387.2a32 32 0 0 0 0-64h-387.2a32 32 0 0 0 0 64M256 480a32 32 0 1 0 0 64 32 32 0 0 0 0-64M256 672a32 32 0 1 0 0 64 32 32 0 0 0 0-64"/></svg>
            <svg class="toc-close hide" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 960c-247.039484 0-448-200.960516-448-448S264.960516 64 512 64 960 264.960516 960 512 759.039484 960 512 960zM512 128.287273c-211.584464 0-383.712727 172.128262-383.712727 383.712727 0 211.551781 172.128262 383.712727 383.712727 383.712727 211.551781 0 383.712727-172.159226 383.712727-383.712727C895.712727 300.415536 723.551781 128.287273 512 128.287273z"/><path d="M557.05545 513.376159l138.367639-136.864185c12.576374-12.416396 12.672705-32.671738 0.25631-45.248112s-32.704421-12.672705-45.248112-0.25631l-138.560301 137.024163-136.447897-136.864185c-12.512727-12.512727-32.735385-12.576374-45.248112-0.063647-12.512727 12.480043-12.54369 32.735385-0.063647 45.248112l136.255235 136.671523-137.376804 135.904314c-12.576374 12.447359-12.672705 32.671738-0.25631 45.248112 6.271845 6.335493 14.496116 9.504099 22.751351 9.504099 8.12794 0 16.25588-3.103239 22.496761-9.247789l137.567746-136.064292 138.687596 139.136568c6.240882 6.271845 14.432469 9.407768 22.65674 9.407768 8.191587 0 16.352211-3.135923 22.591372-9.34412 12.512727-12.480043 12.54369-32.704421 0.063647-45.248112L557.05545 513.376159z"/></svg>
        </div>
        <a href="#gobottom" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M231.424 346.208a32 32 0 0 0-46.848 43.584l297.696 320a32 32 0 0 0 46.4 0.48l310.304-320a32 32 0 1 0-45.952-44.544l-286.848 295.808-274.752-295.36z"/></svg>
        </a>
    </div>
    <div class="toc-main">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab2-Memory-Management"><span class="toc-text">Lab2 Memory Management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-实验介绍"><span class="toc-text">&gt; 实验介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-实验准备"><span class="toc-text">&gt; 实验准备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part1-Physical-Page-Management"><span class="toc-text">Part1: Physical Page Management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-bootloader读入kernel后的内存分布"><span class="toc-text">&gt; bootloader读入kernel后的内存分布</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-回顾Lab1"><span class="toc-text">&gt;&gt; 回顾Lab1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-JOS分段和分页"><span class="toc-text">&gt; JOS分段和分页</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part2-Virtual-Memory"><span class="toc-text">Part2: Virtual Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-段式管理-Segment"><span class="toc-text">&gt; 段式管理-Segment</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-描述符-Descriptors"><span class="toc-text">&gt;&gt; 描述符(Descriptors)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-段描述符表-Descriptor-Table"><span class="toc-text">&gt;&gt; 段描述符表(Descriptor Table)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-描述符表寄存器-GDTR-LDTR"><span class="toc-text">&gt;&gt; 描述符表寄存器(GDTR/LDTR)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-段选择子-Selectors"><span class="toc-text">&gt;&gt; 段选择子(Selectors)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-页式管理-Pages"><span class="toc-text">&gt; 页式管理(Pages)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Linear-Address"><span class="toc-text">&gt;&gt; Linear Address</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-页表-Page-Tables"><span class="toc-text">&gt;&gt;页表(Page Tables)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-页表项-Page-Table-Entries"><span class="toc-text">&gt;&gt;页表项(Page-Table Entries)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Virtual-Linear-and-Physical-Addresses"><span class="toc-text">2.1 Virtual, Linear and Physical Addresses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Reference-Counting"><span class="toc-text">2.2 Reference Counting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Page-Table-Management"><span class="toc-text">2.3 Page Table Management</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part3-Kernel-Address-Space"><span class="toc-text">Part3: Kernel Address Space</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Permissions-and-Fault-Isolation"><span class="toc-text">3.1 Permissions and Fault Isolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Initializing-the-Kernel-Address-Space"><span class="toc-text">3.2 Initializing the Kernel Address Space</span></a></li></ol></li></ol>
    </div>
</div>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>




	</div>
	


<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            

<article class="read-next-card" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfvz62ikmj30u0140kjl.jpg)">
  <header class="read-next-card-header">
    <small class="read-next-card-header-sitetitle">&mdash; Icegrave &mdash;</small>
    <h3 class="read-next-card-header-title">Recent Posts</h3>
  </header>
  <div class="read-next-divider">
    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
      <path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/>
    </svg>
  </div>
  <div class="read-next-card-content">
    <ul>
      
      
      
      <li>
        <a href="/2020/03/10/oslab3/">手把手带你MIT6.828 - Lab3</a>
      </li>
      
      
      
      <li>
        <a href="/2020/03/07/memfor/"></a>
      </li>
      
      
      
      <li>
        <a href="/2020/03/04/lab2/">手把手带你MIT6.828 - Lab2</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </ul>
  </div>
  <footer class="read-next-card-footer">
    <a href="/archives">  MORE  → </a>
  </footer>
</article>

            
            
            

<article class="read-next-card" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfvz62ikmj30u0140kjl.jpg)">
    <header class="read-next-card-header tagcloud-card">
        <h3 class="read-next-card-header-title">Categories</h3>
    </header>
    <div class="read-next-card-content">
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memory-forensics/">memory forensics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/operating-system/">operating system</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/图形学基础/">图形学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li></ul>
    </div>
</article>


            
            
            

<article class="read-next-card" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfvz62ikmj30u0140kjl.jpg)">
	<header class="read-next-card-header tagcloud-card">
		<h3 class="read-next-card-header-title">Tag Cloud</h3>
	</header>
	<div class="read-next-card-content-ext">
		<a href="/tags/Fundamentals-of-Computer-Graphics/" style="font-size: 14px;">Fundamentals of Computer Graphics</a> <a href="/tags/iOS/" style="font-size: 14px;">iOS</a> <a href="/tags/iosre/" style="font-size: 14px;">iosre</a> <a href="/tags/lab/" style="font-size: 24px;">lab</a> <a href="/tags/memory-forensics/" style="font-size: 14px;">memory forensics</a> <a href="/tags/operating-system/" style="font-size: 24px;">operating system</a> <a href="/tags/工具/" style="font-size: 24px;">工具</a> <a href="/tags/随笔/" style="font-size: 14px;">随笔</a>
	</div>
</article>

            
        </div>
    </div>
</aside>

	




<div id="search" class="search-overlay">
    <div class="search-form">
        
        <div class="search-overlay-logo">
        	<img src="https://mubai.oss-cn-hangzhou.aliyuncs.com/icon.png" alt="Icegrave">
        </div>
        
        <input id="local-search-input" class="search-input" type="text" name="search" placeholder="Search ...">
        <a class="search-overlay-close" href="#"></a>
    </div>
    <div id="local-search-result"></div>
</div>

<footer class="site-footer outer">
	<div class="site-footer-content inner">
		<div class="copyright">
			<a href="/" title="Icegrave">Icegrave &copy; 2020</a>
			
				
			        <span hidden="true" id="/2020/03/04/lab2/" class="leancloud-visitors" data-flag-title="手把手带你MIT6.828 - Lab2">
			            <span>阅读量 </span>
			            <span class="leancloud-visitors-count">0</span>
			        </span>
	    		
    		
		</div>
		<nav class="site-footer-nav">
			
			<a href="https://hexo.io" title="Hexo" target="_blank" rel="noopener">Hexo</a>
			<a href="https://github.com/xzhih/hexo-theme-casper" title="Casper" target="_blank" rel="noopener">Casper</a>
		</nav>
	</div>
</footer>
	


<script>
    if(window.navigator && navigator.serviceWorker) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for(let registration of registrations) {
                registration.unregister()
            }
        })
    }
</script>


<script id="scriptLoad" src="/js/allinone.min.js" async></script>


<script>
    document.getElementById('scriptLoad').addEventListener('load', function () {
        
        
            var bLazy = new Blazy();
        

        
        

        
        
        
            searchFunc("/");
        
        
    })
</script>



<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>




<script id="valineScript" src="//unpkg.com/valine/dist/Valine.min.js" async></script>
<script>
    document.getElementById('valineScript').addEventListener("load", function() {
        new Valine({
            el: '#comment' ,
            verify: false,
            notify: false,
            appId: 'PlliSVE5ISCj7XAYOowLuJDX-gzGzoHsz',
            appKey: 'CoE3u0Y1coO3kv6nHDpSuj4L',
            placeholder: 'nil',
            pageSize: 10,
            avatar: 'mm',
            visitor: true
        })
    });
</script>





</body>
</html>
