<!DOCTYPE html>
<html lang="zh-Hans">







<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="preconnect" href="//www.googletagmanager.com">
	<link rel="preconnect" href="//zz.bdstatic.com">
	<link rel="preconnect" href="//sp0.baidu.com">
	<link rel="preconnect" href="//www.google-analytics.com">
	<link rel="preconnect" href="//cdn1.lncld.net">
	<link rel="preconnect" href="//unpkg.com">
	<link rel="preconnect" href="//app-router.leancloud.cn">
	<link rel="preconnect" href="//9qpuwspm.api.lncld.net">
	<link rel="preconnect" href="//gravatar.loli.net">

	<title>Icegrave | Icegrave</title>

	<meta name="HandheldFriendly" content="True">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
	<meta name="generator" content="hexo">
	<meta name="author" content="Heart-Shaped Box">
	<meta name="description" content>

	
	<meta name="keywords" content>
	

	
	<link rel="shortcut icon" href="https://mubai.oss-cn-hangzhou.aliyuncs.com/icon.png">
	<link rel="apple-touch-icon" href="https://mubai.oss-cn-hangzhou.aliyuncs.com/icon.png">
	

	
	<meta name="theme-color" content="#3c484e">
	<meta name="msapplication-TileColor" content="#3c484e">
	

	

	

	<meta property="og:site_name" content="Icegrave">
	<meta property="og:type" content="article">
	<meta property="og:title" content="Icegrave | Icegrave">
	<meta property="og:description" content>
	<meta property="og:url" content="http://yoursite.com/2020/03/07/memfor/">

	
	<meta property="article:published_time" content="2020-03-07T17:03:00+08:00"> 
	<meta property="article:author" content="Heart-Shaped Box">
	<meta property="article:published_first" content="Icegrave, /2020/03/07/memfor/">
	

	
	
	<link rel="stylesheet" href="/css/allinonecss.min.css">

	
	
	
</head>
<body class="post-template">
	<div class="site-wrapper">
		




<header class="site-header post-site-header outer">
    <div class="inner">
        
<nav class="site-nav"> 
    <div class="site-nav-left">
        <ul class="nav">
            <li>
                
                <a href="/" title="Home">HOME</a>
                
            </li>
            
            
            <li>
                <a href="/about" title="ABOUT">ABOUT</a>
            </li>
            
            <li>
                <a href="/archives" title="ARCHIVES">ARCHIVES</a>
            </li>
            
            
        </ul> 
    </div>
    
    <div class="search-button-area">
        <a href="#search" class="search-button">Search ...</a>
    </div>
     
    <div class="site-nav-right">
        
        <a href="#search" class="search-button">Search ...</a>
         
        
<div class="social-links">
    
    <a class="social-link" title="weibo" href="https://weibo.com/" target="_blank" rel="noopener">
        <svg viewbox="0 0 1141 1024" xmlns="http://www.w3.org/2000/svg"><path d="M916.48 518.144q27.648 21.504 38.912 51.712t9.216 62.976-14.336 65.536-31.744 59.392q-34.816 48.128-78.848 81.92t-91.136 56.32-94.72 35.328-89.6 18.944-75.264 7.68-51.712 1.536-49.152-2.56-68.096-10.24-78.336-21.504-79.872-36.352-74.24-55.296-59.904-78.848q-16.384-29.696-22.016-63.488t-5.632-86.016q0-22.528 7.68-51.2t27.136-63.488 53.248-75.776 86.016-90.112q51.2-48.128 105.984-85.504t117.248-57.856q28.672-10.24 63.488-11.264t57.344 11.264q10.24 11.264 19.456 23.04t12.288 29.184q3.072 14.336 0.512 27.648t-5.632 26.624-5.12 25.6 2.048 22.528q17.408 2.048 33.792-1.536t31.744-9.216 31.232-11.776 33.28-9.216q27.648-5.12 54.784-4.608t49.152 7.68 36.352 22.016 17.408 38.4q2.048 14.336-2.048 26.624t-8.704 23.04-7.168 22.016 1.536 23.552q3.072 7.168 14.848 13.312t27.136 12.288 32.256 13.312 29.184 16.384zM658.432 836.608q26.624-16.384 53.76-45.056t44.032-64 18.944-75.776-20.48-81.408q-19.456-33.792-47.616-57.344t-62.976-37.376-74.24-19.968-80.384-6.144q-78.848 0-139.776 16.384t-105.472 43.008-72.192 60.416-38.912 68.608q-11.264 33.792-6.656 67.072t20.992 62.976 42.496 53.248 57.856 37.888q58.368 25.6 119.296 32.256t116.224 0.512 100.864-21.504 74.24-33.792zM524.288 513.024q20.48 8.192 38.912 18.432t32.768 27.648q10.24 12.288 17.92 30.72t10.752 39.424 1.536 42.496-9.728 38.912q-8.192 18.432-19.968 37.376t-28.672 35.328-40.448 29.184-57.344 18.944q-61.44 11.264-117.76-11.264t-88.064-74.752q-12.288-39.936-13.312-70.656t16.384-66.56q13.312-27.648 40.448-51.712t62.464-38.912 75.264-17.408 78.848 12.8zM361.472 764.928q37.888 3.072 57.856-18.432t21.504-48.128-15.36-47.616-52.736-16.896q-27.648 3.072-43.008 23.552t-17.408 43.52 9.728 42.496 39.424 21.504zM780.288 6.144q74.752 0 139.776 19.968t113.664 57.856 76.288 92.16 27.648 122.88q0 33.792-16.384 50.688t-35.328 17.408-35.328-14.336-16.384-45.568q0-40.96-22.528-77.824t-59.392-64.512-84.48-43.52-96.768-15.872q-31.744 0-47.104-15.36t-14.336-34.304 18.944-34.304 51.712-15.36zM780.288 169.984q95.232 0 144.384 48.64t49.152 146.944q0 30.72-10.24 43.52t-22.528 11.264-22.528-14.848-10.24-35.84q0-60.416-34.816-96.256t-93.184-35.84q-19.456 0-28.672-10.752t-9.216-23.04 9.728-23.04 28.16-10.752z"/></svg>
    </a>
    
    
    <a class="social-link" title="github" href="https://github.com/Icegrave0391" target="_blank" rel="noopener">
        <svg viewbox="0 0 1049 1024" xmlns="http://www.w3.org/2000/svg"><path d="M524.979332 0C234.676191 0 0 234.676191 0 524.979332c0 232.068678 150.366597 428.501342 358.967656 498.035028 26.075132 5.215026 35.636014-11.299224 35.636014-25.205961 0-12.168395-0.869171-53.888607-0.869171-97.347161-146.020741 31.290159-176.441729-62.580318-176.441729-62.580318-23.467619-60.841976-58.234462-76.487055-58.234463-76.487055-47.804409-32.15933 3.476684-32.15933 3.476685-32.15933 53.019436 3.476684 80.83291 53.888607 80.83291 53.888607 46.935238 79.963739 122.553122 57.365291 152.97411 43.458554 4.345855-33.897672 18.252593-57.365291 33.028501-70.402857-116.468925-12.168395-239.022047-57.365291-239.022047-259.012982 0-57.365291 20.860106-104.300529 53.888607-140.805715-5.215026-13.037566-23.467619-66.926173 5.215027-139.067372 0 0 44.327725-13.906737 144.282399 53.888607 41.720212-11.299224 86.917108-17.383422 131.244833-17.383422s89.524621 6.084198 131.244833 17.383422C756.178839 203.386032 800.506564 217.29277 800.506564 217.29277c28.682646 72.1412 10.430053 126.029806 5.215026 139.067372 33.897672 36.505185 53.888607 83.440424 53.888607 140.805715 0 201.64769-122.553122 245.975415-239.891218 259.012982 19.121764 16.514251 35.636014 47.804409 35.636015 97.347161 0 70.402857-0.869171 126.898978-0.869172 144.282399 0 13.906737 9.560882 30.420988 35.636015 25.205961 208.601059-69.533686 358.967656-265.96635 358.967655-498.035028C1049.958663 234.676191 814.413301 0 524.979332 0z"/></svg>
    </a>
    
    
    <a class="social-link" title="facebook" href="https://facebook" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

    </a>
    
    
    <a class="social-link" title="twitter" href="https://twitter.com" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

    </a>
    
    
    
    
</div>
    </div>
</nav>
    </div>
</header>


<div id="site-main" class="site-main outer" role="main">
    <div class="inner">
        <header class="post-full-header">
            <div class="post-full-meta">
                <time class="post-full-meta-date" datetime="2020-03-07T09:18:10.000Z">
                    2020-03-07
                </time>
                
                <span class="date-divider">/</span>
                
                <a href="/categories/memory-forensics/">memory forensics</a>&nbsp;&nbsp;
                
                
            </div>
            <h1 class="post-full-title"></h1>
        </header>
        <div class="post-full no-image">
            
            <div class="post-full-content">
                <article id="photoswipe" class="markdown-body">
                    <h1 id="Memory-Forensics"><a href="#Memory-Forensics" class="headerlink" title="Memory Forensics"></a>Memory Forensics</h1><h2 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h2><ul>
<li>PAE: physical adress extension</li>
<li>AS: Address spaces is an interface that provides flexible and consistent accsee to data in RAM.</li>
<li><code>_KDDEBUGGER_DATA64</code>: characteristics of the kernel debugger data block .</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DBGKD_DEBUG_DATA_HEADER64</span> &#123;</span> </span><br><span class="line">		LIST_ENTRY64 List; </span><br><span class="line">		ULONG OwnerTag; </span><br><span class="line">		ULONG Size; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Windows keeps a store of some useful global variables in a structure called <strong><code>_KDDEBUGGER_DATA64</code></strong>. This information is used by the microsoft kernel debugger in order to bootstap the analysis of a crash dump.</p>
<h2 id="Volatility"><a href="#Volatility" class="headerlink" title="Volatility"></a>Volatility</h2><h3 id="selecting-a-profile"><a href="#selecting-a-profile" class="headerlink" title="selecting a profile"></a>selecting a profile</h3><p>In some cases that you don’t know the profile ahead of time, volatility includes two plugins that can help you determine the proper profile.(Windows only)</p>
<ol>
<li><code>imageinfo</code></li>
</ol>
<p>instruction: <code>python vol.py -f [filename] imageinfo</code></p>
<p><img alt="image-20200306172125272" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gckby9o9q2j30ng0c23z7.jpg" data-index="0" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gckby9o9q2j30ng0c23z7.jpg"></p>
<blockquote>
<p>it also shows you the date and time when the memory sample was collected, the number of CPUS, some characteristics of the AS, such as whether PAE is enabled; and the directory table base (DTB) value used for address translation.</p>
</blockquote>
<ol>
<li>kdbgscan</li>
</ol>
<p>instruction: <code>python vol.py -f [filename] kdbgscan</code></p>
<p>The name of the plugin gives you an idea of how the potential profiles are guessed: It finds and analyzes characteristics of the kernel debugger data block (_KDDEBUGGER_DATA64).</p>
<p><img alt="image-20200306173632863" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gckcdzzmjhj30mc0j0myc.jpg" data-index="1" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gckcdzzmjhj30mc0j0myc.jpg"></p>
<hr>
<p>Now, you may supply <code>--profile=WinXPSP3x86</code> when running other plugins.</p>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p><code>python vol.py -f memory.dmp --profile=XXXX volshell</code></p>
<h2 id="Memory-Dump-Formats"><a href="#Memory-Dump-Formats" class="headerlink" title="Memory Dump Formats"></a>Memory Dump Formats</h2><p>The volatility franeworks also provides several plugins, for exploring the metadara associated with many of the common file formats:</p>
<p><img alt="image-20200306195815213" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gckghgcb5rj30q509q75x.jpg" data-index="2" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gckghgcb5rj30q509q75x.jpg"></p>
<h3 id="gt-Raw-Memory-Dump"><a href="#gt-Raw-Memory-Dump" class="headerlink" title="&gt; Raw Memory Dump"></a>&gt; Raw Memory Dump</h3><ul>
<li>The most widely supported format among analysis tools. </li>
<li>Does not contain any headers, metadata, or magic values for file type identification.</li>
<li>typically includes padding for any memory ranges that were intentionally skipped (i.e., device memory) or that could not be read by the acquisition tool, which helps maintain spatial integrity (relative offsets among data).</li>
</ul>
<h3 id="gt-Windows-Crash-Dump"><a href="#gt-Windows-Crash-Dump" class="headerlink" title="&gt; Windows Crash Dump"></a>&gt; Windows Crash Dump</h3><p>This file format was designed for debugging purposes. It begins with a <code>_DMP_HEADER</code> structure. 》 </p>
<blockquote>
<p>The header identifies the major and minor OS version, the kernel DTB(Directory  Table Base), the address of the active process and loaded kernel module list heads, and information on the physical memory runs.</p>
</blockquote>
<p><img alt="image-20200306200642283" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gckgq8q2mkj30o90d3goe.jpg" data-index="3" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gckgq8q2mkj30o90d3goe.jpg"></p>
<h3 id="gt-Windows-Hibernation-File"><a href="#gt-Windows-Hibernation-File" class="headerlink" title="&gt; Windows Hibernation File"></a>&gt; Windows Hibernation File</h3><p>A hibernation file (hiberfil.sys) contains a compressed copy of memory that the system dumps to disk during the hibernation process.</p>
<blockquote>
<p>Hibernation files consist of a standard header (PO_MEMORY_IMAGE), a set of kernel contexts and registers such as CR3, and several arrays of compressed data blocks.</p>
</blockquote>
<p>An example of the hibernation file header:</p>
<p><img alt="image-20200306202051606" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gckh508ml5j30lg08mdh7.jpg" data-index="4" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gckh508ml5j30lg08mdh7.jpg"></p>
<h3 id="gt-Virtual-Machine-Memory"><a href="#gt-Virtual-Machine-Memory" class="headerlink" title="&gt; Virtual Machine Memory"></a>&gt; Virtual Machine Memory</h3><p>To acquire memory from a VM, you can run one of the aforementioned software tools within the guest OS (VM) or you can perform the acquisition from the hypervisor. </p>
<h2 id="5-Windows-Objects-and-Pool-Allocations"><a href="#5-Windows-Objects-and-Pool-Allocations" class="headerlink" title="5 Windows Objects and Pool Allocations"></a>5 Windows Objects and Pool Allocations</h2><h3 id="gt-Windows-Executive-Objects"><a href="#gt-Windows-Executive-Objects" class="headerlink" title="&gt; Windows Executive Objects"></a>&gt; Windows Executive Objects</h3><p>Windows is written in C and makes heavy use of C structures to organize related data and attributes. Several of these structures are called executive objects because they are managed (created, protected, deleted, etc.) by the Windows Object Manager—a component of the kernel implemented by the NT module.</p>
<blockquote>
<p><strong>All executive objects are structures</strong>, but not all structures are executive objects.</p>
</blockquote>
<p>The most forensically relevant executive <strong>objects types</strong> are described below:</p>
<p><img alt="image-20200306205927113" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcki94tb52j30mr0mbdji.jpg" data-index="5" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcki94tb52j30mr0mbdji.jpg"></p>
<p><img alt="image-20200306205941411" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcki9dg2blj30mr0700ts.jpg" data-index="6" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcki9dg2blj30mr0700ts.jpg"></p>
<h4 id="gt-gt-Object-Headers"><a href="#gt-gt-Object-Headers" class="headerlink" title="&gt;&gt; Object Headers"></a>&gt;&gt; Object Headers</h4><ul>
<li>One of the common traits(特性) shared between all executive object types is the presence of an object header (<code>_OBJECT_HEADER</code>)</li>
<li>The <strong>object header immediately precedes the executive object structure in memory</strong>.</li>
</ul>
<p>Finding the structure (i.e.,<code>_FILE_OBJECT</code> in the figure) given the address of its <code>_OBJECT_HEADER</code>, or vice versa, is simple because the two are always directly adjacent; and the size of <code>_OBJECT_HEADER</code> is consistent per operating system.</p>
<p><img alt="image-20200306210659152" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gckigz0i1sj30lr0ggjte.jpg" data-index="7" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gckigz0i1sj30lr0ggjte.jpg"></p>
<p><img alt="image-20200306210737514" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gckihmt5gnj30j40bhgmy.jpg" data-index="8" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gckihmt5gnj30j40bhgmy.jpg"></p>
<ul>
<li><code>PointerCount</code>: Contains the <strong>total number of pointers to the object</strong>, including kernelmode references.</li>
<li><code>HandleCount</code>: Contains the number of <strong>open handles to the object</strong>.</li>
<li><code>TypeIndex</code>: This value tells you <strong>what type of object you’re dealing with</strong> (e.g., process, thread, file).</li>
<li><code>InfoMask</code>: This value <strong>tells you which of the optional headers</strong>, if any, are present.</li>
<li><code>SecurityDescriptor</code>: Stores information on the security restrictions for the object, such as which users can access it for reading, writing, deleting, and so on.</li>
<li><code>Body</code>: This member is just a placeholder that represents the start of the structure contained within the object.</li>
</ul>
<h4 id="gt-gt-Optional-Headers"><a href="#gt-gt-Optional-Headers" class="headerlink" title="&gt;&gt; Optional Headers"></a>&gt;&gt; Optional Headers</h4><p>An object’s optional headers contain various types of metadata that help describe the object.</p>
<p><img alt="image-20200306211042526" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gckiktybbxj30n50a3tac.jpg" data-index="9" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gckiktybbxj30n50a3tac.jpg"></p>
<h4 id="gt-gt-Object-Type-Objects"><a href="#gt-gt-Object-Type-Objects" class="headerlink" title="&gt;&gt; Object Type Objects"></a>&gt;&gt; Object Type Objects</h4><p>Firstly, we take a look at <code>_OBJECT_HEADER</code> and find a member <code>TypeIndex</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x18     : TypeIndex               [&apos;unsigned char&apos;]</span><br></pre></td></tr></table></figure>
<p>This member is an index into <code>nt!ObTypeIndexTable</code>.</p>
<ul>
<li><code>nt!ObTypeIndexTable</code> is an array of type objects(<code>_OBJECT_TYPE</code>), which we have shown above at the begin of this chapter.</li>
</ul>
<blockquote>
<p>This data is critical to memory forensics because you can use it to determine the type of object that follows an _OBJECT_HEADER.</p>
</blockquote>
<p><strong>Data Structures:</strong></p>
<p><img alt="image-20200307170307117" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gclh1j8t7nj30hx09d75y.jpg" data-index="10" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gclh1j8t7nj30hx09d75y.jpg"></p>
<ul>
<li><code>Name</code>: This is a <strong>Unicode string name of the object type</strong> (Process, File, Key, etc.). </li>
<li><p><code>TotalNumberOfObjects</code>: The total number of objects of this particular object type that exist on the system.</p>
</li>
<li><p><code>TotalNumberOfHandles</code>: The total number of open handles to objects of this particular type.</p>
</li>
<li><p><code>TypeInfo</code>: An _OBJECT_TYPE_INITIALIZER structure that tells you the <strong>type of memory</strong> used to allocate instances of these objects (for example, paged or nonpaged memory).</p>
</li>
<li><code>Key</code>: A four-byte tag that is <strong>used to uniquely mark memory allocations</strong> that contain objects of this particular type.</li>
</ul>
<blockquote>
<p>The <code>TypeInfo</code> and <code>Key</code> members provide two clues that will prove to be invaluable to memory forensics—<strong>they essentially tell you where to look (in paged or nonpaged memory) and what to look for</strong> (a specific four-byte tag) to find all instances of a particular object type (for example, all processes or all files).</p>
</blockquote>
<p><strong>demo:</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">python vol.py –f memory.dmp --profile=Win7SP1x64 volshell </span><br><span class="line">Volatile Systems Volatility Framework <span class="number">2.4</span> </span><br><span class="line">Current context: <span class="keyword">process</span> System, pid=<span class="number">4</span>, ppid=<span class="number">0</span> DTB=<span class="number">0</span>x187000 </span><br><span class="line">To get help, type <span class="string">'hh()'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; kernel_space = addrspace()</span><br><span class="line">&gt;&gt;&gt; ObTypeIndexTable = <span class="number">0</span>xFFFFF80002870300</span><br><span class="line">&gt;&gt;&gt; ptrs = obj.Object(<span class="string">"Array"</span>, </span><br><span class="line">... 									targetType = <span class="string">"Pointer"</span>,</span><br><span class="line">... 									offset = ObTypeIndexTable,</span><br><span class="line">... 									count = <span class="number">100</span>,</span><br><span class="line">...					 					vm = kernel_space)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; ptrs[<span class="number">0</span>] </span><br><span class="line">&lt;NoneObject pointer to [<span class="number">0</span>x00000000]&gt;</span><br><span class="line">&gt;&gt;&gt; ptrs[<span class="number">1</span>] </span><br><span class="line">&lt;NoneObject pointer to [<span class="number">0</span>xBAD0B0B0]&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> i, ptr <span class="keyword">in</span> enumerate(ptrs):</span><br><span class="line">... 		objtype = ptr.dereference_as(<span class="string">"_OBJECT_TYPE"</span>) </span><br><span class="line">... 		<span class="keyword">if</span> objtype.is_valid():</span><br><span class="line">... 				print i, str(objtype.Name), <span class="string">"in"</span>,</span><br><span class="line">... 					str(objtype.TypeInfo.PoolType),</span><br><span class="line">... 					<span class="string">"with key"</span>, </span><br><span class="line">...						str(objtype.Key)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> Type <span class="keyword">in</span> NonPagedPool with key ObjT </span><br><span class="line"><span class="number">3</span> Directory <span class="keyword">in</span> PagedPool with key Dire </span><br><span class="line"><span class="number">4</span> SymbolicLink <span class="keyword">in</span> PagedPool with key Symb </span><br><span class="line"><span class="number">5</span> Token <span class="keyword">in</span> PagedPool with key Toke </span><br><span class="line"><span class="number">6</span> Job <span class="keyword">in</span> NonPagedPool with key Job </span><br><span class="line"><span class="number">7</span> <span class="keyword">Process</span> <span class="keyword">in</span> NonPagedPool with key Proc </span><br><span class="line"><span class="number">8</span> Thread <span class="keyword">in</span> NonPagedPool with key Thre </span><br><span class="line"><span class="number">9</span> UserApcReserve <span class="keyword">in</span> NonPagedPool with key User </span><br><span class="line"><span class="number">10</span> IoCompletionReserve <span class="keyword">in</span> NonPagedPool with key IoCo </span><br><span class="line"><span class="number">11</span> DebugObject <span class="keyword">in</span> NonPagedPool with key Debu </span><br><span class="line"><span class="number">12</span> Event <span class="keyword">in</span> NonPagedPool with key Even</span><br></pre></td></tr></table></figure>
<p>Note: We treated the data at kernel address 0xFFFFF80002870300 as an array of pointers to <code>_OBJECT_TYPE</code> structures.</p>
<ul>
<li><p>To get the address of 0xFFFFF80002870300 for the previous example, we typed</p>
<p><code>x nt!ObTypeIndexTable</code> into <code>Windbg</code>.</p>
</li>
<li><p>If don’t have Windbg, you can generate similar results by this: <code>python vol.py -f win7x64cmd.dd --profile=Win7SP0x64 objtypescan</code></p>
</li>
</ul>
<h3 id="gt-Kernel-Pool-Allocations"><a href="#gt-Kernel-Pool-Allocations" class="headerlink" title="&gt; Kernel Pool Allocations"></a>&gt; Kernel Pool Allocations</h3><p>A kernel pool is <strong>a range of memory that can be divided up into smaller blocks for storing any type of data that a kernel-mode component</strong> (the NT module, third-party device driver, etc.) requests.</p>
<ul>
<li>Similar to a heap, <strong>each allocated block has a header</strong> (<code>_POOL_HEADER</code>) that contains accounting and debugging information.</li>
</ul>
<p><img alt="image-20200307174538675" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcli9rw2c5j30iw0e8dho.jpg" data-index="11" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcli9rw2c5j30iw0e8dho.jpg"></p>
<p><strong>Data Structures of Pool Header:</strong></p>
<p><img alt="image-20200307175557004" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcliki40ydj30kw09tq4o.jpg" data-index="12" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcliki40ydj30kw09tq4o.jpg"></p>
<ul>
<li><p><code>BlockSize</code>: The <strong>total size of the allocation</strong>, including the pool header, object header, and any optional headers.</p>
</li>
<li><p><code>PoolType</code>: The <strong>type of system memory</strong> (paged, nonpaged, etc.) for which this pool header describes.</p>
</li>
<li><p><code>PoolTag</code>: A four-byte value, typically composed of ASCII characters that should uniquely identify the code path taken to produce the allocation (so troublesome blocks can be traced back to their source). </p>
</li>
</ul>
<h4 id="gt-gt-Allocation-APIs"><a href="#gt-gt-Allocation-APIs" class="headerlink" title="&gt;&gt; Allocation APIs"></a>&gt;&gt; Allocation APIs</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">ExAllocatePoolWithTag</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">	_In_ POOL_TYPE PoolType,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_ SIZE_T NumberOfBytes, </span></span></span><br><span class="line"><span class="function"><span class="params">	_In_ ULONG Tag</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>The <code>PoolType</code> argument specifies the type of system memory to use for the allocation. <code>NonPagedPool (0)</code> and <code>PagedPool (1)</code> are the enumeration values for nonpageable and pageable memory, respectively. (As previously shown, most, but not all, executive object types are allocated using nonpageable memory)</p>
</li>
<li><p>The <code>NumberOfBytes</code> argument contains the number of bytes to allocate. Drivers that call <code>ExAllocatePoolWithTag()</code> directly can set this to the size of data they need to store in the memory block. </p>
<blockquote>
<p>Executive objects are different, as you have already learned, because they require extra space to store the object headers and optional headers. A function in the kernel named <code>ObCreateObject</code> is the central point from which all executive objects are created. It determines the size of the requested structure (i.e., 1232 bytes for an <code>_EPROCESS</code> on 64-bit Windows 7) and adds the size of <code>_OBJECT_HEADER</code> and any optional headers that need to be present before calling <code>ExAllocatePoolWithTag()</code>.</p>
</blockquote>
</li>
<li><p>The <code>Tag</code> argument specifies a four-byte value, typically composed of ASCII characters that should uniquely identify the code path taken to produce the allocation (so troublesome blocks can be traced back to their source).</p>
</li>
</ul>
<p><strong>The steps of Allocation using Windows API:</strong></p>
<ol>
<li>The process calls <code>CreateFileA</code>(ASCII) or <code>CreateFileW</code> (Unicode)—both are exported by <code>kernel32.dll</code>.</li>
<li>The create file APIs lead into <code>ntdll.dll</code>, which subsequently calls into the kernel and reaches the native <code>NtCreateFile</code> function.</li>
<li><code>NtCreateFile</code> will call <code>ObCreateObject</code> to request a new File object type.</li>
<li><code>ObCreateObject</code> calculates the size of <code>_FILE_OBJECT</code> , including the extra space needed for its optional headers.</li>
<li><code>ObCreateObject</code> finds the <code>_OBJECT_TYPE</code> structure for File objects and determines whether to allocate paged or nonpaged memory, as well as the four-byte tag to use.</li>
<li><code>ExAllocatePoolWithTag</code> is called with the appropriate size, memory type, and tag.</li>
</ol>
<p>After the steps, a new <code>_FILE_OBJECT</code> exists in memory.</p>
<p>A pointer to the object header is added to the <strong>calling process’ handle table</strong>, <strong>a system-wide pool</strong> tag tracking database is updated accordingly, and the individual members of the <code>_FILE_OBJECT</code> are initialized with the path to the file being created and the requested access permissions (e.g., read, write, delete).</p>
<h4 id="gt-gt-De-allocation-and-Reuse"><a href="#gt-gt-De-allocation-and-Reuse" class="headerlink" title="&gt;&gt; De-allocation and Reuse"></a>&gt;&gt; De-allocation and Reuse</h4><p><em>When blocks of pool memory are released, they are simply marked as free, not immediately overwritten.</em></p>
<p>The single most important factor is how soon the process indicates (by calling <code>CloseHandle</code>) that it is finished reading or writing the new file.</p>
<ul>
<li><p>At this time, if no other processes are using the file object, the block of memory will be released back to the pool’s “<strong>free list</strong>,” where it <strong>can be reallocated</strong> for a different purpose.</p>
<blockquote>
<p>While waiting to be reallocated, or at any time before new data is written to the memory block, much of the original <code>_FILE_OBJECT</code> will remain intact.</p>
</blockquote>
</li>
</ul>
<h3 id="gt-Pool-Tag-Scanning"><a href="#gt-Pool-Tag-Scanning" class="headerlink" title="&gt; Pool-Tag Scanning"></a>&gt; Pool-Tag Scanning</h3><p>Pool-tag scanning, or simply pool scanning, refers to finding allocations based on the aforementioned four-byte tags.</p>
<p>Pool scanning, involves <strong>searching the entire memory dump file for Proc (the four-byte tag associated with <code>_EPROCESS</code>)</strong>. The advantage to the latter method is that you can find historical entries (processes that are no longer running) as well as defeat some rootkit hiding techniques.</p>
<p>Notes: Four-byte tag is only the start. For scanning a certain process, we also need additional information.</p>
<blockquote>
<p>Volatility builds a more robust “signature” of what memory around the desired allocations looks like, and it’s based on the information described earlier in the chapter. </p>
<p>For example, <strong>the size of the allocation</strong> and <strong>type of memory</strong> (paged, nonpaged) play a large role in eliminating false positives. If you’re looking for a 100-byte <code>_EPROCESS</code> and find <code>Proc</code> inside a 30-byte allocation, it cannot possibly be a real process because the memory block is too small.</p>
</blockquote>
<h4 id="gt-gt-Pool-Tag-Sources"><a href="#gt-gt-Pool-Tag-Sources" class="headerlink" title="&gt;&gt; Pool Tag Sources"></a>&gt;&gt; Pool Tag Sources</h4><p>The initial criteria thar Volatility uses to find the listed executive objects via pool scanning:</p>
<p><img alt="image-20200307192732037" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcll7splzej30or0bgwgc.jpg" data-index="13" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcll7splzej30or0bgwgc.jpg"></p>
<p>Also, notice the Tag(Protected) column in Table above. </p>
<p>One of the most infrequently documented intricacies <strong>regarding pool tags is the protected bit</strong>. When you free a pool with <code>ExFreePoolWithTag</code>, you must supply the same tag supplied to <code>ExAllocatePoolWithTag</code>.</p>
<blockquote>
<p>This is a technique the operating system uses to prevent drivers from freeing memory by accident. If the tag passed to the free function doesn’t match, the system will raise an exception.</p>
</blockquote>
<h4 id="gt-gt-Pooltag-file"><a href="#gt-gt-Pooltag-file" class="headerlink" title="&gt;&gt; Pooltag file"></a>&gt;&gt; Pooltag file</h4><p>As previously mentioned, Microsoft created pool tags for debugging and auditing purposes. Thus, some installations of the Windows Driver Development Kit (DDK) and Debugging Tools for Windows include a <code>pooltag.txt</code> file that you can use to perform lookups. </p>
<h4 id="gt-gt-PoolMon-Utility"><a href="#gt-gt-PoolMon-Utility" class="headerlink" title="&gt;&gt; PoolMon Utility"></a>&gt;&gt; PoolMon Utility</h4><p>A memory pool monitor. It reports live updates about the pool tags that are in use on a system:</p>
<ul>
<li><p>The memory type (Paged or Nonpaged)</p>
</li>
<li><p>Number of allocations </p>
</li>
<li><p>Number of frees </p>
</li>
<li><p>Total number of bytes occupied by allocations</p>
</li>
<li><p>Average bytes per allocation</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\WinDDK\7600.16385.1\tools\Other\i386&gt; poolmon.exe -b</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200307194403599" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcllozni70j30pv06ajso.jpg" data-index="14" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcllozni70j30pv06ajso.jpg"></p>
<p><strong>PoolMon is intended to provide real-time updates of changes in pool tag usage</strong>, it must be run on a live system. <strong>But what if you only have a memory dump?</strong> </p>
<p>Luckily, memory actually contains the statistics that PoolMon reads. They are accessible from the same kernel debugger data block (<code>_KDDEBUGGER_DATA64</code>) that stores the active process and loaded module lists.</p>
<h4 id="gt-gt-Pool-Tracker-Tables"><a href="#gt-gt-Pool-Tracker-Tables" class="headerlink" title="&gt;&gt; Pool Tracker Tables"></a>&gt;&gt; Pool Tracker Tables</h4><p>The PoolTrackTable member points to an array of <code>_POOL_TRACKER_TABLE</code> structures—<strong>one for each unique pool tag in use</strong>.</p>
<p><img alt="image-20200307194840141" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gclltsk52aj30mf076ab7.jpg" data-index="15" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gclltsk52aj30mf076ab7.jpg"></p>
<p>As you can see, each tracker table has a Key, which is the four-byte tag. The remaining members tell you how many allocations, frees, and total bytes are consumed for both nonpaged and paged memory.</p>
<p><strong>Although the information isn’t updated in real time</strong> (which makes sense because the system isn’t running anymore), you can at least <strong>determine its state at the time when the memory dump was acquired</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f win7x64.dd pooltracker</span><br><span class="line">								  --profile=Win7SP0x64</span><br><span class="line">									--tags=Proc,File,Driv,Thre</span><br></pre></td></tr></table></figure>
<p>The column names start with “<strong>Np</strong>” for nonpaged or “<strong>Pg</strong>” for paged:</p>
<p><img alt="image-20200307195317976" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcllylo7cuj30kb05yt9d.jpg" data-index="16" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcllylo7cuj30kb05yt9d.jpg"></p>
<h4 id="gt-gt-Pool-Scanner-Algorighm"><a href="#gt-gt-Pool-Scanner-Algorighm" class="headerlink" title="&gt;&gt; Pool Scanner Algorighm"></a>&gt;&gt; Pool Scanner Algorighm</h4><p><img alt="image-20200307203454870" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcln5xu1unj30ev0jxq4u.jpg" data-index="17" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcln5xu1unj30ev0jxq4u.jpg"></p>
<p>If you scan using a physical address space, the code starts looking for the four-byte pool tag at offset 0 of the memory dump file and continues until it reaches the end of the file. Otherwise, if a virtual address space is selected, it enumerates and scans all pages in the kernel’s page table.</p>
<h4 id="gt-gt-Finding-Terminated-Processes"><a href="#gt-gt-Finding-Terminated-Processes" class="headerlink" title="&gt;&gt; Finding Terminated Processes"></a>&gt;&gt; Finding Terminated Processes</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f win7x64.dd --profile=Win7SP0x64 psscan</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200307204659972" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gclnih5cwcj30oa0fegok.jpg" data-index="18" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gclnih5cwcj30oa0fegok.jpg"></p>
<h4 id="gt-gt-Limitations-of-Pool-Scanning"><a href="#gt-gt-Limitations-of-Pool-Scanning" class="headerlink" title="&gt;&gt; Limitations of Pool Scanning"></a>&gt;&gt; Limitations of Pool Scanning</h4><p><strong>Non-malicious Limitations</strong></p>
<ul>
<li><p><strong>Untagged pool memory</strong>: <code>ExAllocatePoolWithTag</code> is Microsoft’s recommended way for drivers and kernel-mode components to allocate memory, but it’s not the only option. A driver can also use <code>ExAllocatePool</code>, which is in the process of being deprecated, but is still available on many versions of Windows. <strong>This API allocates memory, but without a tag</strong>—leaving you no easy way to track or scan for the allocations.</p>
</li>
<li><p><strong>False positives</strong>: Because the pool-scanning technique is essentially based on pattern matching and heuristics, <strong>false positives are a possibility</strong>. This is especially true when scanning the physical address space because it includes data that the operating system discarded. To resolve false positives, you typically need to consider the context of the object (where it was found), if the member values make sense (this can vary per object), and if you found the object by other means such as alternate lists.</p>
</li>
<li><strong>Large allocations</strong>: The <strong>pool tag scanning technique does not work for allocations larger than 4096 bytes</strong> (see the upcoming section, “Big Page Pool”). Fortunately, all executive objects are less than this size.</li>
</ul>
<p><strong>Malicious Limitations (Anti-Forensics)</strong></p>
<ul>
<li><p><strong>Arbitrary tags</strong>: A driver can allocate memory <strong>using a generic, or default, tag</strong> such as “Ddk” (the last character is a space). This tag is used throughout the operating system and also third-party code when a tag is not specified. <strong>In other words, if malicious drivers use “Ddk” as their tag, the memory block will blend in with other allocations.</strong></p>
</li>
<li><p><strong>Decoy tags</strong>: As stated by Walters and Petroni (<a href="https://www.blackhat.com/presentations/bh-dc-07/Walters/Paper/bh-dc-07-Walters-WP.pdf" target="_blank" rel="noopener">https://www.blackhat.com/presentations/bh-dc-07/Walters/Paper/bh-dc-07-Walters-WP.pdf</a>) a driver <strong>can create fake (or decoy) objects that appear “life-like” to mislead investigators</strong>, effectively increasing the signal-to-noise ratio.</p>
</li>
<li><p><strong>Manipulated tags</strong>: Because tags are intended for debugging purposes, they aren’t critical for the stability of the operating system. <strong>Rootkits running in the kernel can modify pool tags</strong> (or any other value in the<code>_POOL_HEADER</code>, such as the block size and memory type) without any noticeable difference on the live machine, but the manipulation prevents Volatility’s pool scanner from working properly.</p>
</li>
</ul>
<h3 id="gt-Big-Page-Pool"><a href="#gt-Big-Page-Pool" class="headerlink" title="&gt; Big Page Pool"></a>&gt; Big Page Pool</h3><p>Windows kernel will try to group similarly sized allocations together. However, if the requested size exceeds one page (4096 bytes), the block of memory is allocated from a special pool (the big page pool) that is reserved for large allocations.</p>
<blockquote>
<p>In this case, the <code>_POOL_HEADER</code>, which contains the four-byte tag and exists at the base address for smaller allocations, is not used at all.</p>
</blockquote>
<p><img alt="image-20200307205528268" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gclnrammqkj30ny0g9wfq.jpg" data-index="19" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gclnrammqkj30ny0g9wfq.jpg"></p>
<h3 id="gt-Big-Page-Track-Tables"><a href="#gt-Big-Page-Track-Tables" class="headerlink" title="&gt; Big Page Track Tables"></a>&gt; Big Page Track Tables</h3><ul>
<li><p>The pool track tables ( <code>_POOL_TRACKER_TABLE</code>) for small memory blocks store statistics regarding the number of allocations and byte usage; but they don’t tell you the addresses of all the allocations (thus the need to scan). </p>
</li>
<li><p>Big page track tables, on the other hand, don’t store statistics, but they include the addresses of the allocations.</p>
</li>
</ul>
<p>the kernel symbol <code>nt!PoolBigPageTable</code>, which points to the array of <code>_POOL_TRACKER_BIG_PAGES</code> structures, (one for each large allocation), <strong>is neither exported nor copied to the kernel debugger data block</strong>.</p>
<p> However, <strong>this symbol can always be found at a predictable location relative to <code>nt!PoolTrackTable</code> (which is copied to the debugger data block).</strong> Thus, if you can find the pool track tables, you can find the big page track tables easily.</p>
<p><img alt="image-20200307205919311" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gclnvay4ejj30k504pq3l.jpg" data-index="20" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gclnvay4ejj30k504pq3l.jpg"></p>
<h4 id="gt-gt-Exploring-Big-Page-Pools"><a href="#gt-gt-Exploring-Big-Page-Pools" class="headerlink" title="&gt;&gt; Exploring Big Page Pools"></a>&gt;&gt; Exploring Big Page Pools</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f win7x64cmd.dd --profile=Win7SP0x64 bigpools &gt; bigpools.txt</span><br></pre></td></tr></table></figure>
<h2 id="6-Processes-Handles-and-Tokens"><a href="#6-Processes-Handles-and-Tokens" class="headerlink" title="6 Processes, Handles, and Tokens"></a>6 Processes, Handles, and Tokens</h2><p>This Chapter combines three of the most common initial steps in an investigation: determining what applications are running, what they’re doing(in terms of access to files, registry keys, and so on), and what security context(or privilege level) they have obtained.</p>
<h3 id="gt-Processes"><a href="#gt-Processes" class="headerlink" title="&gt; Processes"></a>&gt; Processes</h3><p>There are several of the basic resources that belong to a <strong>process</strong>:</p>
<p><img alt="image-20200308151829635" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmjn074wej30mj0gstao.jpg" data-index="21" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmjn074wej30mj0gstao.jpg"></p>
<ul>
<li><p><code>_EPROCESS</code>: the name of the structure that Windows uses to represent a process.</p>
<blockquote>
<p>all operating systems share the same concepts that are described in this high-level diagram.</p>
</blockquote>
</li>
<li><p>each process has its own private memory space that’s isolated from other processes.</p>
</li>
</ul>
<p>Inside this memory space, you can find the process executable; its list of loaded modules (DLLs or shared libraries); and its stacks, heaps, and allocated memory regions containing everything from user input to application-specific data structures.</p>
<ul>
<li>SIDs(security identifiers) and privilege data: a <strong>Security Identifier</strong> (commonly abbreviated <strong>SID</strong>) is a unique, immutable identifier of a user, user group, or other security principal.</li>
</ul>
<h4 id="gt-gt-Data-Structures"><a href="#gt-gt-Data-Structures" class="headerlink" title="&gt;&gt; Data Structures"></a>&gt;&gt; Data Structures</h4><p>Windows tracks processes by assigning them a unique <code>_EPROCESS</code> structure that resides in a <strong>non-paged pool</strong> of kernel memory.</p>
<p><img alt="image-20200308153340454" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmk2sm8tjj30lj0prwjk.jpg" data-index="22" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmk2sm8tjj30lj0prwjk.jpg"></p>
<p>and below:</p>
<p><img alt="image-20200308153352023" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmk2zufiwj30lq08u75q.jpg" data-index="23" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmk2zufiwj30lq08u75q.jpg"></p>
<ul>
<li><p><code>Pcb</code>: The <strong>kernel’s process control block</strong> (<code>_KPROCESS</code>). This structure is found at the base of <code>_EPROCESS</code> and contains several critical fields, including the DirectoryTableBase for address translation and the amount of time the process has spent in kernel mode and user mode.</p>
</li>
<li><p><code>CreateTime</code>: A UTC timestamp indicating when the process first started.</p>
</li>
<li><p><code>ExitTime</code>: A UTC timestamp indicating the time the process exited. <strong>This value is zero for still-running processes</strong>.</p>
</li>
<li><p><code>UniqueProcessId</code>: An integer that uniquely identifies the process (also known as the <strong>PID</strong>).</p>
</li>
<li><p><code>ActiveProcessLinks</code>: The <strong>doubly linked list that chains together active processes on the machine</strong>. Most APIs on a running system rely on walking this list. </p>
<blockquote>
<p>we can access all the process using <code>ActiveProcessLinks</code></p>
</blockquote>
</li>
<li><p><code>SessionProcessLinks</code>: Another doubly linked list that chains together processes in the same session.</p>
</li>
<li><p><code>InheritedFromUniqueProcessId</code>: An integer that specifies the <strong>PID of the parent process</strong>. After a process is running, this member is not modified, even if its parent terminates.</p>
</li>
<li><p><code>Session</code>: This member points to the <code>_MM_SESSION_SPACE</code> structure (see Chapter 14) that <strong>stores information on a user’s logon session and graphical user interface (GUI) objects.</strong></p>
</li>
<li><p><code>ImageFileName</code>: <strong>The filename portion of the process’ executable</strong>. This field stores the first 16 ASCII characters, so longer filenames will appear truncated. To get the full path to the executable, or to see the Unicode name, you can access the corresponding VAD node or members in the PEB (see Chapter 7).</p>
</li>
<li><p><code>ThreadListHead</code>: A doubly linked list that <strong>chains together all the process’ threads</strong> (each list element is an <code>_ETHREAD</code>).</p>
</li>
<li><p><code>ActiveThreads</code>: <strong>An integer indicating the number of active threads running in the process context</strong>. Seeing a process with zero active threads is a good sign that the process has exited.</p>
</li>
<li><p><code>Peb</code>: A pointer to the <strong>Process Environment Block (PEB)</strong>. Although this member (<code>_EPROCESS.Peb</code>) exists in kernel mode, it points to an address in user mode. <strong>The PEB contains pointers to the process’ DLL lists, current working directory, command line arguments, environment variables, heaps, and standard handles</strong>. </p>
</li>
<li><code>VadRoot</code>: The <strong>root node of the VAD tree</strong>. It contains detailed information <strong>about a process’ allocated memory segments, including the original access permissions</strong> (read, write, execute) and whether a file is mapped into the region.</li>
</ul>
<h4 id="gt-gt-Process-Organization"><a href="#gt-gt-Process-Organization" class="headerlink" title="&gt;&gt; Process Organization"></a>&gt;&gt; Process Organization</h4><p>The <code>_EPROCESS</code> structure contains a <code>_LIST_ENTRY</code> structure called <code>ActiveProcessLinks</code>.</p>
<p> The <code>_LIST_ENTRY</code> structure contains two members:</p>
<ul>
<li>Flink (forward link) that points to the <code>_LIST_ENTRY</code> of the next <code>_EPROCESS</code> structure</li>
<li>Blink (backward link) that points to the <code>_LIST_ENTRY</code> of the previous <code>_EPROCESS</code> structure.</li>
</ul>
<p><code>_LIST_ENTRY</code> structures:</p>
<p><img alt="image-20200308154619201" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmkfyh7iwj30nu0crdgn.jpg" data-index="24" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmkfyh7iwj30nu0crdgn.jpg"></p>
<p>Review:</p>
<p>To list processes, Volatility first locates the kernel debugger data block ( <code>_KDDEBUGGER_DATA64</code>). From there, it accesses the <code>PsActiveProcessHead</code> member, which points to the head of the doubly linked list of <code>_EPROCESS</code> structures. </p>
<p>We also discussed the pool-scanning approach in Chapter 5.</p>
<blockquote>
<p>In this chapter, we present many other ways to find processes in a memory dump. It is important to implement alternative methods because the debugger data block, the linked-list pointers, and the pool tags are all nonessential to OS stability—which means they can be manipulated (accidentally or intentionally) to defeat forensic tools without disrupting the system or its processes.</p>
</blockquote>
<h4 id="gt-gt-Critical-System-Processes"><a href="#gt-gt-Critical-System-Processes" class="headerlink" title="&gt;&gt; Critical System Processes"></a>&gt;&gt; Critical System Processes</h4><blockquote>
<p>if you know what’s normal, you can detect what’s abnormal more quickly</p>
</blockquote>
<p>So for now we’ll just focus on the theoretical concepts of how things should appear on clean systems.</p>
<ul>
<li><code>Idle</code> and <code>System</code>: These are not real processes (in the sense that they have no corresponding executable on disk). Idle is just a container that the kernel uses to charge CPU time for idle threads. Similarly, System serves as the default home for threads that run in kernel mode. Thus, the System process (PID 4) appears to own any sockets or handles to files that kernel modules open.</li>
<li><code>csrss.exe</code>: <strong>The client/server runtime subsystem plays a role in creating and deleting processes and threads</strong>. It maintains a private list of the objects that you can use to cross-reference with other data sources. </li>
<li><code>services.exe</code>: The Service Control Manager (SCM) in short, <strong>it manages Windows services and maintains a list of such services in its private memory space.</strong> This process should be the parent for any svchost.exe (service host) instances that you see, in addition to processes such as spoolsv.exe and SearchIndexer.exe that implement services. There should be only one copy of services.exe on a system, and it should be running from the system32 directory.</li>
<li><code>svchost.ex</code>e: A clean system has multiple shared host processes running concurrently, each providing a container for DLLs that implement services. As previously mentioned, their parent should be services.exe, and the path to their executable should point to the system32 directory. In his blog, Patrick identifies a few of the common names (such as scvhost.exe and svch0st.exe) used by malware to blend in with these processes.</li>
<li><code>lsass.exe</code>: The local security authority subsystem process is responsible for enforcing the security policy, verifying passwords, and creating access tokens. As such, it’s often the target of code injection because the plaintext password hashes can be found in its private memory space. There should be only one instance of lsass.exe running from the system32 directory, and its parent is winlogon.exe on pre-Vista machines, and wininit.exe on Vista and later systems. Stuxnet created two fake copies of lsass.exe, which caused them to stick out like a sore thumb.</li>
<li><code>winlogon</code>.exe : This process presents the interactive logon prompt, initiates the screen saver when necessary, helps load user profiles, and responds to Secure Attention Sequence (SAS) keyboard operations such as CTRL+ALT+DEL. Also, this process monitors files and directories for changes on systems that implement Windows File Protection (WFP). As with most other critical processes, its executable is located in the system32 directory.</li>
<li><code>explorer.exe</code>: You’ll see one Windows Explorer process for each logged-on user. It is responsible for handling a variety of user interactions such as GUI-based folder navigation, presenting the start menu, and so on. It also has access to sensitive material such as the documents you open and credentials you use to log in to FTP sites via Windows Explorer.</li>
<li><code>smss.exe</code>: The session manager is the first real user-mode process that starts during the boot sequence. It is responsible for creating the sessions (see Chapter 14) that isolate OS services from the various users who may log on via the console or Remote Desktop Protocol (RDP).</li>
</ul>
<h4 id="gt-gt-Analyzing-Process-Activity"><a href="#gt-gt-Analyzing-Process-Activity" class="headerlink" title="&gt;&gt; Analyzing Process Activity*"></a>&gt;&gt; Analyzing Process Activity*</h4><ul>
<li><code>pslist</code> <strong>finds and walks the doubly linked list of processes and prints a summary of the data.</strong> This method typically <strong>cannot show you terminated or hidden processes</strong>. </li>
<li><code>pstree</code> takes the output from pslist and formats it in a tree view, so you can easily see parent and child relationships.</li>
<li><code>psscan</code> <strong>scans for <code>_EPROCESS</code> objects instead of relying on the linked list</strong>. This plugin <strong>can also find terminated and unlinked (hidden) processes</strong>.</li>
<li><code>psxview</code> locates processes using alternate process listings, so you can then cross-reference different sources of information and reveal malicious discrepancies.</li>
</ul>
<h4 id="gt-gt-Process-Tree-Visualizations"><a href="#gt-gt-Process-Tree-Visualizations" class="headerlink" title="&gt;&gt; Process Tree Visualizations"></a>&gt;&gt; Process Tree Visualizations</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python vol.py psscan –f simple007.mem --profile=Win7SP1x64</span><br><span class="line">																	    --output=dot</span><br><span class="line">																	    --output-file=processes.dot</span><br><span class="line"></span><br><span class="line">⚙ chuqiz@Narny-6 =&gt; ~/Downloads/graphviz-2.40.1 =&gt; dot -Tsvg -o ~/tree.svg ~/Desktop/processes.dot</span><br></pre></td></tr></table></figure>
<p>Tree likes below：</p>
<p><img alt="image-20200308170307920" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmmnur1tmj31y60g0tbn.jpg" data-index="25" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmmnur1tmj31y60g0tbn.jpg"></p>
<h4 id="gt-gt-Detecting-DKOM-Attacks"><a href="#gt-gt-Detecting-DKOM-Attacks" class="headerlink" title="&gt;&gt; Detecting DKOM Attacks"></a>&gt;&gt; Detecting DKOM Attacks</h4><p>Many attacks are possible with Direct Kernel Object Manipulation (DKOM), but one of the most common is hiding a process by <strong>unlinking its entry from the doubly linked list</strong>. To accomplish this, overwrite the Flink and Blink pointers of surrounding objects so that they point around the <code>_EPROCESS</code> structure of the process to hide. Tools that execute on a running system and Volatility’s <code>pslist</code> command are susceptible to this attack, because they rely on the linked list. However, the <code>psscan</code> plugin uses the pool-scanning approach.</p>
<p><strong>Process Cross-View Plugin</strong></p>
<p>The <code>psxview</code> plugin enumerates processes in seven different ways: the active process linked list and the six methods previously identified. Thus, it’s unlikely that a rootkit can successfully hide from <code>psxview</code>.</p>
<p><img alt="image-20200308163252517" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmlsdh8aqj30y40k240f.jpg" data-index="26" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmlsdh8aqj30y40k240f.jpg"></p>
<h3 id="gt-Process-Tokens"><a href="#gt-Process-Tokens" class="headerlink" title="&gt; Process Tokens"></a>&gt; Process Tokens</h3><p>A process’ token describes its security context. This context includes security identifiers (SIDs) of users or groups that the process is running as and the various privileges (specific tasks) that it is allowed to perform.</p>
<p>When the kernel needs to decide whether a process can access an object or call a particular API, it consults data in the process’ token.</p>
<h4 id="gt-gt-Data-Structures-1"><a href="#gt-gt-Data-Structures-1" class="headerlink" title="&gt;&gt; Data Structures"></a>&gt;&gt; Data Structures</h4><p>The <code>_TOKEN</code> structure is large, so we won’t display all the members.</p>
<p><img alt="image-20200308164700337" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmm72qyj8j30lm0judj3.jpg" data-index="27" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmm72qyj8j30lm0judj3.jpg"></p>
<p>and below:</p>
<p><img alt="image-20200308164716818" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmm7czsqbj30n30pi42j.jpg" data-index="28" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmm7czsqbj30n30pi42j.jpg"></p>
<ul>
<li><p><code>UserAndGroupCount</code>: This integer stores the size of the <code>UserAndGroups</code> array.</p>
</li>
<li><p><code>UserAndGroups</code>: An array of <code>_SID_AND_ATTRIBUTES</code> structures associated with the token. Each element in the array describes a different user or group that the process is a member of. The <code>Sid</code> member of <code>_SID_AND_ATTRIBUTES</code> points to a <code>_SID</code> structure, which has <code>IdentifierAuthority</code> and <code>SubAuthority</code> members that you can combine to form the S-1-5-[snip] SID strings.</p>
</li>
<li><p><code>PrivilegeCount</code> (Windows XP and 2003 only): This integer stores the size of the <code>Privileges</code> array.</p>
</li>
<li><p><code>Privileges</code> (Windows XP and 2003): An array of <code>_LUID_AND_ATTRIBUTES</code> structures</p>
<p>that each describe a different privilege and its attributes (that is, present, enabled, enabled by default).</p>
</li>
<li><p><code>Privileges</code> (Windows Vista and later): This is an instance of <code>_SEP_TOKEN_PRIVILEGES</code>, which has three parallel 64-bit values (Present, Enabled, EnabledByDefault). The bit positions correspond to particular privileges, and the values of the bit (on or off) describe the privilege’s status.</p>
</li>
</ul>
<h4 id="gt-gt-Accessing-Tokens"><a href="#gt-gt-Accessing-Tokens" class="headerlink" title="&gt;&gt; Accessing Tokens"></a>&gt;&gt; Accessing Tokens</h4><p>On a live machine, a process can access its own token through the <code>OpenProcessToken</code> API. To enumerate the SIDs or privileges, it can then use <code>GetTokenInformation</code> with the desired parameters. </p>
<p>With administrator access, it can also query (or set) the tokens of other users’ processes, including the system-critical ones. Of course, existing tools already provide this type of functionality for you, such as <strong>Sysinternals Process Explorer</strong>.</p>
<p><img alt="image-20200308171420415" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmmziqholj30df0g7juz.jpg" data-index="29" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmmziqholj30df0g7juz.jpg"></p>
<p>This instance of explorer.exe belongs to a user named Jimmy, whose SID string is <code>S-1-5-21-[snip]-1000</code>. By analyzing the other SIDs in this process’ token, you can see it’s also in the <code>Everyone</code>, <code>LOCAL</code>, and <code>NT AUTHORITY\Authenticated Users</code> groups.</p>
<h4 id="gt-gt-Extracting-and-Translating-SIDs-in-Memory"><a href="#gt-gt-Extracting-and-Translating-SIDs-in-Memory" class="headerlink" title="&gt;&gt; Extracting and Translating SIDs in Memory"></a>&gt;&gt; Extracting and Translating SIDs in Memory</h4><p>there are User SIDs such as S-1-5-21-4010035002-774237572-2085959976-1000. These SIDs break down into the following components:</p>
<ul>
<li>S: Prefix indicating that the string is a SID </li>
<li>1: The revision level (version of the SID specification) from <code>_SID.Revision</code> </li>
<li>5: The identifier authority value from <code>_SID.IdentifierAuthority.Value</code> </li>
<li>21-4010035002-774237572-2085959976: The local computer or domain identifier from the <code>_SID.SubAuthority</code> values </li>
<li>1000: A relative identifier that represents any user or group that doesn’t exist by default</li>
</ul>
<p>You can map the SID string to a username by querying the registry:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f memory.img --profile=Win7SP0x86 printkey -K &quot;Microsoft\Windows NT\CurrentVersion\ProfileList\S-1-5-21-4010035002-774237572-2085959976-1000&quot;</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200308173111605" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmnh1ueklj30n80alta3.jpg" data-index="30" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmnh1ueklj30n80alta3.jpg"></p>
<h4 id="gt-gt-Detecting-Lateral-Movement"><a href="#gt-gt-Detecting-Lateral-Movement" class="headerlink" title="&gt;&gt; Detecting Lateral Movement"></a>&gt;&gt; Detecting Lateral Movement</h4><p>If you need to associate a process with a user account or investigate potential lateral movement attempts, use the getsids plugin.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python vol.py –f grrcon.img --profile=WinXPSP3x86 getsids –p 1096</span><br><span class="line"></span><br><span class="line">explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-500 (administrator) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-513 (Domain Users) explorer.exe: S-1-1-0 (Everyone) explorer.exe: S-1-5-32-545 (Users)</span><br><span class="line">explorer.exe: S-1-5-32-544 (Administrators) explorer.exe: S-1-5-4 (Interactive) explorer.exe: S-1-5-11 (Authenticated Users) explorer.exe: S-1-5-5-0-206541 (Logon Session) </span><br><span class="line">explorer.exe: S-1-2-0 (Local (Users with the ability to log in locally)) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-519 (Enterprise Admins) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-1115 </span><br><span class="line">explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-518 (Schema Admins) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-512 (Domain Admins)</span><br></pre></td></tr></table></figure>
<p>This command shows the SIDs associated with explorer.exe for the current logged-on user.</p>
<h3 id="gt-Privileges"><a href="#gt-Privileges" class="headerlink" title="&gt; Privileges"></a>&gt; Privileges</h3><p>Privileges are another critical component involved in security and access control. A privilege is the permission to perform a specific task, such as debugging a process, shutting down the computer, changing the time zone, or loading a kernel driver.</p>
<p>Before a process can enable a privilege, the privilege must be present in the process’ token. Administrators decide which privileges are present by configuring them in the Local Security Policy (LSP),</p>
<p>You can access the LSP by going to Start ➪ Run and typing SecPol.msc:</p>
<p><img alt="image-20200308174427394" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmnuuh2ldj30gi0iadg7.jpg" data-index="31" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmnuuh2ldj30gi0iadg7.jpg"></p>
<p><img alt="image-20200308174509331" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmnvkq70mj30q60gmjva.jpg" data-index="32" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmnvkq70mj30q60gmjva.jpg"></p>
<p>In English:</p>
<p><img alt="image-20200308174533487" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmnvzwow0j30k80ak0ye.jpg" data-index="33" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmnvzwow0j30k80ak0ye.jpg"></p>
<p>From a forensic perspective, you should be most concerned with the following privileges when they’ve been explicitly enabled:</p>
<ul>
<li><code>SeBackupPrivilege</code>: This grants read <strong>access to any file on the file system</strong>, regardless of its specified access control list (ACL). Attackers can leverage this privilege to copy locked files.</li>
<li><p><code>SeDebugPrivilege</code>: This <strong>grants the ability to read from or write to another process’ private memory space</strong>. It <strong>allows malware to bypass the security boundaries that typically isolate processes</strong>. Practically all malware that performs code injection from user mode relies on enabling this privilege.</p>
</li>
<li><p><code>SeLoadDriverPrivilege</code>: This <strong>grants the ability to load or unload kernel drivers</strong>.</p>
</li>
<li><code>SeChangeNotifyPrivilege</code>: This <strong>allows the caller to register a callback function that gets executed when specific files and directories change.</strong> Attackers can use this to determine immediately when one of their configuration or executable files are removed by antivirus or administrators.</li>
<li><code>SeShutdownPrivilege</code>: This <strong>allows the caller to reboot or shut down the system</strong>. Some infections, such as those that modify the Master Boot Record (MBR) don’t activate until the next time the system boots. Thus, you’ll often see malware trying to manually speed up the procedure by invoking a reboot.</li>
</ul>
<h4 id="gt-gt-Analyzing-Explicit-Privileges"><a href="#gt-gt-Analyzing-Explicit-Privileges" class="headerlink" title="&gt;&gt; Analyzing Explicit Privileges"></a>&gt;&gt; Analyzing Explicit Privileges</h4><p>Here’s the output of the Volatility <code>privs</code> plugin. You’ll see the privilege name along with its attributes (present, enabled, and/or enabled by default):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f grrcon.img privs -p 1096</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200308175020273" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmo0z63yvj30mv07swg1.jpg" data-index="34" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmo0z63yvj30mv07swg1.jpg"></p>
<p>and below:</p>
<p><img alt="image-20200308175027708" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmo13rnf6j30mm08qmza.jpg" data-index="35" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmo13rnf6j30mm08qmza.jpg"></p>
<p>You can see several privileges present in the output. Only six of them are enabled, but three are enabled by default.</p>
<h3 id="gt-Process-Handles"><a href="#gt-Process-Handles" class="headerlink" title="&gt; Process Handles"></a>&gt; Process Handles</h3><p>A handle is a reference to an open instance of a kernel object, such as a file, registry key, mutex, process, or thread.</p>
<blockquote>
<p>By enumerating and analyzing the specific objects a process was accessing at the time of a memory capture, it is possible to arrive at a number of forensically relevant conclusions—such as what process was reading or writing a particular file, what process accessed one of the registry run keys, and which process mapped remote file systems.</p>
</blockquote>
<h4 id="gt-gt-Lifetime-of-a-Handle"><a href="#gt-gt-Lifetime-of-a-Handle" class="headerlink" title="&gt;&gt; Lifetime of a Handle"></a>&gt;&gt; Lifetime of a Handle</h4><p>Before a process can access an object, it first opens a handle to the object by calling an API such as <code>CreateFile</code>, <code>RegOpenKeyEx</code>, or <code>CreateMutex</code>. These APIs return a special Windows data type called <code>HANDLE</code>, which is simply an index into a process-specific handle table.</p>
<p>For example, when you call <code>CreateFile</code>,</p>
<p> a pointer to the corresponding <code>_FILE_OBJECT</code> in kernel memory is placed in the first available slot in the calling process’ handle table, and the respective index (such as 0x40) is returned. Additionally, <strong>the handle count for the object is incremented</strong>. The calling process then passes the <code>HANDLE</code> value to functions that perform operations on the object, such as reading, writing, waiting, or deleting. Thus, APIs such as ReadFile and WriteFile work in the following manner:</p>
<ol>
<li>Find the base address of the calling process’ handle table.</li>
<li>Seek to index 0x40.</li>
<li>Retrieve the _FILE_OBJECT pointer.</li>
<li>Carry out the requested operation.</li>
</ol>
<p>When a process is finished using an object, it should close the handle by calling the appropriate function (<code>CloseHandle</code>, <code>RegCloseHandle</code>, and so on). These APIs <strong>decrement the object’s handle count</strong> and <strong>remove the pointer to the object from the process’ handle table</strong>.</p>
<p><strong>❓WHY USE HANDLE TABLE MODEL❓</strong></p>
<p>The handle table model was designed for both convenience and security.</p>
<ul>
<li>It’s convenient because <a href>you don’t have to pass the full name or path of an objec</a>t each time you perform an operation—only when you initially open or create the object. </li>
<li>For security purposes, it also helps to <strong>conceal the addresses of objects in kernel memory</strong>. Because processes in user mode should never directly access kernel objects, there’s no reason why they would need the pointers. </li>
<li>Furthermore, the model <strong>provides a centralized way for the kernel to monitor access to kernel objects</strong>, thus giving it the chance to enforce security based on SIDs and privileges.</li>
</ul>
<h4 id="gt-gt-Reference-Counts-and-Kernel-Handles"><a href="#gt-gt-Reference-Counts-and-Kernel-Handles" class="headerlink" title="&gt;&gt; Reference Counts and Kernel Handles"></a>&gt;&gt; Reference Counts and Kernel Handles</h4><p>So far in this section, we’ve been referring to processes as the entities that interact with objects <strong>via handles</strong>.</p>
<p>However, kernel modules, or threads in kernel mode, can call the equivalent kernel APIs (i.e., <code>NtCreateFile</code>, <code>NtReadFile</code>, <code>NtCreateMutex</code>) in a similar manner. In this case, the handles are <strong>allocated from the System (PID 4) process’ handle table.</strong> </p>
<blockquote>
<p>Thus, when you dump the handles of the System process, you’re <strong>actually seeing all the currently open resources requested by kernel modules.</strong></p>
</blockquote>
<ul>
<li><p>Even if handles are closed, and references are released, there’s still a chance that you can find the objects by scanning the physical address space (as described in Chapter 5).</p>
</li>
<li><p>Of course, they wouldn’t be associated with a process’ handle table at that point, but their <strong>presence in RAM can still lend clues to your investigations</strong>. </p>
<blockquote>
<p>Likewise, after a process terminates, its handle table is destroyed, but that doesn’t mean all objects created by the process are destroyed at the same time.</p>
</blockquote>
</li>
</ul>
<h4 id="gt-gt-Handle-Table-Internals"><a href="#gt-gt-Handle-Table-Internals" class="headerlink" title="&gt;&gt; Handle Table Internals"></a>&gt;&gt; Handle Table Internals</h4><p>Each process’ <code>_EPROCESS.ObjectTable</code> member <strong>points to a handle table</strong> ( <code>_HANDLE_TABLE</code>). This structure has a <code>TableCode</code> that serves two critical purposes: </p>
<ul>
<li>It <strong>specifies the number of levels in the table.</strong></li>
<li>It <strong>points to the base address of the first level.</strong> </li>
</ul>
<p>All processes start out with a single-level table, which is shown in Figure 6-12. The table size is one page (4096 bytes), and this scheme allows for up to 512 handles on a 32-bit system or 256 on a 64-bit system. Indexes in the table contain <code>_HANDLE_TABLE_ENTRY</code> structures if they’re in use; otherwise, they’re zeroed out.</p>
<p><img alt="image-20200308194859560" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmrgfjz3cj30o20dsabx.jpg" data-index="36" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmrgfjz3cj30o20dsabx.jpg"></p>
<p>Also, there are two-level even three-level table.</p>
<blockquote>
<p>You can image it as Page Directory and Page Table Entry and so on.</p>
</blockquote>
<h4 id="gt-gt-Data-Structures-2"><a href="#gt-gt-Data-Structures-2" class="headerlink" title="&gt;&gt; Data Structures"></a>&gt;&gt; Data Structures</h4><p><img alt="image-20200308195404675" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmrlq7r02j30m609bq4r.jpg" data-index="37" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmrlq7r02j30m609bq4r.jpg"></p>
<p>and below:</p>
<p><img alt="image-20200308195419291" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmrlytjh8j30mc0bjjtm.jpg" data-index="38" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmrlytjh8j30mc0bjjtm.jpg"></p>
<p>Some key points for <code>_HANDLE_TABLE</code>:</p>
<ul>
<li><code>TableCode</code>: This value <strong>tells you the number of levels in the table and points to the address of the top-level table</strong>. The dual purpose is achieved using a bit mask of seven (7). For example, to obtain the number of tables, you can compute TableCode &amp; 7; and to obtain the address, you can compute TableCode &amp; ~7. </li>
<li><code>QuotaProcess</code> : <strong>A pointer to the process to which the handle table belongs</strong>. It can come in handy if you find handle tables using the pool-scanning approach described in Chapter 5 rather than enumerating processes and following their ObjectTable pointer.</li>
<li><code>HandleTableList</code>: <strong>A linked list of process handle tables in kernel memory</strong>. You can use it to locate other handle tables—potentially even those for processes that have been unlinked from the process list.</li>
<li><code>HandleCount</code>: The <strong>total number of handle table entries</strong> that are currently in use by the process. This field was removed starting in Windows 8 and Server 2012.</li>
</ul>
<p>Some key points for <code>_HANDLE_TABLE_ENTRY</code>:</p>
<ul>
<li><p><code>Object</code>: This member points to the <code>_OBJECT_HEADER</code> of the corresponding object. The <code>_EX_FAST_REF</code> is a special data type that combines reference count information into the least significant bits of the pointer.</p>
</li>
<li><p><code>GrantedAccess</code>: A bit mask that specifies the granted access rights (read, write, delete, synchronize, etc.) that the owning process has obtained for the object.</p>
</li>
</ul>
<h3 id="gt-Enumerating-Handles-in-Memory"><a href="#gt-Enumerating-Handles-in-Memory" class="headerlink" title="&gt; Enumerating Handles in Memory*"></a>&gt; Enumerating Handles in Memory*</h3><p>The Volatility <code>handles</code> plugin generates output by walking the handle table data structures. There are a few filtering options:</p>
<ul>
<li><p>Filter by process ID: You can pass one or more (comma-separated) process IDs to the <code>-p/--pid</code> option.</p>
</li>
<li><p>Filter by process offset: You can supply the physical offset of an <code>_EPROCESS</code> structure to the <code>-o/--offset</code> option.</p>
</li>
<li><p>Filter by object type: If you’re interested in only a particular type of object, such as files or registry keys, you can specify the appropriate name(s) to the <code>-t/--object-type</code> option. See Chapter 5 or enter <code>!object \ObjectTypes</code> into Windbg to see the full list of object types.</p>
</li>
<li><p>Filter by name: Not all objects have names. Unnamed objects are obviously useless when searching for indicators by name, so one way to reduce noise is to use the <code>--silent</code> option, which suppresses handles to unnamed objects.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f zeus.vmem --profile=WinXPSP3x86 -p 632 handles</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200308200304795" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmrv336bfj30o2036gly.jpg" data-index="39" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmrv336bfj30o2036gly.jpg"></p>
<p>and below:</p>
<p><img alt="image-20200308200316769" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmrvan7y9j30nw06iq44.jpg" data-index="40" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmrvan7y9j30nw06iq44.jpg"></p>
<p>As shown in the next example, you can limit your search to files and mutexes opened by PID 632 and ignore unnamed objects:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f zeus.vmem --profile=WinXPSP3x86 -p 632 handles</span><br><span class="line">		-t File,Mutant</span><br><span class="line">		--silent</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200308200423716" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmrwge5e3j30o50df0vi.jpg" data-index="41" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmrwge5e3j30o50df0vi.jpg"></p>
<p>You see the user.ds and local.ds files, which contain the configuration and stolen data. The sdra64.exe file in the system32 directory is the initial Zeus installer.</p>
<blockquote>
<p>ou also may notice several open handles to <code>\Device\Tcp</code> and <code>\Device\Ip</code>. These are obviously different from the handles to files prefixed with <code>\Device\HarddiskVolume1</code>.</p>
<p>Specifically, Tcp and Ip are not files on the machine’s hard drive. This is described in Chapter 11, but what you’re essentially seeing are artifacts of network sockets that the process creates. Although sockets aren’t files, they support similar operations such as opening, reading, writing, and deleting. As a result, the same handle/descriptor subsystem can service both files and network sockets.</p>
<p>Along the same lines, <strong>named pipes are also represented as file objects</strong>. Thus, if malware creates a named pipe for interprocess communication or to redirect output of a backdoor command shell into a file, you can determine which processes are involved in that activity, provided that you <strong>know the name of the pipe it creates. In this case, it’s easy to identify because the name of the pipe that Zeus uses is the same as the standard mutex it creates to mark its presence on systems ( _AVIRA_)</strong>.</p>
</blockquote>
<h4 id="gt-gt-Detecting-Registry-Persistence"><a href="#gt-gt-Detecting-Registry-Persistence" class="headerlink" title="&gt;&gt; Detecting Registry Persistence"></a>&gt;&gt; Detecting Registry Persistence</h4><p>Malware often leverages the registry for persistence. To write the pertinent values, the malicious process must first open a handle to the desired registry key.</p>
<blockquote>
<p>you’ll see how obvious it is when malware chooses a well-known location (such as the Run key) and also suffers from a handle leak. You should not only recognize the registry key name but also the fact that you have numerous open handles to the same key.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f laqma.mem --profile=WinXPSP3x86 handles</span><br><span class="line">		--object-type=Key</span><br><span class="line">		--pid=1700</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200308202015902" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmsd08hraj30o60j3win.jpg" data-index="42" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmsd08hraj30o60j3win.jpg"></p>
<blockquote>
<p>The process has nearly 20 open handles to the RUN key (not all are shown). This is indicative of a bug in the code that fails to close its handles after opening them.</p>
</blockquote>
<p>Of course, the artifacts won’t always be this obvious, and just because a handle to a key is open, that doesn’t mean the process added values. </p>
<p>However, you can always confirm your suspicions by using the <code>printkey</code> plugin (see Chapter 10) to look at the actual data that the key contains:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f laqma.mem printkey -K &quot;MICROSOFT\WINDOWS\CURRENTVERSION\RUN&quot;</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200308202735782" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmsklhwp0j30nw0deac5.jpg" data-index="43" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmsklhwp0j30nw0deac5.jpg"></p>
<p>Based on their names, the final two entries seem suspicious—they cause <code>lanmanwrk.exe</code> and <code>KernelDrv.exe</code> to start automatically at each boot.</p>
<h4 id="gt-gt-Identifying-Remote-Mapped-Drives"><a href="#gt-gt-Identifying-Remote-Mapped-Drives" class="headerlink" title="&gt;&gt; Identifying Remote Mapped Drives"></a>&gt;&gt; Identifying Remote Mapped Drives</h4><p>Many adversaries rely on commands such as <code>net view</code> and <code>net use</code> to explore the surrounding network and map remote drives. </p>
<p>Obtaining read access to a company’s Server Message Block (SMB) file server or write access to various other workstations or servers in an enterprise can lead to successful lateral movement.</p>
<ul>
<li>The following example shows <strong>how an attacker navigates the network to mount two remote drives</strong>. The Users directory of a system named WIN-464MMR8O7GF is mounted on P, and the C$ share of a system named LH-7J277PJ9J85I is mounted at Q:</li>
</ul>
<p><img alt="image-20200308203556523" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmsta2ujuj30m70ic0v9.jpg" data-index="44" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmsta2ujuj30m70ic0v9.jpg"></p>
<ul>
<li><p><strong>The trick to finding evidence of remote mapped drives in memory</strong> is to look for file handles prefixed with <code>\Device\Mup</code> and <code>\Device\LanmanRedirector</code>:</p>
<blockquote>
<p>MUP, which stands for Multiple Universal Naming Convention (UNC) Provider, is a kernel-mode component that channels requests to access remote files using UNC names to the appropriate network redirector. In this case, <code>LanmanRedirector</code> handles the SMB protocol.</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f hop.mem --profile=VistaSP2x64 handles -t File | grep Mup</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200308204050322" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcmsydpfuej30o10a9aby.jpg" data-index="45" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcmsydpfuej30o10a9aby.jpg"></p>
<p>You have several plain handles to <code>\Device\Mup</code> (they are normal). The few in bold are the ones you should find interesting because they actually display the local drive letter, the remote NetBIOS name, and the share or file system path name. </p>
<blockquote>
<p>There are also two different process IDs shown: 752 and 1544. In this case, 752 is the instance of svchost.exe that runs the LanmanWorkstation service; it creates and maintains client network connections to remote servers using the SMB protocol. PID 1544 is the cmd.exe shell, and it has a handle to <code>C$\Users\Jimmy\Documents</code> as a result of the attacker changing into that directory.</p>
</blockquote>
<h2 id="7-Process-Memory-Internals"><a href="#7-Process-Memory-Internals" class="headerlink" title="7 Process Memory Internals"></a>7 Process Memory Internals</h2><p>This chapter analyzes the various application programming interfaces (APIs) used for allocating the different data types and examines how to enumerate process memory regions via memory forensics.</p>
<h3 id="gt-What’s-in-Process-Memory"><a href="#gt-What’s-in-Process-Memory" class="headerlink" title="&gt; What’s in Process Memory?"></a>&gt; What’s in Process Memory?</h3><p>As you know, each process has its owen private view of memory in this range(upper bounds of the range can be vary between of operating systems).</p>
<p>We simply represented the highest value as <code>MmHighestUserAddress</code>.</p>
<blockquote>
<p>This is a symbol in the NT module that you can query with a debugger or inside Volatility’s <code>volshell</code> plugin.</p>
</blockquote>
<p><img alt="image-20200309151913862" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnpa1y6n7j30e10dgdgk.jpg" data-index="46" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnpa1y6n7j30e10dgdgk.jpg"></p>
<p>It’s important to know that <strong>the positions of the ranges are not constant, especially on systems that levergae address spase layout randomization(ASLR)</strong>.</p>
<blockquote>
<p>the thread stacks can exist below or above the process executable, or the ranges containing mapped files can be interspersed throughout the entire process space, not gathered contiguously as the diagram above shows.</p>
</blockquote>
<ul>
<li><p><code>Dynamic linked libraries (DLLs)</code>: This area represents <strong>shared libraries (DLLs) that were loaded into the address space</strong>, either intentionally by the process or forcefully through library injection.</p>
</li>
<li><p><code>Environment variables</code>: This range of memory <strong>stores the process’ environment variables, such as its executable paths, temporary directories, home folders</strong>, and so on.</p>
</li>
<li><p><code>Process Environment Block (PEB)</code>: An extremely useful structure that <strong>tells you where to find several of the other items in this list</strong>, including the DLLs, heaps, and environment variables. It also contains the process’ command line arguments, its current working directory, and its standard handles.</p>
</li>
<li><p><code>Process heaps</code>: Where you can find a majority of the dynamic input that the process receives. </p>
<blockquote>
<p>For example, variable-length text that you type into e-mail or documents is often placed on the heap, as is data sent or received over network sockets.</p>
</blockquote>
</li>
<li><p><code>Thread stacks</code>: <strong>Each thread has a dedicated range of process memory set aside for its runtime stack</strong>. This is where you can find function arguments, return addresses (allowing you to reconstruct call history), and local variables.</p>
</li>
<li><p><code>Mapped files and application data</code>: This item is left intentionally vague because the content really depends on the process. <strong>Mapped files represent content from files on disk, which could be configuration data, documents, and so on</strong>. <strong>Application data is anything the process needs to perform its intended duties</strong>.</p>
</li>
<li><p><code>Executable</code>: The process executable contains <strong>the primary body of code and read/ write variables for the application</strong>. This data may be compressed or encrypted on disk, <strong>but once loaded into memory, it unpacks, enabling you to dump plain-text code back to disk</strong>.</p>
</li>
</ul>
<h3 id="Memory-Allocation-APIs"><a href="#Memory-Allocation-APIs" class="headerlink" title="Memory Allocation APIs"></a>Memory Allocation APIs</h3><p><img alt="image-20200309152939761" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnpkwg0pvj30ox0f9q5l.jpg" data-index="47" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnpkwg0pvj30ox0f9q5l.jpg"></p>
<p>QUESTION❓</p>
<p>These two virtual allocation functions are also the only ones that allow the caller to reserve memory (that is, set it aside) before committing it. This allows applications to “save” a large region of virtually contiguous memory for later use, without tying up the underlying physical pages in the meantime.</p>
<p>WHY？</p>
<h3 id="gt-Enumerating-Process-Memory"><a href="#gt-Enumerating-Process-Memory" class="headerlink" title="&gt; Enumerating Process Memory"></a>&gt; Enumerating Process Memory</h3><h4 id="gt-gt-Process-Page-Tables"><a href="#gt-gt-Process-Page-Tables" class="headerlink" title="&gt;&gt; Process Page Tables"></a>&gt;&gt; Process Page Tables</h4><p>We can use <code>memmap</code> and <code>memdump</code> plugins to list and extract all pages accessible to a process.</p>
<blockquote>
<p>In this case, accessible includes kernel mode addresses because even threads that start in user memory transition into kernel memory when system APIs are called.</p>
</blockquote>
<p><img alt="image-20200309154721770" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnq3brf4gj30fw0e0my0.jpg" data-index="48" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnq3brf4gj30fw0e0my0.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python vol.py -f memory.dmp --profile=Win7SP0x64 memmap –p 864</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200309154752063" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnq3ugu07j30mb0aidh4.jpg" data-index="49" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnq3ugu07j30mb0aidh4.jpg"></p>
<p>and below:</p>
<p><img alt="image-20200309154806825" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnq43wktzj30md08pwfp.jpg" data-index="50" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnq43wktzj30md08pwfp.jpg"></p>
<p>Although the system’s default page size is 4KB (<code>0x1000</code> bytes hex), you can see a few pages of size <code>0x200000</code>, which is 2MB. These are Page Size Entry (PSE) pages.</p>
<ul>
<li><p><code>DumpFileOffset</code>: This value specifies the offset of the corresponding page in the file produced by the <code>memdump</code> plugin. </p>
<blockquote>
<p>Because process address spaces are sparse—holes or gaps exist between available pages—the output file is also sparse. For example, the data at virtual address <code>0xff4c1000</code> maps to physical offset <code>0x151b77000</code> (5.2GB), but your output file for this process will be nowhere near that large. Thus, the <code>DumpFileOffset</code> column tells you where to find the contents of <code>0xff4c1000</code> in your output file (<code>0x2a3000</code>). </p>
</blockquote>
</li>
</ul>
<p><code>memdump</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python vol.py -f memory.dmp --profile=Win7SP1x64 memdump -p 864 -D OUTDIR</span><br><span class="line">$ ls -alh OUTDIR/864.dmp </span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">-rw-r--r-- 1 michael staff           434M Mar 14 14:51 864.dmp</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200309160654094" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnqnnldlhj30lo0frgov.jpg" data-index="51" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnqnnldlhj30lo0frgov.jpg"></p>
<h3 id="gt-Virtual-Address-Descriptors"><a href="#gt-Virtual-Address-Descriptors" class="headerlink" title="&gt; Virtual Address Descriptors"></a>&gt; Virtual Address Descriptors</h3><p>A process’ VAD tree describes the layout of its memory segments at a slightly higher level than the page tables. </p>
<p><em>The operating system, not the CPU, defines and maintains these data structures.</em></p>
<blockquote>
<p>VADs contain the names of memory-mapped files, the total number of pages in the region, the initial protection (read, write, execute), and several other flags that can tell you a lot about what type of data the regions contain.</p>
</blockquote>
<p>Each node in the tree <strong>represents one range in process virtual memory</strong>. A node that describes a memory range lower than its parent appears on the left, and a node that describes a higher range appears on the right：</p>
<p><img alt="image-20200309161110171" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnqs3f7mtj30on0c43zo.jpg" data-index="52" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnqs3f7mtj30on0c43zo.jpg"></p>
<h4 id="gt-gt-VAD-Structures"><a href="#gt-gt-VAD-Structures" class="headerlink" title="&gt;&gt; VAD Structures"></a>&gt;&gt; VAD Structures</h4><p>For each process, <code>_EPROCESS.VadRoot</code> points to the root of the VAD tree.</p>
<blockquote>
<p>the type of the member has frequently changed, as have the names of the VAD nodes. The differences are shown in Table below. For example, on Windows XP and 2003 Server, VadRoot pointed to an<code>_MMVAD_SHORT</code>, <code>_MMVAD</code>, or <code>_MMVAD_LONG</code>.</p>
</blockquote>
<p><img alt="image-20200309161744038" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnqyx67iqj30ol08uwft.jpg" data-index="53" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnqyx67iqj30ol08uwft.jpg"></p>
<p><code>_MM_AVL_TABLE</code>:</p>
<p><img alt="image-20200309164359492" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnrq8u3rnj30nz08a0uc.jpg" data-index="54" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnrq8u3rnj30nz08a0uc.jpg"></p>
<ul>
<li>You can see the <code>_MM_AVL_TABLE</code> has a BalancedRoot member, which is an <code>_MMADDRESS_NODE</code>.</li>
<li><strong><em>Each node</em> has a set of pointers to its child nodes and a <code>StartingVpn</code> and <code>EndingVpn</code>.</strong> From these <strong>virtual page numbers (VPNs)</strong>, you can derive the addresses of the first and last pages in the target process’ virtual memory.</li>
<li>VPNs are page numbers, not addresses.(To get the address, you have to multiply the page number by the size of a page.)</li>
</ul>
<p><code>_MMADDRESS_NODE(40 bytes)</code>:</p>
<p>It is an alias and it is really one of the <code>_MMVAD*</code>(short, regular, long)</p>
<p><img alt="image-20200309164742768" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnru4bhuqj30nu059757.jpg" data-index="55" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnru4bhuqj30nu059757.jpg"></p>
<p><code>_MMVAD_SHORT</code>:</p>
<p><img alt="image-20200309165155887" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnryihkurj30o507r0u3.jpg" data-index="56" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnryihkurj30o507r0u3.jpg"></p>
<p><code>_MMVAD</code>:</p>
<p><img alt="image-20200309165226422" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnrz1cz78j30ny0cpgo8.jpg" data-index="57" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnrz1cz78j30ny0cpgo8.jpg"></p>
<p><code>_MMVAD_LONG</code>:</p>
<p><img alt="image-20200309165303141" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnrzoc1uzj30ne037jrn.jpg" data-index="58" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnrzoc1uzj30ne037jrn.jpg"></p>
<p>and below:</p>
<p><img alt="image-20200309165317383" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnrzx8k6ij30ny0aptav.jpg" data-index="59" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnrzx8k6ij30ny0aptav.jpg"></p>
<p>a short node does not have a <code>Subsection</code>, thus it cannot possibly store a mapped file. </p>
<p>On the other hand, shell code that gets injected into a process never needs to exist on disk. </p>
<p>Thus, it won’t be backed by a file. As a result, <strong>if you’re hunting for code injection, you can probably ignore the regular and long nodes</strong>.</p>
<h4 id="gt-gt-VAD-Tags"><a href="#gt-gt-VAD-Tags" class="headerlink" title="&gt;&gt; VAD Tags"></a>&gt;&gt; VAD Tags</h4><p>After reading the structures above, you may wonder how Volatility determines which of the three <code>_MMVAD*</code> structures is aliased by an <code>_MMADDRESS_NODE</code>.</p>
<p>The answer is <code>Tag</code> member.(The offset of this member is -<code>0xc</code>)</p>
<blockquote>
<p>Indeed, this is a convenient hack allowed when defining structures with Volatility. Essentially what we’re doing is accessing the <code>PoolTag</code> member of the <code>_POOL_HEADER</code>, which exists in memory directly before the node.</p>
</blockquote>
<p>A mapping of VAD-Related Pool Tags to Strucrute type:</p>
<p><img alt="image-20200309171826693" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcnsq3c6zzj30of06ft94.jpg" data-index="60" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcnsq3c6zzj30of06ft94.jpg"></p>
<p><strong>Memory regions that contain injected shell code won’t be backed by a file. Thus, you would be looking for nodes with a VadS or VadF tag.</strong></p>
<h4 id="gt-gt-VAD-Flags"><a href="#gt-gt-VAD-Flags" class="headerlink" title="&gt;&gt; VAD Flags"></a>&gt;&gt; VAD Flags</h4><p>Each node has one or more sets of flags that contain characteristics about the memory range.(These flags are located in embedded unions named u, u1, u2, u3, and so on).</p>
<p>This name is based on <code>unnamed-tag</code> because unions don’t have associated types.</p>
<p><img alt="image-20200309174815086" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcntl3y1nrj30li0bitb9.jpg" data-index="61" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcntl3y1nrj30li0bitb9.jpg"></p>
<p>Bits 0 to 51 of the 8-byte value are for CommitCharge, and bits 56 to 61 are the Protection.</p>
<h4 id="gt-gt-CommitCharge"><a href="#gt-gt-CommitCharge" class="headerlink" title="&gt;&gt; CommitCharge"></a>&gt;&gt; CommitCharge</h4><p><code>CommitCharge</code> specifies the number of pages committed in the region described by the VAD node.</p>
<p>QUESTION:❓</p>
<p>The reason we care about this field is because historically when code injecting malware sets up the target process’ address space to receive the malicious code, it commits all pages up front—it doesn’t reserve them and then go back and commit them later (although it very well could). Thus, you can use these additional characteristics to help identify injected memory regions.</p>
<h4 id="gt-gt-Protection"><a href="#gt-gt-Protection" class="headerlink" title="&gt;&gt; Protection"></a>&gt;&gt; Protection</h4><p>This field indicates what type of access should be allowed to the memory region.</p>
<ul>
<li><p><code>PAGE_EXECUTE</code>: The memory can be executed, but not written. This protection cannot be used for mapped files.</p>
</li>
<li><p><code>PAGE_EXECUTE_READ</code>: The memory can be executed or read, but not written.</p>
</li>
<li><p><code>PAGE_EXECUTE_READWRITE</code>: The memory can be executed, read, or written. Injected code regions almost always have this protection.</p>
</li>
<li><p><code>PAGE_EXECUTE_WRITECOPY</code>: Enables execute, read-only, or copy-on-write access to a mapped view of a file. It cannot be set by calling <code>VirtualAlloc</code> or <code>VirtualAllocEx</code>. DLLs almost always have this protection.</p>
</li>
<li><p><code>PAGE_NOACCESS</code>: Disables all access to the memory. This protection cannot be used for mapped files. Applications can prevent accidental reads/writes to data by setting this protection.</p>
</li>
<li><p><code>PAGE_READONLY</code>: The memory can be read, but not executed or written. </p>
</li>
<li><code>PAGE_READWRITE</code>: The memory can be read or written, but not executed.</li>
<li><code>PAGE_WRITECOPY</code>: Enables read-only or copy-on-write access to a mapped view of a file. It cannot be set by calling VirtualAlloc or VirtualAllocEx.</li>
</ul>
<p>Note:</p>
<p>Protection field from the VAD <code>flags</code> is that it’s only the <strong>initial protection</strong> specified for all pages in the range when they were first reserved or committed. Thus, the current protection can be drastically different.</p>
<h4 id="gt-gt-Private-Memory"><a href="#gt-gt-Private-Memory" class="headerlink" title="&gt;&gt; Private Memory"></a>&gt;&gt; Private Memory</h4><p>Private memory, in this context, refers to committed regions that <strong>cannot typically be shared with or inherited by other processes</strong>.</p>
<ul>
<li>Mapped files, named shared memory, and copy-onwrite DLLs can be shared with other processes (although they may not be). <strong>Thus, if the <code>PrivateMemory</code> bit is set for a memory region, it does not contain one of the aforementioned types of data</strong>. </li>
<li>A process’ heaps, stacks, and ranges allocated with <code>VirtualAlloc</code> or <code>VirtualAllocEx</code> are usually marked as private.</li>
</ul>
<h4 id="gt-gt-Volatility-VAD-Plugins"><a href="#gt-gt-Volatility-VAD-Plugins" class="headerlink" title="&gt;&gt; Volatility VAD Plugins"></a>&gt;&gt; Volatility VAD Plugins</h4><ul>
<li><code>vadinfo</code> : Displays the most verbose output, including the starting and ending addresses, the protection level, flags, and full paths to mapped files or DLLs. </li>
</ul>
<p><img alt="image-20200310011133726" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gco6eevfzsj30pb07a75c.jpg" data-index="62" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gco6eevfzsj30pb07a75c.jpg"></p>
<ul>
<li><p><code>vadtree</code>: In text mode, this plugin prints a tree-view of the nodes, so you can see the parent and child relationships on your console. </p>
</li>
<li><p><code>vaddump</code> : <strong>Extracts the range of process memory each VAD node describes to a separate file on disk</strong>. Unlike memmap (discussed earlier), the output from this plugin is padded with zeros if any pages in the range are swapped to disk to maintain spatial integrity (offsets).</p>
</li>
</ul>
<h2 id="8-Hunting-Malware-in-Process-Memory"><a href="#8-Hunting-Malware-in-Process-Memory" class="headerlink" title="8 Hunting Malware in Process Memory"></a>8 Hunting Malware in Process Memory</h2><p>Now we will see some specific examples of how can detect malware that hides in process by unlinking dynamic linked ilbraries(DLL) or using one of four different methods of injecting code.</p>
<h3 id="gt-Process-Environment-Block-PEB"><a href="#gt-Process-Environment-Block-PEB" class="headerlink" title="&gt; Process Environment Block(PEB)"></a>&gt; Process Environment Block(PEB)</h3><p>Every<code>_EPROCESS</code> structure contains a member called the Process Environment Block (PEB). </p>
<p>The PEB contains the full path to the process’ executable, the full command line that starts the process, the current working directory, pointers to the process’ heaps, standard handles, and three doubly linked lists that contain the full path to DLLs loaded by the process.</p>
<h4 id="gt-gt-Data-Structures-3"><a href="#gt-gt-Data-Structures-3" class="headerlink" title="&gt;&gt; Data Structures"></a>&gt;&gt; Data Structures</h4><p>The main PEB structure is appropriately named <code>_PEB</code>. </p>
<blockquote>
<p><code>_PEB</code> structure exists in process memory, so <strong>a process can easily modify its own values</strong> to falsely report information or thwart analysis.</p>
</blockquote>
<p><img alt="image-20200310174936970" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcoz8u5pulj30ny0bp0ut.jpg" data-index="63" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcoz8u5pulj30ny0bp0ut.jpg"></p>
<p>Key Points:</p>
<ul>
<li><p><code>BeingDebugged</code>: Tells you whether the process is currently being debugged. In the past, we’ve seen malware that attaches to itself (by calling <code>DebugActiveProcess</code>).</p>
<blockquote>
<p>Because only one debugger at a time can attach to a target process, it served as anti-debugging protection. Thus, <strong>there is a red flag if this value is set to true, but there are no legitimate active debuggers running</strong>.</p>
</blockquote>
</li>
<li><p><code>ImageBaseAddress</code> : <strong>The address in process memory where the main executable (.exe) is loaded</strong>. Before Volatility’s <code>procdump</code> plugin (described later in the chapter) carves an executable from memory, it reads this value so it knows where to look. </p>
</li>
<li><code>Ldr</code>: Points to a <code>_PEB_LDR_DATA</code> structure, which <strong>contains details about the DLLs loaded in a process</strong>.</li>
<li><p><code>ProcessParameters</code>: Points to a <code>_RTL_PROCESS_PARAMETERS</code> structure (described soon).</p>
</li>
<li><p><code>ProcessHeap</code>: Primary heap for the process, which is created automatically when the process is initialized.</p>
</li>
<li><p><code>NumberOfHeaps</code>: Number of heaps in a process. By default, a process has only one heap, but it can create others by calling <code>HeapCreate</code>.</p>
</li>
<li><p><code>ProcessHeaps</code> : An array of pointers to process heaps. The first entry in this list always points to the same location as ProcessHeap because it is the primary.</p>
</li>
</ul>
<p>Then we look into the <code>_RTL_USER_PROCESS_PARAMETERS</code> structure:</p>
<p><img alt="image-20200310180558394" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcozpuoyqpj30nr04mgm8.jpg" data-index="64" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcozpuoyqpj30nr04mgm8.jpg"></p>
<p>and below:</p>
<p><img alt="image-20200310180640220" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcozqkx6gbj30nq04p3z2.jpg" data-index="65" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcozqkx6gbj30nq04p3z2.jpg"></p>
<p>Key Points:</p>
<ul>
<li><code>StandardInput</code>: The process’ standard input handle. </li>
<li><p><code>StandardOutput</code>: The process’ standard output handle.</p>
</li>
<li><p><code>StandardError</code>: The process’ standard error handle.</p>
</li>
<li><p><code>CurrentDirectory</code>: The current working directory for the application.</p>
</li>
<li><p><code>ImagePathName</code>: The Unicode full path on disk to the process executable (.exe).</p>
<blockquote>
<p>You often need to consult this value because the <code>_EPROCESS.ImageFileName</code> (printed by the pslist plugin) contains only the first 16 characters and it does not include Unicode.</p>
</blockquote>
</li>
<li><p><code>CommandLine</code>: The full command line, including all arguments, used to invoke the process.</p>
</li>
<li><p><code>Environment</code>: A pointer to the process’ environment variables.</p>
</li>
</ul>
<p>The <code>_PEB_LDR_DATA</code> structure:</p>
<p><img alt="image-20200310181043016" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcozusn6ofj30n9053dgg.jpg" data-index="66" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcozusn6ofj30n9053dgg.jpg"></p>
<p>Key Points:</p>
<ul>
<li><p><code>InLoadOrderModuleList</code>: A linked list that organizes modules <strong>in the order in which they are loaded into a process</strong>. </p>
<blockquote>
<p>Because the <strong>process executable is always first to load in the process address space</strong>, its entry is first in this list. </p>
</blockquote>
</li>
<li><p><code>InMemoryOrderModuleList</code>: A linked list that organizes modules in the order in which they <strong>appear in the process’ virtual memory layout</strong>. </p>
<blockquote>
<p>For example, the last DLL to load may end up at a lower base address than the first (due to address space layout randomization [ASLR] and other factors). </p>
</blockquote>
</li>
<li><p><code>InInitializationOrderModuleList</code>: A linked list that organizes modules <strong>in the order in which their <code>DllMain</code> function was executed</strong>.</p>
<blockquote>
<p>This is different from the load order list because a module’s DllMain isn’t always called immediately when it loads. Sometimes it’s never called, for example when you load a DLL as a data file or image resource (see the <code>dwFlags</code> parameter to <code>LoadLibraryEx</code>).</p>
</blockquote>
</li>
</ul>
<p>The <code>_LDR_DATA_TABLE_ENTRY</code> structure:</p>
<p><img alt="image-20200310181813866" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcp02m453hj30np0980uc.jpg" data-index="67" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcp02m453hj30np0980uc.jpg"></p>
<p>Key Points:</p>
<ul>
<li><p><code>DllBase</code> : This is the base address of the module in process memory.</p>
</li>
<li><p><code>EntryPoint</code>: The first instruction executed by the module. In most cases, it is taken from the PE file’s <code>AddressOfEntryPoint</code> value.</p>
</li>
<li><p><code>SizeOfImage</code>: The size of the module, in bytes.</p>
</li>
<li><p><code>FullDllName</code>: The full path to the module’s file on disk (for example, <code>C:\Windows\ System32\kernel32.dll</code>).</p>
</li>
<li><p><code>BaseDllName</code> : The base portion of the module’s filename (for example, <code>kernel32.dll</code>).</p>
</li>
<li><p><code>LoadCount</code>: <strong>The number of times</strong> <code>LoadLibrary</code> was called for the module. <strong>It is used as a reference count to know when it is safe to unload a DLL from process memory</strong>. You’ll see this value later in the chapter to determine how a DLL was loaded (via the import address table [IAT] or an explicit call to LoadLibrary).</p>
</li>
</ul>
<h4 id="gt-gt-Process-Heap"><a href="#gt-gt-Process-Heap" class="headerlink" title="&gt;&gt; Process Heap"></a>&gt;&gt; Process Heap</h4><p>When you dump process memory via <code>memdump</code> or <code>vaddump</code>, you inevitably get the heap contents(at least the pages that are not swapped). However, you won’t necessarily know which offsets in your dump file or signature results correspond to heap regions.</p>
<p>But in some cases you might want to analyze only heap memory.</p>
<p><strong>Scenario:</strong></p>
<p>Suppose we are investigating some suspects’ notepad that is recorded something for crime as below:</p>
<p><img alt="image-20200310195417879" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcp2ukdyslj30og0ih11a.jpg" data-index="68" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcp2ukdyslj30og0ih11a.jpg"></p>
<p>We may obtain the memory dump from the suspects’system. Though we could use <code>vadinfo</code> or <code>vadtree</code> on the notepad process, we’ll see 50+ VAD tress and its hard to analyze. The goal is to obtain the texts by pressing keyboard and we only need to analyze the heap.</p>
<p>We can use <code>heaps</code> plugin to layout the heap:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f Win2K3SP1x86.vmem --profile=Win2003SP1x86 heaps -p 3988</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200310195057283" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcp2r38zxjj30o40jun0s.jpg" data-index="69" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcp2r38zxjj30o40jun0s.jpg"></p>
<blockquote>
<p>As shown, two chunks stood out because the “<code>extra</code>” flag is displayed. In other words, the <code>HEAP_ENTRY_EXTRA_PRESENT</code> flag was set in the <code>_HEAP_ENTRY.Flags</code> member for these two chunks.</p>
</blockquote>
<p>Regardless of the actual meaning of the <code>extra</code> flag, we got two chunks at <code>0xa8028</code> and <code>0xac7b0</code>.</p>
<p>We could access the memory by <code>volshell</code> below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f Win2K3SP1x86.vmem --profile=Win2003SP1x86 volshell -p 3988</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200310195925790" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcp2zwsgpoj30nr081q4j.jpg" data-index="70" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcp2zwsgpoj30nr081q4j.jpg"></p>
<h4 id="gt-gt-Environment-Variables"><a href="#gt-gt-Environment-Variables" class="headerlink" title="&gt;&gt; Environment Variables"></a>&gt;&gt; Environment Variables</h4><p>A process’ environment variables are pointed to by <code>_PEB.ProcessParameters.Environment</code>. The variables are organized as multiple NULL-terminated strings, similar to a <code>REG_MULTI_SZ</code> value in the registry.</p>
<blockquote>
<p>If an attacker manipulates these variables, they can cause the target application to unexpectedly execute a malicious process. Additionally, some malware marks its presence by creating environment variables rather than mutexes.</p>
</blockquote>
<p>Here are some scopes of environment variables:</p>
<p><img alt="image-20200310200449010" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcp35ifgnuj30oj063q3u.jpg" data-index="71" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcp35ifgnuj30oj063q3u.jpg"></p>
<p>The System and User variables are both persistent in the registry. Thus, you can enumerate them by parsing registry hive files that were acquired from disk.</p>
<blockquote>
<p>When a process is created, it usually inherits the environment block from its parent. The parent process can override this default behavior by specifying the <code>lpEnvironment</code> parameter when it calls <code>CreateProcess</code>.</p>
</blockquote>
<p>You can find these types of data in environment variables:</p>
<ul>
<li>Paths to executable programs (PATH) </li>
<li>Extensions assigned to executable programs (PATHEXT) </li>
<li>Paths to temporary directories </li>
<li>Paths to a user’s Documents, Internet History, and Application Data folders </li>
<li>User names, computer names, and domain names </li>
<li>The location of cmd.exe (ComSpec)</li>
</ul>
<h4 id="gt-gt-Attacks-on-Environment-variables"><a href="#gt-gt-Attacks-on-Environment-variables" class="headerlink" title="&gt;&gt; Attacks on Environment variables"></a>&gt;&gt; Attacks on Environment variables</h4><p>The two most common types of attacks on environment variables include changing the <code>PATH</code> and <code>PATHEXT</code> variables.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=C:\windows;C:\windows\system32 PATH=C:\Users\HR101\.tmp;C:\windows;C:\windows\system32</span><br></pre></td></tr></table></figure>
<p>An attacker could plant a file named calc.zzz in one of the searched directories, and it would be executed first:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE</span><br><span class="line">PATHEXT=.ZZZ;.COM;.EXE;.BAT;.CMD;.VBS;.VBE</span><br></pre></td></tr></table></figure>
<h4 id="gt-gt-Coreflood-Presence-Marking"><a href="#gt-gt-Coreflood-Presence-Marking" class="headerlink" title="&gt;&gt; Coreflood Presence Marking"></a>&gt;&gt; Coreflood Presence Marking</h4><p>Many malware samples mark their presence on a system by creating globally accessible mutexes. This helps prevent accidental re-infection. Mutexes also provide a strong forensic indicator. Coreflood used environment variables for a very similar purpose—to mark its presence within a process.</p>
<p><strong>Example:</strong></p>
<p>How many of the following processes are infected with Coreflood’s DLL?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f coreflood.img --profile=WinXPSP3x86 envars</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200310214200342" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcp5yo7ra2j30o80mojuz.jpg" data-index="72" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcp5yo7ra2j30o80mojuz.jpg"></p>
<p>Answer : 2</p>
<p>At first glance, it appears as if all four processes are infected, because they all contain suspicious variable names. </p>
<p>However, we previously mentioned that <strong>child processes typically inherit their parent’s variables</strong>. We also said <strong>the variable name depends on the PID of the process</strong>. <strong>If all four processes were infected, you’d see four unique variable names</strong>; but you see only two (VFTPXXPYVTAMF and QBYXKDAGXM). </p>
<p>The last three processes (IEXPLORE.EXE, notepad.exe, and firefox.exe) were spawned by PID 1144, which explains why they have a copy of the VFTPXXPYVTAMF variable.</p>
<h4 id="gt-gt-Standard-Handles"><a href="#gt-gt-Standard-Handles" class="headerlink" title="&gt;&gt; Standard Handles"></a>&gt;&gt; Standard Handles</h4><p>By analyzing a process’ standard handles, you can determine where it gets input and where it sends output and error messages.</p>
<p>This is especially useful when investigating potential breaches by <strong>remote attackers</strong>.</p>
<blockquote>
<p>A fairly common way to create a backdoor command shell on a system involves <strong>spawning an instance of <code>cmd.exe</code> and redirecting its standard handles over named pipes or network sockets</strong>. Thus, the attackers can use <code>telnet</code> or <code>netcat</code> to connect to the target machine (provided that no firewall is blocking access), and type commands as if they were sitting at the console.</p>
</blockquote>
<h4 id="gt-gt-Dynamic-Link-Libraries-DLLs"><a href="#gt-gt-Dynamic-Link-Libraries-DLLs" class="headerlink" title="&gt;&gt; Dynamic Link Libraries(DLLs)"></a>&gt;&gt; Dynamic Link Libraries(DLLs)</h4><p>DLLs contain code and resources that can be shared between multiple processes. They’re popular among malware and threat actors because DLLs are designed to run inside a host process, thus giving them access to all of the process’ resources: its threads, handles, and full range of process memory.</p>
<p><strong><em>How DLLs Are Loaded</em></strong></p>
<ul>
<li><code>Dynamic linking</code>: As part of the process initialization routines, any DLL in the executable (.exe) file’s IAT(import address table) automatically loads in the process’ address space.</li>
<li><p><code>Dependencies</code>: DLLs also have import tables, so when they’re loaded, all additional DLLs on which they rely load into the process’ address space. For more information, see Dependency Walker (<a href="http://www.dependencywalker.com/" target="_blank" rel="noopener">http://www.dependencywalker.com/</a>).</p>
</li>
<li><p><code>Run-time dynamic linking (RTDL)</code>: A thread can explicitly call <code>LoadLibrary</code> (or the native <code>LdrLoadDll</code>) with the name of the DLL to load. This has the same end result as dynamic linking (a DLL loaded in the process), except there’s no trace of the DLL in the process’ IAT.</p>
</li>
<li><p><code>Injections</code>: As you’ll learn later in the chapter, DLLs can also be forcefully injected into a target process.</p>
</li>
</ul>
<p><strong><em>Hiding DLLs</em></strong></p>
<p>all three lists exist in process memory, any thread running in the process can unlink a metadata structure ( <code>_LDR_DATA_TABLE_ENTRY</code>) to hide it from the running system (and potentially memory forensics as well). For example, once loaded, the xyz.dll module can overwrite its own Flink and Blink pointers so that its entry is skipped during enumeration.</p>
<p><img alt="image-20200310224506418" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcp7samwu0j30p20gmdhb.jpg" data-index="73" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcp7samwu0j30p20gmdhb.jpg"></p>
<p><strong><em>Listing DLLs in Memory</em></strong></p>
<p>We design <code>dlllist</code> plugin: enumerating DLLs by <strong>walking the load order list.</strong>  Thus The unlinking approach depicted in diagram above also affects Volatility’s dlllist plugin.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py –f mem.dmp --profile=WinXPSP3x86 dlllist –p 3108</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200310225126658" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcp7yvtzq4j30ny0gigph.jpg" data-index="74" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcp7yvtzq4j30ny0gigph.jpg"></p>
<blockquote>
<p>The process executable (<code>notepad.exe</code>) is first to load in the process address space, thus it’s first in the load order list. Next, the <code>ntdll.dll</code> and <code>kernel32.dll</code> system libraries are loaded. The system then proceeds to load any DLLs in Notepad’s IAT and any dependency modules that those DLLs need.</p>
</blockquote>
<p>However, that the load count for the first batch of modules is 0xffff. Because this field is a short integer, <strong>0xffff is actually -1</strong>. A load <strong>count of -1 means the DLL loaded because it was specified in an IAT</strong>. (The others near the end, whose load counts are 0x3, 0x27, 0x4 and 0x1, were all loaded via explicit calls to <code>LoadLibrary</code>)</p>
<p>Although there are plenty of legitimate reasons to call LoadLibrary, <strong>its usage is also consistent with the techniques shellcode uses to set up the target process’ address space</strong>. You may notice none of the explicitly loaded DLLs are suspicious per se—they’re all properly named and in the correct system32 path. </p>
<p>However, when you consider their purpose (network related) and the host process context (notepad.exe), the situation begins to look quite abnormal. Most likely code needing access to networking DLLs has infected this process, and it loads them by calling <code>LoadLibrary</code>.</p>
<p><strong><em>Detecting Unlinked DLLs</em></strong></p>
<p>Two methods can help you detect DLLs that are unlinked from all three lists:</p>
<ul>
<li><p><code>PE file scanning</code>: You can leverage techniques described in Chapter 7 to perform a brute force scan through process memory, <strong>looking for all instances of PE files (based on their known MZ header signatures)</strong>. </p>
<p>Remember, however, that the <strong>PE headers are also in process memory</strong>, so the same body of code that unlinks the DLL metadata structure can easily overwrite them.</p>
</li>
<li><p><code>VAD cross-referencing</code>: This is the technique implemented by Volatility’s <code>ldrmodules</code> plugin. If you recall from Chapter 7, <strong>VAD nodes contain full paths on disk to files mapped into the regions—including DLL files</strong>. </p>
<p>The unique aspect of VADs is that <strong>they exist in kernel memory</strong> and attempts to manipulate the tree (i.e., unlink a VAD node) or overwrite their file pointers quickly result in system instability (blue screens).</p>
</li>
</ul>
<p>We can use <code>ldrmodules</code> plugin</p>
<ul>
<li>First enumerates all VAD nodes that contain mapped executable images. Specifically, <strong>it looks for large nodes with <code>PAGE_EXECUTE_WRITECOPY</code> protections, a <code>VadImageMap</code> type, and the Image control flag set.</strong></li>
<li>It then compares <strong>the starting addresses from the VAD nodes</strong> with the <strong><code>DllBase</code> value from the <code>_LDR_DATA_TABLE_ENTRY</code> structures found in process memory</strong>. </li>
<li>Entries identified through the VAD that aren’t represented in the DLL lists are potentially hidden.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python vol.py -f memory.dmp --profile=Win7SP1x64 ldrmodules -p 616</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200310232557769" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcp8ysqshhj30o70djq6o.jpg" data-index="75" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcp8ysqshhj30o70djq6o.jpg"></p>
<h3 id="gt-PE-Files-in-Memory"><a href="#gt-PE-Files-in-Memory" class="headerlink" title="&gt; PE Files in Memory"></a>&gt; PE Files in Memory</h3><ul>
<li><p>Volatility can dump and rebuild PE files.</p>
</li>
<li><p><strong>Due to changes that occur during program execution, it’s hard for you to get an exact copy of the original binary or even one that runs on another machine.</strong></p>
</li>
</ul>
<p>Dumping an executable and compare its MD5 or SHA1 hash to the file on disk is also not likely possible.</p>
<p>Another reason why PE files dumped from memory often differ from the original file on disk is because of slack space:</p>
<p><strong><em>PE File Slack Space</em></strong></p>
<p>The smallest page size on a typical x86 or x64 Windows system is 4,096 bytes. Most PE files have sections that are not exact multiples of the smallest page size.</p>
<p><img alt="image-20200311010829443" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcpbxhgloaj30h20ay3zi.jpg" data-index="76" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcpbxhgloaj30h20ay3zi.jpg"></p>
<p>As the diagram above, the .text section, which is not an exact multiple of 4,096, must fully exist in memory marked as RX (read, execute), and the .data section must fully exist in memory marked as RW (read, write).</p>
<blockquote>
<p>Because <strong>protections are applied at the page level</strong> (in other words, if a page is marked as executable, all bytes in the page are executable)—-</p>
<p>That the two sections must <strong>be separated after being loaded into memory</strong>. Otherwise, the beginning of the .data section ends up being RX instead of RW.</p>
</blockquote>
<h4 id="gt-gt-Parsing-PE-Headers-in-Memory"><a href="#gt-gt-Parsing-PE-Headers-in-Memory" class="headerlink" title="&gt;&gt; Parsing PE Headers in Memory"></a>&gt;&gt; Parsing PE Headers in Memory</h4><p>It can be described as following steps:</p>
<ul>
<li>using volatility to attach the certain process and launch volshell</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f memory.dmp --profile=Win7SP1x64 volshell -p 516</span><br></pre></td></tr></table></figure>
<ul>
<li>get the <code>process.peb</code> and <code>ImageBaseAddress</code></li>
</ul>
<p>Let’s take a review, <code>ImageBaseAddress</code> in PEB is <strong>the address in process memory where the main executable (.exe) is loaded</strong>. Take a look at <code>ImageBaseAddress</code> below:</p>
<p><img alt="image-20200311095415129" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcpr4j5amgj30nx02fmxb.jpg" data-index="77" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcpr4j5amgj30nx02fmxb.jpg"></p>
<p>We can see <code>MZ(4d5a)</code> signature appears first.</p>
<ul>
<li>get <code>NT</code> header</li>
</ul>
<p>We could create an <code>_IMAGE_DOS_HEADER</code> at the base address we first got and use the <code>get_nt_header</code> function.</p>
<p><img alt="image-20200311100253259" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcprdirfx8j30o2083q46.jpg" data-index="78" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcprdirfx8j30o2083q46.jpg"></p>
<ul>
<li>then print sections in PE</li>
</ul>
<p><img alt="image-20200311100844130" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcprjm0fvvj30ny06jdgl.jpg" data-index="79" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcprjm0fvvj30ny06jdgl.jpg"></p>
<h4 id="gt-gt-PE-Extraction-Plugins"><a href="#gt-gt-PE-Extraction-Plugins" class="headerlink" title="&gt;&gt; PE Extraction Plugins"></a>&gt;&gt; PE Extraction Plugins</h4><p>We have shown in previous the whole process of extracting PE file to memory. Then there are some plugins that can automate the process:</p>
<ul>
<li><p><code>procdump</code>: Dump a process executable. You can identify the process by PID (<code>--pid</code>) or the physical offset of its <code>_EPROCESS</code> (<code>--offset</code>). </p>
<blockquote>
<p>The latter option enables you to dump processes hidden from the active process list.</p>
</blockquote>
</li>
<li><p><code>dlldump</code>: Dump a DLL. You can identify the host process by PID ( <code>--pid</code>) or the physical offset of its <code>_EPROCESS</code> (<code>--offset</code>). </p>
<blockquote>
<p>If the DLL(s) are in the load order list, you can identify them using a regular expression (<code>--regex/--ignore-case</code>) on their name. Otherwise, you can refer to them by their base address in process memory (<code>--base</code>). The latter option enables you to dump hidden or injected PE files. </p>
</blockquote>
</li>
<li><p><code>moddump</code>: <strong>Dump a kernel module</strong>. </p>
</li>
</ul>
<p>All the plugins require an output directory (<code>--dump-dir</code>) to write the extracted files.</p>
<p>They also all accept an optional <code>--memory</code> parameter, which is how you request the slack space between sections to be included in the output file.</p>
<p><strong>Examples:</strong></p>
<ul>
<li><code>procdump</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python vol.py -f memory.dmp --profile=Win7SP1x64 procdump --dump-dir=OUTDIR/</span><br></pre></td></tr></table></figure>
<p><img alt="image-20200311102633430" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcps251gtmj30nz07cmy9.jpg" data-index="80" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcps251gtmj30nz07cmy9.jpg"></p>
<blockquote>
<p>Notice the name of the output file is based on the PID of the process (<code>executable.PID.exe</code>).</p>
</blockquote>
<p>We can extract a process that’s not in the active process list based on the physical offset of its <code>_EPROCESS</code> <strong>(which you can get with psscan or psxview)</strong>:</p>
<p><img alt="image-20200311104526554" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcpslsm7c6j30o606a0ti.jpg" data-index="81" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcpslsm7c6j30o606a0ti.jpg"></p>
<ul>
<li><code>dlldump</code></li>
</ul>
<p>extract any DLL from PID 1408 that has a name or path matching “crypt” string:</p>
<p><img alt="image-20200311105130051" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcpss3ljovj30o408k75u.jpg" data-index="82" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcpss3ljovj30o408k75u.jpg"></p>
<blockquote>
<p>output files are named according to the PID and physical offset of the host process and the base virtual address of the DLL (module.PID. OFFSET.ADDRESS.dll)</p>
</blockquote>
<p>But to dump DLLs hidden or injected we should use <code>--base</code> the base address where the DOS header exists:</p>
<p><img alt="image-20200311105642004" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcpsxijalsj30o706j3zd.jpg" data-index="83" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcpsxijalsj30o706j3zd.jpg"></p>
<p><strong><em>Caveats</em></strong></p>
<p>One thing to note about these plugins is that they’re susceptible to attacks that manipulate PE header values. For example, <strong>if the MZ or PE signature isn’t found, they cannot properly locate the sections</strong>. Furthermore, they also rely on the advertised section virtual addresses and sizes, which malicious code can easily overwrite.</p>
<p>If you encounter issues dumping PE files from process memory, whether it’s the process executable or a DLL, you can always fall back to just dumping the containing VAD region.</p>
<h3 id="gt-Code-Injection"><a href="#gt-Code-Injection" class="headerlink" title="&gt; Code Injection"></a>&gt; Code Injection</h3><p>The way to detect code injection depends on how the code was injected.</p>
<ul>
<li><p><strong>Remote DLL injection</strong>: A malicious process forces the target process to load a specified DLL from disk by calling LoadLibrary or the native LdrLoadDll. By definition, the DLL must exist on disk prior to being injected.</p>
</li>
<li><p><strong>Remote code injection</strong>: A malicious process writes code into the memory space of a target process and forces it to execute. The code can be a block of shellcode (i.e., not a PE file) or it can be a PE file whose import table is preemptively configured for the target process.</p>
</li>
<li><p><strong>Reflective DLL injection</strong>: A malicious process writes a DLL (as a sequence of bytes) into the memory space of a target process. The DLL handles its own initialization without the help of the Windows loader. The DLL does not need to exist on disk prior to being injected.</p>
</li>
<li><p><strong>Hollow process injection</strong>: A malicious process starts a new instance of a legitimate process (such as lsass.exe) in suspended mode. Before resuming it, the executable section(s) are freed and reallocated with malicious code.</p>
</li>
</ul>
<p>In the following descriptions, <strong><em>Process A is the malicious process and Process B is the target.</em></strong></p>
<h4 id="gt-gt-Remote-DLL-Injection"><a href="#gt-gt-Remote-DLL-Injection" class="headerlink" title="&gt;&gt; Remote DLL Injection"></a>&gt;&gt; <em>Remote DLL Injection</em></h4><ol>
<li>ProcessA <strong>enables debug privilege</strong>(<code>SE_DEBUG_PRIVILEGE</code>) as if it were a debugger, so that it can read and write other process’ memory.</li>
<li>ProcessA calls <code>OpenProcess</code> and <strong>opens a handle to ProcessB</strong> (also request <code>PROCESS_CREATE_THREAD</code>, <code>PROCESS_VM_OPERATION</code>, and <code>PROCESS_VM_WRITE</code>)</li>
<li>ProcessA calls <code>VirtualAllocEx</code> to <strong>allocate memory in ProcessB</strong></li>
<li>ProcessA <strong>transfers a string(identifies the full path on disk to the malicious DLL)</strong> to ProcessB’s memory by calling <code>WriteProcessMemory</code>.(writing at the address allocated in previous step)</li>
<li>ProcessA calls <code>CreateRemoteThread</code> to <strong>start a new thread in ProcessB that executes the <code>LoadLibrary</code> function</strong>.</li>
<li>Now the injection is complete and processB has loaded the DLL. ProcessA calls <code>VirtualFree</code> to free the memory containing the DLL’s path.</li>
<li>ProcessA calls <code>CloseHandle</code> on ProcessB’s process to clean up.</li>
</ol>
<p><strong><em>Detection</em></strong></p>
<p><code>LoadLibrary</code> was used to load the DLL, there is no good way to conclusively distinguish between the malicious DLL and other explicitly loaded DLLs in ProcessB.</p>
<blockquote>
<p>The VAD and PEB lists look nearly identical from a metadata perspective for all modules loaded with the same API. </p>
<p><strong>In other words, the injected DLL isn’t necessarily hidden at this point</strong>; it is perfectly visible with <code>dlllist</code> or tools such as Process Explorer running on the live system. However, unless you know the specific name of the DLL, it can easily blend in with the legitimate modules.</p>
</blockquote>
<p>There are still two factors can make detection possible:</p>
<ul>
<li>If the injected DLL does attempt to hide from tools on the live system after it gets loaded (by unlinking its <code>_LDR_DATA_TABLE_ENTRY</code> from one or more of the ordered lists), you can use <code>ldrmodules</code> to detect it.</li>
<li>If the injected DLL is packed, and the unpacking procedure copies the decompressed code to a new memory region. In this case, you’ll detect it with <code>malfind</code> (described next).</li>
</ul>
<h4 id="gt-gt-Remote-Code-Injection"><a href="#gt-gt-Remote-Code-Injection" class="headerlink" title="&gt;&gt; Remote Code Injection"></a>&gt;&gt; <em>Remote Code Injection</em></h4><p>It starts out with the same two steps as remote DLL injection above.</p>
<ol>
<li>ProcessA <strong>allocates memory in ProcessB with <code>PAGE_EXECUTE_READWRITE</code> protection</strong>.(It can alloc ProcessA to write and ProcessB to read and execute it).</li>
<li>ProcessA <strong>transfer a block of code to ProcessB</strong> using <code>WriteProcessMemory</code>.</li>
<li>ProcessA calls <code>CreateRemoteThread</code> and points the thread’s starting address to a function within the code.</li>
</ol>
<p><strong><em>Detection</em></strong></p>
<p>We could use <code>malfind</code> plugin(it is designed to hunt down remote code injections).</p>
<p>The concept is:</p>
<ul>
<li>There will be a readable, writeable, and executable private memory region (that is, no file mapping) with all pages committed (we use a few variations of these criteria for detection). </li>
<li>The region will <strong>contain a PE header and/or valid CPU instructions</strong>.</li>
</ul>
<p><strong>Examples:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python vol.py –f stuxnet.mem --profile=WinXPSP3x86 malfind</span><br></pre></td></tr></table></figure>
<p><em>case1 - obvious injected code with MZ signature</em></p>
<p><img alt="image-20200311122718332" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcpvjs26njj30nx0dnwg5.jpg" data-index="84" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcpvjs26njj30nx0dnwg5.jpg"></p>
<blockquote>
<p>In some cases, you’ll leverage the hex dump to determine whether the region is malicious (for example, <strong>because you see an MZ signature</strong>); </p>
</blockquote>
<p>In other cases, you’ll need to rely on the disassembly(no <code>MZ</code> signature):</p>
<p>case2 - unconspicuous injected code without MZ signature*</p>
<p><img alt="image-20200311152041422" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcq0k6tf7sj30o40dtwh1.jpg" data-index="85" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcq0k6tf7sj30o40dtwh1.jpg"></p>
<blockquote>
<p>This region at 0x9d0000 is worth further investigation because the disassembly contains CPU instructions that make sense. For example, the <code>JMP</code> destinations are valid, and the combination of <code>MOV EDI, EDI</code> followed by <code>PUSH EBP</code> indicates the start of a function prologue.</p>
</blockquote>
<p><em>case3 - normal code similar to injected code</em></p>
<p>The following region in <code>csrss.exe</code> was not injected by malware, it was picked up by the plugin due to its similarity to injection regions:</p>
<p><img alt="image-20200311154500763" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcq19hzu1jj30o20bkabo.jpg" data-index="86" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcq19hzu1jj30o20bkabo.jpg"></p>
<p>Keep in mind that programs may allocate executable private memory for legitimate reasons.</p>
<blockquote>
<p>For example, there’s an <code>ENTER</code> instruction, but no <code>LEAVE</code>. There’s conditional jump (<code>JNO</code>), but no condition. Furthermore, the destination of the jump leads to 0x7f6f0007, an address that does not contain an instruction according to the current alignment.</p>
<p>It is just meaningless.</p>
</blockquote>
<p><em>case4 - hidden injected code with coreflood</em></p>
<p><img alt="image-20200311155332478" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcq1idd58pj30o00csabu.jpg" data-index="87" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcq1idd58pj30o00csabu.jpg"></p>
<p>Most analysts assume that this range at 0x7ff80000 is a false positive. The hex dump and disassembly both consist of only zeros. (<strong>In this case, Coreflood’s antidumping feature wiped out its PE header (which occupied the first page) by overwriting it with zeros)</strong>.</p>
<p> However, remember that this is only a preview of the data. <strong>The CPU doesn’t necessarily start executing code at offset 0 in the injected region; it can easily point somewhere within the range.</strong></p>
<p>Use <code>volshell</code> to disassemble code in the seconde page we could see the main function:</p>
<p><img alt="image-20200311155607867" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcq1l279lfj30o70bjgnn.jpg" data-index="88" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcq1l279lfj30o70bjgnn.jpg"></p>
<h4 id="gt-gt-Reflective-DLL-Injection"><a href="#gt-gt-Reflective-DLL-Injection" class="headerlink" title="&gt;&gt; Reflective DLL Injection"></a>&gt;&gt; <em>Reflective DLL Injection</em></h4><p>This method is a hybrid of the two approaches discussed previously. </p>
<p>The content transferred from Process A to Process B is a DLL (as opposed to a block of shellcode), but after it exists in Process B, it initializes itself instead of calling <code>LoadLibrary</code>.</p>
<p>It has several anti-forensics advantages:</p>
<ul>
<li><p><code>LoadLibrary</code> only loads libraries from disk. <strong>Because this method doesn’t rely on the API, the injected DLL never needs to be written to more permanent storage</strong>. It can be loaded into memory straight from the network (for example, when exploiting a remote buffer overflow).</p>
</li>
<li><p>Also as a result of avoiding <code>LoadLibrary</code>, <strong>the <code>_LDR_DATA_TABLE_ENTRY</code> metadata structures are not created</strong>. Thus the <strong>three lists in the PEB do not have a record of this DLL</strong> loading.</p>
</li>
</ul>
<p><strong><em>Detection</em></strong></p>
<p>First take a look at an example(a snippet of code) of Reflection DLL Injection project’s <code>LoadLibraryR.c</code> file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// alloc memory (RWX) in the host process for the image... </span><br><span class="line">lpRemoteLibraryBuffer = VirtualAllocEx( hProcess, NULL, dwLength,</span><br><span class="line">                           MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); </span><br><span class="line">if(!lpRemoteLibraryBuffer) </span><br><span class="line">   break;</span><br></pre></td></tr></table></figure>
<p>Due to the options chosen during allocation, the VAD in the host process that contains the DLL fits the criteria for <code>malfind</code>.</p>
<p>So we can use <code>malfind</code>.</p>
<h4 id="gt-gt-Hollow-Process-Injection"><a href="#gt-gt-Hollow-Process-Injection" class="headerlink" title="&gt;&gt; Hollow Process Injection"></a>&gt;&gt; <em>Hollow Process Injection</em></h4><p>The malware starts a new instance of a legitimate process, such as lsass.exe. Before the process’ first thread begins, the malware frees the memory containing the lsass.exe code (it hollows it out) and replaces it with the body of the malware.</p>
<p><img alt="image-20200311161409689" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcq23twd95j30oj0d0wfr.jpg" data-index="89" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcq23twd95j30oj0d0wfr.jpg"></p>
<blockquote>
<p>PEB and various other data structures identify the path to the legitimate lsass.exe binary.(unchanged)</p>
</blockquote>
<p><strong><em>Hollow a process</em></strong></p>
<ol>
<li><p>Start a new instance of a legitimate process (for example, C:\windows\system32\lsass.exe), but with its first thread suspended. </p>
<blockquote>
<p>At this point, the <code>ImagePathName</code> in the PEB of the new process identifies the full path to the legitimate lsass.exe.</p>
</blockquote>
</li>
<li><p><strong>Acquire the contents for the malicious replacement code</strong>. This content can come from a file on disk, an existing buffer in memory, or over the network.</p>
</li>
<li><p>Determine the base address (ImageBase) of the lsass.exe process, and then <strong>free or unmap the containing memory section</strong>. </p>
<blockquote>
<p>At this point, the process is just an empty container (the DLLs, heaps, stacks, and open handles are still intact, but no process executable exists).</p>
</blockquote>
</li>
<li><p>Allocate a new memory segment in lsass.exe and make sure that the memory can be read, written, and executed. </p>
<blockquote>
<p>You can reuse the same <code>ImageBase</code> or a different one</p>
</blockquote>
</li>
<li><p>Copy the PE header for the malicious process into the newly allocated memory in lsass.exe</p>
</li>
<li><p>Copy each PE section for the malicious process into the proper virtual address in lsass.exe</p>
</li>
<li><p>Set the start address for the first thread (the one that has been in a suspended state) to point at the malicious process’ AddressOfEntryPoint value.</p>
</li>
<li><p>Resume the thread.</p>
<blockquote>
<p>The malicious process begins executing within the container created for lsass.exe. The ImagePathName in the PEB still points to C:\windows\system32\lsass.exe.</p>
</blockquote>
</li>
</ol>
<p><strong><em>Detection</em></strong></p>
<p>First we can list all processes using <code>pslist</code>:</p>
<p><img alt="image-20200311165645526" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcq3c5jf4vj30oc05b758.jpg" data-index="90" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcq3c5jf4vj30oc05b758.jpg"></p>
<blockquote>
<p>There are three processes (PID 680, 868, and 1928), but only one is the “real” lsass.exe. Intuition may tell you that the one that <strong>started first based on creation time (PID 680) is the legitimate one</strong>, but we’ll show you how to confirm.</p>
</blockquote>
<p>Now we can see <code>ImageBase</code> by <code>dlllist</code> for the processes:</p>
<p><img alt="image-20200311165841601" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcq3e5shgaj30o40a1myy.jpg" data-index="91" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcq3e5shgaj30o40a1myy.jpg"></p>
<blockquote>
<p>The advertised paths are all the same (despite two having an extra set of quotes around the path) because the data in the PEB, including the <code>ImageBase</code>, is initialized at process creation, and all processes started out the same.</p>
</blockquote>
<p>However, as a result of being hollowed, the VAD characteristics for the region that contains the ImageBase are drastically different:</p>
<p><img alt="image-20200311165948460" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcq3fb9za5j30o00hi77u.jpg" data-index="92" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcq3fb9za5j30o00hi77u.jpg"></p>
<p><img alt="image-20200311165956271" class="post-img b-lazy" data-img="https://tva1.sinaimg.cn/large/00831rSTly1gcq3fgk8bej30nz0b2dhu.jpg" data-index="93" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcq3fgk8bej30nz0b2dhu.jpg"></p>
<blockquote>
<p>Only the legitimate one (PID 680) still has a copy of the lsass.exe file mapped into the region</p>
</blockquote>

                </article>
                <ul class="tags-postTags">
                    
                    <li>
                        <a href="/tags/memory-forensics/" rel="tag"># memory forensics</a>
                    </li>
                    
                    <li>
                        <a href="/tags/notes/" rel="tag"># notes</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </div>

    
    <nav id="gobottom" class="pagination">
        
        <a class="prev-post" title="Processes, Handles, and Tokens" href="/2020/03/08/memfor-6/">
            ← Processes, Handles, and Tokens
        </a>
        
        <span class="prev-next-post">·</span>
        
        <a class="next-post" title="手把手带你MIT6.828 - Lab2" href="/2020/03/04/joslab2/">
            手把手带你MIT6.828 - Lab2 →
        </a>
        
    </nav>

    
    <div class="inner">
        <div id="comment"></div>
    </div>
    
</div>

<div class="toc-bar">
    <div class="toc-btn-bar">
        <a href="#site-main" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M793.024 710.272a32 32 0 1 0 45.952-44.544l-310.304-320a32 32 0 0 0-46.4 0.48l-297.696 320a32 32 0 0 0 46.848 43.584l274.752-295.328 286.848 295.808z"/></svg>
        </a>
        <div class="toc-btn toc-switch">
            <svg class="toc-open" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M779.776 480h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M779.776 672h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M256 288a32 32 0 1 0 0 64 32 32 0 0 0 0-64M392.576 352h387.2a32 32 0 0 0 0-64h-387.2a32 32 0 0 0 0 64M256 480a32 32 0 1 0 0 64 32 32 0 0 0 0-64M256 672a32 32 0 1 0 0 64 32 32 0 0 0 0-64"/></svg>
            <svg class="toc-close hide" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 960c-247.039484 0-448-200.960516-448-448S264.960516 64 512 64 960 264.960516 960 512 759.039484 960 512 960zM512 128.287273c-211.584464 0-383.712727 172.128262-383.712727 383.712727 0 211.551781 172.128262 383.712727 383.712727 383.712727 211.551781 0 383.712727-172.159226 383.712727-383.712727C895.712727 300.415536 723.551781 128.287273 512 128.287273z"/><path d="M557.05545 513.376159l138.367639-136.864185c12.576374-12.416396 12.672705-32.671738 0.25631-45.248112s-32.704421-12.672705-45.248112-0.25631l-138.560301 137.024163-136.447897-136.864185c-12.512727-12.512727-32.735385-12.576374-45.248112-0.063647-12.512727 12.480043-12.54369 32.735385-0.063647 45.248112l136.255235 136.671523-137.376804 135.904314c-12.576374 12.447359-12.672705 32.671738-0.25631 45.248112 6.271845 6.335493 14.496116 9.504099 22.751351 9.504099 8.12794 0 16.25588-3.103239 22.496761-9.247789l137.567746-136.064292 138.687596 139.136568c6.240882 6.271845 14.432469 9.407768 22.65674 9.407768 8.191587 0 16.352211-3.135923 22.591372-9.34412 12.512727-12.480043 12.54369-32.704421 0.063647-45.248112L557.05545 513.376159z"/></svg>
        </div>
        <a href="#gobottom" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M231.424 346.208a32 32 0 0 0-46.848 43.584l297.696 320a32 32 0 0 0 46.4 0.48l310.304-320a32 32 0 1 0-45.952-44.544l-286.848 295.808-274.752-295.36z"/></svg>
        </a>
    </div>
    <div class="toc-main">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Memory-Forensics"><span class="toc-text">Memory Forensics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Knowledge"><span class="toc-text">Basic Knowledge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatility"><span class="toc-text">Volatility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#selecting-a-profile"><span class="toc-text">selecting a profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell"><span class="toc-text">shell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Dump-Formats"><span class="toc-text">Memory Dump Formats</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Raw-Memory-Dump"><span class="toc-text">&gt; Raw Memory Dump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Windows-Crash-Dump"><span class="toc-text">&gt; Windows Crash Dump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Windows-Hibernation-File"><span class="toc-text">&gt; Windows Hibernation File</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Virtual-Machine-Memory"><span class="toc-text">&gt; Virtual Machine Memory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Windows-Objects-and-Pool-Allocations"><span class="toc-text">5 Windows Objects and Pool Allocations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Windows-Executive-Objects"><span class="toc-text">&gt; Windows Executive Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Object-Headers"><span class="toc-text">&gt;&gt; Object Headers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Optional-Headers"><span class="toc-text">&gt;&gt; Optional Headers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Object-Type-Objects"><span class="toc-text">&gt;&gt; Object Type Objects</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Kernel-Pool-Allocations"><span class="toc-text">&gt; Kernel Pool Allocations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Allocation-APIs"><span class="toc-text">&gt;&gt; Allocation APIs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-De-allocation-and-Reuse"><span class="toc-text">&gt;&gt; De-allocation and Reuse</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Pool-Tag-Scanning"><span class="toc-text">&gt; Pool-Tag Scanning</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Pool-Tag-Sources"><span class="toc-text">&gt;&gt; Pool Tag Sources</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Pooltag-file"><span class="toc-text">&gt;&gt; Pooltag file</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-PoolMon-Utility"><span class="toc-text">&gt;&gt; PoolMon Utility</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Pool-Tracker-Tables"><span class="toc-text">&gt;&gt; Pool Tracker Tables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Pool-Scanner-Algorighm"><span class="toc-text">&gt;&gt; Pool Scanner Algorighm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Finding-Terminated-Processes"><span class="toc-text">&gt;&gt; Finding Terminated Processes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Limitations-of-Pool-Scanning"><span class="toc-text">&gt;&gt; Limitations of Pool Scanning</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Big-Page-Pool"><span class="toc-text">&gt; Big Page Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Big-Page-Track-Tables"><span class="toc-text">&gt; Big Page Track Tables</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Exploring-Big-Page-Pools"><span class="toc-text">&gt;&gt; Exploring Big Page Pools</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Processes-Handles-and-Tokens"><span class="toc-text">6 Processes, Handles, and Tokens</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Processes"><span class="toc-text">&gt; Processes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Data-Structures"><span class="toc-text">&gt;&gt; Data Structures</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Process-Organization"><span class="toc-text">&gt;&gt; Process Organization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Critical-System-Processes"><span class="toc-text">&gt;&gt; Critical System Processes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Analyzing-Process-Activity"><span class="toc-text">&gt;&gt; Analyzing Process Activity*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Process-Tree-Visualizations"><span class="toc-text">&gt;&gt; Process Tree Visualizations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Detecting-DKOM-Attacks"><span class="toc-text">&gt;&gt; Detecting DKOM Attacks</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Process-Tokens"><span class="toc-text">&gt; Process Tokens</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Data-Structures-1"><span class="toc-text">&gt;&gt; Data Structures</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Accessing-Tokens"><span class="toc-text">&gt;&gt; Accessing Tokens</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Extracting-and-Translating-SIDs-in-Memory"><span class="toc-text">&gt;&gt; Extracting and Translating SIDs in Memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Detecting-Lateral-Movement"><span class="toc-text">&gt;&gt; Detecting Lateral Movement</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Privileges"><span class="toc-text">&gt; Privileges</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Analyzing-Explicit-Privileges"><span class="toc-text">&gt;&gt; Analyzing Explicit Privileges</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Process-Handles"><span class="toc-text">&gt; Process Handles</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Lifetime-of-a-Handle"><span class="toc-text">&gt;&gt; Lifetime of a Handle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Reference-Counts-and-Kernel-Handles"><span class="toc-text">&gt;&gt; Reference Counts and Kernel Handles</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Handle-Table-Internals"><span class="toc-text">&gt;&gt; Handle Table Internals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Data-Structures-2"><span class="toc-text">&gt;&gt; Data Structures</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Enumerating-Handles-in-Memory"><span class="toc-text">&gt; Enumerating Handles in Memory*</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Detecting-Registry-Persistence"><span class="toc-text">&gt;&gt; Detecting Registry Persistence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Identifying-Remote-Mapped-Drives"><span class="toc-text">&gt;&gt; Identifying Remote Mapped Drives</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Process-Memory-Internals"><span class="toc-text">7 Process Memory Internals</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-What’s-in-Process-Memory"><span class="toc-text">&gt; What’s in Process Memory?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Allocation-APIs"><span class="toc-text">Memory Allocation APIs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Enumerating-Process-Memory"><span class="toc-text">&gt; Enumerating Process Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Process-Page-Tables"><span class="toc-text">&gt;&gt; Process Page Tables</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Virtual-Address-Descriptors"><span class="toc-text">&gt; Virtual Address Descriptors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-VAD-Structures"><span class="toc-text">&gt;&gt; VAD Structures</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-VAD-Tags"><span class="toc-text">&gt;&gt; VAD Tags</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-VAD-Flags"><span class="toc-text">&gt;&gt; VAD Flags</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-CommitCharge"><span class="toc-text">&gt;&gt; CommitCharge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Protection"><span class="toc-text">&gt;&gt; Protection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Private-Memory"><span class="toc-text">&gt;&gt; Private Memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Volatility-VAD-Plugins"><span class="toc-text">&gt;&gt; Volatility VAD Plugins</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Hunting-Malware-in-Process-Memory"><span class="toc-text">8 Hunting Malware in Process Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Process-Environment-Block-PEB"><span class="toc-text">&gt; Process Environment Block(PEB)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Data-Structures-3"><span class="toc-text">&gt;&gt; Data Structures</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Process-Heap"><span class="toc-text">&gt;&gt; Process Heap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Environment-Variables"><span class="toc-text">&gt;&gt; Environment Variables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Attacks-on-Environment-variables"><span class="toc-text">&gt;&gt; Attacks on Environment variables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Coreflood-Presence-Marking"><span class="toc-text">&gt;&gt; Coreflood Presence Marking</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Standard-Handles"><span class="toc-text">&gt;&gt; Standard Handles</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Dynamic-Link-Libraries-DLLs"><span class="toc-text">&gt;&gt; Dynamic Link Libraries(DLLs)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-PE-Files-in-Memory"><span class="toc-text">&gt; PE Files in Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Parsing-PE-Headers-in-Memory"><span class="toc-text">&gt;&gt; Parsing PE Headers in Memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-PE-Extraction-Plugins"><span class="toc-text">&gt;&gt; PE Extraction Plugins</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gt-Code-Injection"><span class="toc-text">&gt; Code Injection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Remote-DLL-Injection"><span class="toc-text">&gt;&gt; Remote DLL Injection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Remote-Code-Injection"><span class="toc-text">&gt;&gt; Remote Code Injection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Reflective-DLL-Injection"><span class="toc-text">&gt;&gt; Reflective DLL Injection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-gt-Hollow-Process-Injection"><span class="toc-text">&gt;&gt; Hollow Process Injection</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>




	</div>
	


<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            

<article class="read-next-card" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfvz62ikmj30u0140kjl.jpg)">
  <header class="read-next-card-header">
    <small class="read-next-card-header-sitetitle">&mdash; Icegrave &mdash;</small>
    <h3 class="read-next-card-header-title">Recent Posts</h3>
  </header>
  <div class="read-next-divider">
    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
      <path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/>
    </svg>
  </div>
  <div class="read-next-card-content">
    <ul>
      
      
      
      <li>
        <a href="/2020/03/19/joslab4/">手把手带你MIT6.828 - Lab4</a>
      </li>
      
      
      
      <li>
        <a href="/2020/03/10/memfor-8/">Hunting Malware in Process Memory</a>
      </li>
      
      
      
      <li>
        <a href="/2020/03/10/joslab3/">手把手带你MIT6.828 - Lab3</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </ul>
  </div>
  <footer class="read-next-card-footer">
    <a href="/archives">  MORE  → </a>
  </footer>
</article>

            
            
            

<article class="read-next-card" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfvz62ikmj30u0140kjl.jpg)">
    <header class="read-next-card-header tagcloud-card">
        <h3 class="read-next-card-header-title">Categories</h3>
    </header>
    <div class="read-next-card-content">
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memory-forensics/">memory forensics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/operating-system/">operating system</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/图形学基础/">图形学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li></ul>
    </div>
</article>


            
            
            

<article class="read-next-card" style="background-image: url(https://tva1.sinaimg.cn/large/00831rSTly1gcfvz62ikmj30u0140kjl.jpg)">
	<header class="read-next-card-header tagcloud-card">
		<h3 class="read-next-card-header-title">Tag Cloud</h3>
	</header>
	<div class="read-next-card-content-ext">
		<a href="/tags/Fundamentals-of-Computer-Graphics/" style="font-size: 14px;">Fundamentals of Computer Graphics</a> <a href="/tags/iOS/" style="font-size: 14px;">iOS</a> <a href="/tags/iosre/" style="font-size: 14px;">iosre</a> <a href="/tags/lab/" style="font-size: 24px;">lab</a> <a href="/tags/memory-forensics/" style="font-size: 24px;">memory forensics</a> <a href="/tags/notes/" style="font-size: 24px;">notes</a> <a href="/tags/operating-system/" style="font-size: 24px;">operating system</a> <a href="/tags/工具/" style="font-size: 19px;">工具</a> <a href="/tags/随笔/" style="font-size: 14px;">随笔</a>
	</div>
</article>

            
        </div>
    </div>
</aside>

	




<div id="search" class="search-overlay">
    <div class="search-form">
        
        <div class="search-overlay-logo">
        	<img src="https://mubai.oss-cn-hangzhou.aliyuncs.com/icon.png" alt="Icegrave">
        </div>
        
        <input id="local-search-input" class="search-input" type="text" name="search" placeholder="Search ...">
        <a class="search-overlay-close" href="#"></a>
    </div>
    <div id="local-search-result"></div>
</div>

<footer class="site-footer outer">
	<div class="site-footer-content inner">
		<div class="copyright">
			<a href="/" title="Icegrave">Icegrave &copy; 2020</a>
			
				
			        <span hidden="true" id="/2020/03/07/memfor/" class="leancloud-visitors" data-flag-title>
			            <span>阅读量 </span>
			            <span class="leancloud-visitors-count">0</span>
			        </span>
	    		
    		
		</div>
		<nav class="site-footer-nav">
			
			<a href="https://hexo.io" title="Hexo" target="_blank" rel="noopener">Hexo</a>
			<a href="https://github.com/xzhih/hexo-theme-casper" title="Casper" target="_blank" rel="noopener">Casper</a>
		</nav>
	</div>
</footer>
	


<script>
    if(window.navigator && navigator.serviceWorker) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for(let registration of registrations) {
                registration.unregister()
            }
        })
    }
</script>


<script id="scriptLoad" src="/js/allinone.min.js" async></script>


<script>
    document.getElementById('scriptLoad').addEventListener('load', function () {
        
        
            var bLazy = new Blazy();
        

        
        

        
        
        
            searchFunc("/");
        
        
    })
</script>



<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>




<script id="valineScript" src="//unpkg.com/valine/dist/Valine.min.js" async></script>
<script>
    document.getElementById('valineScript').addEventListener("load", function() {
        new Valine({
            el: '#comment' ,
            verify: false,
            notify: false,
            appId: 'PlliSVE5ISCj7XAYOowLuJDX-gzGzoHsz',
            appKey: 'CoE3u0Y1coO3kv6nHDpSuj4L',
            placeholder: 'nil',
            pageSize: 10,
            avatar: 'mm',
            visitor: true
        })
    });
</script>





</body>
</html>
