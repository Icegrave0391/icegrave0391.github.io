[{"title":"手把手带你MIT6.828 - Lab2","url":"/2020/03/04/lab2/","content":"\n# Lab2 Memory Management\n\n官方文档: [lectures](https://pdos.csail.mit.edu/6.828/2018/lec/)\n\n### > 实验介绍\n\n在本次实验中，我们将为操作系统编写内存管理代码。内存管理包括两个组件：\n\n1. 第一个是内核的物理内存分配器，它可以使内核分配并释放内存。我们的分配器以4096Bytes为单位进行操作，该单位称为页面（Page）。\n\n我们将维护一个数据结构，这个数据结构能够记录哪些物理pages是空闲的，哪些是已经分配的，以及多少个进程正在共享每个分配的页。同时我们需要编写程序来分配和释放内存页面。\n\n2. 第二个组件是虚拟内存(virtual memory)。它将内核与用户软件使用的虚拟内存映射到物理内存中的地址。当指令使用内存时，x86硬件的内存管理单元(MMU)执行这个映射过程。\n\n我们将根据规范来修改jos以设置MMU的页表。\n\n\n\n### > 实验准备\n\n根据官方网站的提示，将lab2分支进行merge，合并到lab1中。\n\n实验二包括如下的新文件：\n\n- inc/memlayout.h 描述了虚拟地址空间的结构\n- kern/pmap.c 需要修改、添加代码以完成实验\n- kern/pmap.h 定义了PageInfo结构 用来管理物理页状态\n- kern/kclock.h\n- kern/kclock.c 操作电池供电的时钟以及CMOS RAM硬件\n\n个人建议在实验之前再次对段/页式管理有所了解（附上链接）：\n\n80386内存的基本概念和方式：[Memory Organization](https://pdos.csail.mit.edu/6.828/2018/readings/i386/s02_01.htm)\n\n这个章节中包含了段/页式管理，详细阅读：[Memory Management](https://pdos.csail.mit.edu/6.828/2018/readings/i386/c05.htm)\n\n\n\n## Part1: Physical Page Management\n\n操作系统必须追踪物理内存从而知晓哪些内存是空闲的，哪些内存是正在使用的。JOS使用页面粒度(page granularity)管理PC的物理内存，以便利用MMU映射和保护每一片被分配的内存。\n\n首先我们**需要实现一个物理内存分配器**(physical page allocator)。它将根据`struct PageInfo`链表进行空闲页面的追踪。\n\n注意：**我们必须先实现物理页分配器**，然后才能编写其余的虚拟内存实现。因为我们的页表管理代码将需要**分配用于储存页表的物理内存**。\n\n在继续之前，我们仍然需要一些背景知识，这可能仍然有些painful...\n\n### > bootloader读入kernel后的内存分布\n\n![image-20200304125040479](https://tva1.sinaimg.cn/large/00831rSTly1gchsvxxlc1j30j505qmy1.jpg)\n\n上图的代码是kernel刚刚被读入内存，还没有开启保护方式的结构。\n\n#### >> 回顾Lab1\n\n通过lab1，我们知道了，jos启动的过程实际上就是把bootsector的内容读到了0x7c00的位置（注意：bootsector的代码在编译的时候已经故意将逻辑地址的首地址定在了0x7c00上），bootsector中的代码开始执行的时候会从磁盘上紧接着自己的第二个扇区开始一直读8个扇区(一共8x512 = 4K，ELF头的大小)一直到0x10000(64KB)的地方，然后通过对ELF头的解析，得到kernel模块编译出来之后占的大小，并将kernel读到物理内存0x100000(1MB)的地方。然后设置好GDT并且调用`i386_init()`函数，而`i386_init()`函数将在自己的BSS区域清零后，调用`cons_init()`函数设置好屏幕显示设备为cprintf的运行做好准备。\n\n之后就会调用`i386_detect_memory()`函数和`i386_vm_init()`函数。前者的主要功能是读CMOS取得物理内存的实际大小，后者是本次lab的主要函数，将在之后进行讨论。当然`i386_init()`最后会调用`monitor(NULL)`，进入循环处理用户终端的交互。\n\n调用`i386_init()`之后，系统将会重载GDT，新的GDT：\n\n![image-20200304144728023](https://tva1.sinaimg.cn/large/00831rSTly1gchw9gn2sdj30h002i0sy.jpg)\n\n**新的GDT后两项的base是-KERNBASE**。如果KERNBASE=0xf0000000，则GDT的base为0x00100000，通过保护模式的段式地址转换机制(pa = la+base)，将程序内的KERNBASE开始的逻辑地址转换成物理地址。\n\n### > JOS分段和分页\n\n同时我们需要知道JOS是如何使用分段和分页的：[How we will use paging (and segments) in JOS](https://pdos.csail.mit.edu/6.828/2018/lec/l-josmem.html\n\n虚拟内存是将很小的物理内存映射到很大的虚拟内存空间，这个映射关系需要一个输入地址和一个输出地址才能作用。**物理地址**是物理内存中真实的地址，可以直接由硬件寻址得到；**虚拟地址/线性地址**是物理地址通过转换得到的，用于虚拟内存空间索引的地址。\n\n![image-20200304125540629](https://tva1.sinaimg.cn/large/00831rSTly1gcht15732bj30hk0cl0st.jpg)\n\n`mmu.h`对我们线性地址的结构有了详细的描述：\n\n```c\n// A linear address 'la' has a three-part structure as follows:\n//\n// +--------10------+-------10-------+---------12----------+\n// | Page Directory |   Page Table   | Offset within Page  |\n// |      Index     |      Index     |                     |\n// +----------------+----------------+---------------------+\n//  \\--- PDX(la) --/ \\--- PTX(la) --/ \\---- PGOFF(la) ----/\n//  \\---------- PGNUM(la) ----------/\n//\n// The PDX, PTX, PGOFF, and PGNUM macros decompose linear addresses as shown.\n// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),\n// use PGADDR(PDX(la), PTX(la), PGOFF(la)).\n```\n\n我们的线性地址分为三段：\n\n- `Page directory index`：页目录的序号(10位) -> 2^10个页表\n- `Page table index`：页表的序号(10位) -> 2^10页\n- `Page offset`：地址在页内的偏移(12位) -> 2^12 = 4K\n\n也就是说，每个页表有1024个页，每个页目录有1024个页表，每一页的大小是4KB。\n\n`memlayout.h`中可以看整个虚拟内存空间的分配：\n\n```c\n/*\n * Virtual memory map:                                Permissions\n *                                                    kernel/user\n *\n *    4 Gig -------->  +------------------------------+\n *                     |                              | RW/--\n *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *                     :              .               :\n *                     :              .               :\n *                     :              .               :\n *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--\n *                     |                              | RW/--\n *                     |   Remapped Physical Memory   | RW/--\n *                     |                              | RW/--\n *    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+\n *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |\n *                     | - - - - - - - - - - - - - - -|                   |\n *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |\n *                     +------------------------------+                   |\n *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |\n *                     | - - - - - - - - - - - - - - -|                 PTSIZE\n *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |\n *                     +------------------------------+                   |\n *                     :              .               :                   |\n *                     :              .               :                   |\n *    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+\n *                     |       Memory-mapped I/O      | RW/--  PTSIZE\n * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000\n *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE\n *    UVPT      ---->  +------------------------------+ 0xef400000\n *                     |          RO PAGES            | R-/R-  PTSIZE\n *    UPAGES    ---->  +------------------------------+ 0xef000000\n *                     |           RO ENVS            | R-/R-  PTSIZE\n * UTOP,UENVS ------>  +------------------------------+ 0xeec00000\n * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE\n *                     +------------------------------+ 0xeebff000\n *                     |       Empty Memory (*)       | --/--  PGSIZE\n *    USTACKTOP  --->  +------------------------------+ 0xeebfe000\n *                     |      Normal User Stack       | RW/RW  PGSIZE\n *                     +------------------------------+ 0xeebfd000\n *                     |                              |\n *                     |                              |\n *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *                     .                              .\n *                     .                              .\n *                     .                              .\n *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n *                     |     Program Data & Heap      |\n *    UTEXT -------->  +------------------------------+ 0x00800000\n *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE\n *                     |                              |\n *    UTEMP -------->  +------------------------------+ 0x00400000      --+\n *                     |       Empty Memory (*)       |                   |\n *                     | - - - - - - - - - - - - - - -|                   |\n *                     |  User STAB Data (optional)   |                 PTSIZE\n *    USTABDATA ---->  +------------------------------+ 0x00200000        |\n *                     |       Empty Memory (*)       |                   |\n *    0 ------------>  +------------------------------+                 --+\n *\n * (*) Note: The kernel ensures that \"Invalid Memory\" is *never* mapped.\n *     \"Empty Memory\" is normally unmapped, but user programs may map pages\n *     there if desired.  JOS user programs map pages temporarily at UTEMP.\n */\n```\n\n- `0xf0000000`以上：`Remapped physical memory`，物理内存的原样映射，这一部分为虚拟地址\n- `0xefc00000`以上：内核栈区域，存放各个CPU的内核栈。\n  - `0xef800000`：`ULIM`，内核内存区和用户内存区的分界线，这以上用户不可读写\n- `0xef400000`以上：页表区域\n  - `0xef400000`：`UVPT`，页表区域的开始。\n- `0xef000000`以上：页区域\n  - `0xef000000`：`UPAGES`，页区域的开始。\n- `0xeec00000`以上：当前进程的环境变量区域\n  - `0xeec00000`：`UTOP`，用户只读区和读写区的分界线，这以上到`ULIM`之间用户只有读权限\n- ``0xeebff000 1 PGSIZE`：用户的异常栈\n- `0xeebfe000 一段留空内存`\n- `0xeebfd000 1 PGSIZE`：用户栈，可以增长\n- `0x00800000`以上：用户的堆区域和程序数据\n- 以下：用户的符号表区域和空内存\n\n**exercise 1:**\n\n我们需要实现`kern/pmap.c`中的以下函数：\n\n```c\nboot_alloc()\nmem_init()   //（完成直到调用check_page_free_list(1)为止）\npage_init()\npage_alloc()\npage_free()\n```\n\n完成后，我们可以在boot jos的过程中使用`check_page_free_list()`以及`check_page_alloc()`来检查我们的物理内存分配器。\n\ntips：使用assert()进行断言验证。\n\n* `boot_alloc()`\n\n这个函数的解释是，**建立在虚拟内存系统过程中用来为数据结构分配内存空间**。\n\n值得注意的是，`end`变量是在`kernel.ld`中的`.bss`段定义的，也就是说其**首次调用的时候，从内核的bss段结束处分配一个内存块。**\n\n这个bss段在虚拟地址空间`0xf0000000`以上的部分，也就是上图中**物理地址的直接映射区**。从这个地方开始，我们就开始建立用于管理虚拟内存的内核数据结构：\n\n```c\n// This simple physical memory allocator is used only while JOS is setting\n// up its virtual memory system.  page_alloc() is the real allocator.\n//\n// If n>0, allocates enough pages of contiguous physical memory to hold 'n'\n// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.\n//\n// If n==0, returns the address of the next free page without allocating\n// anything.\n//\n// If we're out of memory, boot_alloc should panic.\n// This function may ONLY be used during initialization,\n// before the page_free_list list has been set up.\nstatic void *\nboot_alloc(uint32_t n)\n{\n\tstatic char *nextfree;\t// virtual address of next byte of free memory\n\tchar *result;\n\n\t// Initialize nextfree if this is the first time.\n\t// 'end' is a magic symbol automatically generated by the linker, <-在kernel.ld中\n\t// which points to the end of the kernel's bss segment:\n\t// the first virtual address that the linker did *not* assign\n\t// to any kernel code or global variables.\n\tif (!nextfree) {\n\t\textern char end[];\n\t\tnextfree = ROUNDUP((char *) end, PGSIZE);\n\t}\n\t// Allocate a chunk large enough to hold 'n' bytes, then update\n\t// nextfree.  Make sure nextfree is kept aligned\n\t// to a multiple of PGSIZE.\n\t//\n\t// LAB 2: Your code here.\n\t//return address of next free page\n\tif(n ==0){\n\t\treturn nextfree;\n\t}\n\t//allocate\n\tresult = nextfree;\n\tnextfree = ROUNDUP((char *)(nextfree + n), PGSIZE);\n\treturn result;\n}\n```\n\n* `mem_init()`\n\n这个函数一上来就调用`boot_alloc()`分配了一页的空闲内存并且初始化，该区域的指针为`kern_pgdir`，换句话说**这就是我们的页目录**`page directory`。\n\n接下来我们需要做的工作是为页数组`pages`分配虚拟内存，`pages`以及其数据结构的定义如下：\n\n```c\n/*\n * Page descriptor structures, mapped at UPAGES.\n * Read/write to the kernel, read-only to user programs.\n *\n * Each struct PageInfo stores metadata for one physical page.\n * Is it NOT the physical page itself, but there is a one-to-one\n * correspondence between physical pages and struct PageInfo's.\n * You can map a struct PageInfo * to the corresponding physical address\n * with page2pa() in kern/pmap.h.\n */\nstruct PageInfo {\n\t// Next page on the free list.\n  //pp_link 是下一项地址\n\tstruct PageInfo *pp_link;\n\n\t// pp_ref is the count of pointers (usually in page table entries)\n\t// to this page, for pages allocated using page_alloc.\n\t// Pages allocated at boot time using pmap.c's\n\t// boot_alloc do not have valid reference count fields.\n\t//pp_ref 是引用数量，凡是调用page_alloc 分配了该页的进程都会引用\n\tuint16_t pp_ref;\n};\n\nstruct PageInfo *pages;\t\t// Physical page state array\nsize_t npages;\t\t\t// Amount of physical memory (in pages)\n\t\t\t\t\t\t\t\t\t\t//npages在kernel中i386_detect_memory的时候被赋值\n```\n\n也就是说，`PageInfo`该结构体就是一个能够与物理内存映射的页面。`pages`数组就是每一个分页的信息，可以通过函数将其转换成物理地址，换句话说该数组中的每一个元素都映射到一个物理页面。我们这里就将所有物理内存做一个到pages中的映射。\n\n我们直接调用`boot_alloc()`即可。\n\n```c\n\t//////////////////////////////////////////////////////////////////////\n\t// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.\n\t// The kernel uses this array to keep track of physical pages: for\n\t// each physical page, there is a corresponding struct PageInfo in this\n\t// array.  'npages' is the number of physical pages in memory.  Use memset\n\t// to initialize all fields of each struct PageInfo to 0.\n\t// Your code goes here:\n\tn = npages * sizeof(struct PageInfo);\n\tpages = (struct PageInfo *)boot_alloc(n);\n\tmemset(pages, 0, n);\n```\n\n该步骤完毕后，所有的物理内存都已经按照页面大小划分成了页面，并依次存放在了pages中。\n\n* `page_init()`\n\n我们刚才已经为页表数组分配了空间并初始化，这一步我们需要初始化页的数据结构以及**初始化能够分配的空闲物理空间页的链表(memory free list)**。\n\n原始代码已经给出了，但是我们需要将其进行修改，因为该代码将所有物理内存页都标记为free，这就导致一些问题：\n\n1. 物理页面0处应该是used，这部分保存着实模式的IDT和BIOS的数据结构，这些结构我们可能之后还会用到。\n2. 还记得lab1中为了向后兼容8086而留下的`I/O hole`吗？这一部分内存是不能够被使用的，也就不能标记为free。\n3. `I/O hole`之后的extended memory（从`0x00100000`(1MB)开始，参考lab1笔记的`PC物理空间`部分），这些内存中有一部分被kernel占用了，存放kernel的代码和数据结构，不能被标记为free。\n\n对于可用的空间，我们有`npages_basemem`，这是在如下的`i386_detect_memory`函数detect内存时确定的：\n\n```c\nstatic void\ni386_detect_memory(void)\n{\n\tsize_t basemem, extmem, ext16mem, totalmem;\n\n\t// Use CMOS calls to measure available base & extended memory.\n\t// (CMOS calls return results in kilobytes.)\n\tbasemem = nvram_read(NVRAM_BASELO);\n\textmem = nvram_read(NVRAM_EXTLO);\n\text16mem = nvram_read(NVRAM_EXT16LO) * 64;\n\n\t// Calculate the number of physical pages available in both base\n\t// and extended memory.\n\tif (ext16mem)\n\t\ttotalmem = 16 * 1024 + ext16mem;\n\telse if (extmem)\n\t\ttotalmem = 1 * 1024 + extmem;\n\telse\n\t\ttotalmem = basemem;\n\n\tnpages = totalmem / (PGSIZE / 1024);\n\tnpages_basemem = basemem / (PGSIZE / 1024);\n\n\tcprintf(\"Physical memory: %uK available, base = %uK, extended = %uK\\n\",\n\t\ttotalmem, basemem, totalmem - basemem);\n}\n\n```\n\n这里的重点就是，如何知道extended memory起始的哪部分区域被kernel占用？实际上我们可以调用`boot_alloc(0)`得知我们分配的页目录的最后的区域，这个区域之后就全是空闲了。\n\n最终我们完成的`page_init()`如下：\n\n```c\nvoid\npage_init(void)\n{\n\t// The example code here marks all physical pages as free.\n\t// However this is not truly the case.  What memory is free?\n\t//  1) Mark physical page 0 as in use.\n\t//     This way we preserve the real-mode IDT and BIOS structures\n\t//     in case we ever need them.  (Currently we don't, but...)\n\t//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)\n\t//     is free.\n\t//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must\n\t//     never be allocated.\n\t//  4) Then extended memory [EXTPHYSMEM, ...).\n\t//     Some of it is in use, some is free. Where is the kernel\n\t//     in physical memory?  Which pages are already in use for\n\t//     page tables and other data structures?\n\t//\n\t// Change the code to reflect this.\n\t// NB: DO NOT actually touch the physical memory corresponding to\n\t// free pages!\n\tsize_t i;\n\t// for (i = 0; i < npages; i++) {\n\t// \tpages[i].pp_ref = 0;\n\t// \tpages[i].pp_link = page_free_list;\n\t// \tpage_free_list = &pages[i];\n\t// }\n\t// 跳过page[0]，分配npages_basemem数量\n\tfor (i = 1; i < npages_basemem; i++){\n\t\tpages[i].pp_ref = 0;\n\t\tpages[i].pp_link = page_free_list;\n\t\tpage_free_list = &pages[i];\n\t}\n\t// 无视I/O hole，这部分之前使用了npages_basemem所以不用操作\n\t// 从extended_memory的kernel使用之后的位置开始分配\n\t\t\t// 首先取出最后一块目录项的地址\n\tphysaddr_t next_page = PADDR(boot_alloc(0));\n\t\t\t// 得到索引\n\tsize_t idx_free = next_page / PGSIZE;\n\tfor(i = idx_free; i < npages; i++){\n\t\tpages[i].pp_ref = 0;\n\t\tpages[i].pp_link =page_free_list;\n\t\tpage_free_list = &pages[i];\n\t}\n}\n```\n\n这一步完成之后，我们就已经配置好了一个`page_free_list`，也就是说我们初始化了一个物理内存的所有可用空间页的链表。\n\n* `page_alloc()`\n\n这个函数的作用很简单，就是请求页面，即从`page_free_list`中分配一个空闲的主存页，我们只需要按照注释实现功能。\n\n```c\nstruct PageInfo *\npage_alloc(int alloc_flags)\n{\n\t// Fill this function in\n\tstruct PageInfo * alloc_page = page_free_list;\n\tif(!page_free_list){\n\t\treturn NULL;\n\t}\n\t// move page_free_list\n\tpage_free_list = page_free_list -> pp_link;\n\t// init free page\n\talloc_page -> pp_link = NULL;\n\tif(alloc_flags & ALLOC_ZERO){\n    // page2kva 是将输入的PageInfo结构体转换成对应的pages[]虚拟地址\n    //（因为pages都是通过boot_alloc分配在kernel区，所以是kva）\n    // kva 是kernel virtual address的缩写\n\t\tmemset(page2kva(alloc_page), 0, PGSIZE);\n\t}\n\treturn alloc_page;\n}\n```\n\n这个部分完成后，我们就实现了分配空闲内存页的操作。\n\n* `page_free()`\n\n同样这个函数就是字面意思，释放一块空闲页。\n\n```c\n//\n// Return a page to the free list.\n// (This function should only be called when pp->pp_ref reaches 0.)\n//\nvoid\npage_free(struct PageInfo *pp)\n{\n\t// Fill this function in\n\t// Hint: You may want to panic if pp->pp_ref is nonzero or\n\t// pp->pp_link is not NULL.\n\tif(pp -> pp_ref){\n\t\tpanic(\"[page_free] page : %p is still being used\", pp);\n\t}\n\telse if(pp -> pp_link){\n\t\tpanic(\"[page_free] page : %p is already freed\", pp);\n\t}\n\tpp -> pp_link = page_free_list;\n\tpage_free_list = pp;\n}\n```\n\n\n\n## Part2: Virtual Memory\n\n**exercise 2: **\n\n阅读[Intel 80386 Reference Manual](https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm)第五章以及第六章。这两章的主要内容都是段式和页式管理的方式，以及80386的保护模式。关键内容将在下面呈现：\n\n### > 段式管理-Segment\n\n回顾一下lab1中我们介绍了段式管理的基本流程：程序首先将对应的**段选择子（数组索引）加载到段寄存器**中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，然后**根据段寄存器的段选择子再确定最终要使用的段描述符**。结合段描述符中包含的信息加上指令自身的地址构造出实际的物理地址。\n\n可能这段话有些抽象，我们需要详细说明这个过程。\n\n#### >> 描述符(Descriptors)\n\n在分段保护方式下，**每一个段都需要很多相应的描述信息（包括但不限于段基址、段大小、特权级等）**，描述符是用来统一的描述这些数据。注意：描述符是由编译器、链接器、加载器或者操作系统创建的，而非应用程序的程序员创建的。\n\n对于一个描述符（`64位`），我们将其分为4个16位（蓝色标记），其结构如图：\n\n![image-20200305101256359](https://tva1.sinaimg.cn/large/00831rSTly1gcity4nq0jj30hg0bpwer.jpg)\n\n* 第一个16位：段界限（segment limit）。段界限用于限定段的大小，但是要注意的是段界限实际上有20位，它需要和描述符中另一段4bits的数据拼接（如上图）。\n* 第二个16位：段基址（segment base）。段基址用于描述段在虚拟地址的起始地址。同样显然虚拟地址应该是32位的，它也需要和描述符中的其他数据位拼接（如上图）\n* 第三个16位：\n  * `P`：**存在位**，表示该描述符对应的段是否已经读入内存。\n  * `DPL`：长度为两位，表示该段所属的特权级\n  * `1`或`0`：记录段的类型是存储段还是系统段\n  * `TYPE`：记录段的属性\n    - 如果是存储段，那么是代码段还是数据段\n    - 段的读写权限如何\n  * `A`：访问位，记录段是否被访问过\n\n* 第四个16位：\n  * `G`：**粒度位**，G=0说明段长度的单位是`Byte`，而G=1说明单位是`page`。\n  * `X`：用于区分32位和16位访问方式。\n  * `O`和`AVL`：保留位和系统专用位\n  * `LIMIT`：段界限的16-19位\n\n这样，有了段描述符，我们就能描述一个段的全部信息。\n\n#### >> 段描述符表(Descriptor Table)\n\n顾名思义，段描述符表就是用来存储段描述符的数据结构，它是由8Bytes为一个单位的元素组成的数组。实际上有如下两种段描述符表：\n\n* LDT：局部描述符表。**每一个进程都有一个局部描述符表**，存放在系统的特定的位置。LDT中存有进程对应的代码以及数据段位置等信息。\n\n* GDT：全局描述符表。全局描述符表一定是存在且唯一的。他存放操作系统内核所使用的描述符以及所有系统段的描述符。同时可以通过GDT索引LDT。\n\n![image-20200305102057147](https://tva1.sinaimg.cn/large/00831rSTly1gciu6gqjzrj30h00czt8r.jpg)\n\n#### >> 描述符表寄存器(GDTR/LDTR)\n\n显然，描述符表寄存器是处理器用于定位GDT和LDT在内存中的位置的寄存器。\n\n```c\nstruct gdtr {\n\tu16 limite;    //描述符表的表限长\n\tu32 base;      //描述符表的基址\n} __attribute__ ((packed));\n```\n\n机器刚刚加电，或者处理器复位后，表基址被默认设置为0，而表限长默认设置为0xffff。在保护模式初始化的过程中，必须给GDTR加载新的值。可以使用lgdt指令为GDTR加载新的值。\n\n#### >> 段选择子(Selectors)\n\n段选择子（2Bytes）用于**选择特定的描述符表以及表中特定的描述符**。段选择子一般都是被放置于段寄存器中，段选择子由**13位的索引**、**1位的表指示位**以及**2位的请求特权级**三部分组成。其中**索引指定了描述符**；**表指示位选择应该访问的描述符表**-0代表全局描述符表，1代表局部描述符表；**请求特权级用于段级的保护机制**，自0到4分别代表ring 0 到ring 3。结构体如下：\n\n```c\nstruct selector {\n    u16 index:13;      //用于指定描述符\n    u16 ti:1;          //用于访问描述符表 0-GDT   1-LDT\n    u16 rpl:2;         //请求特权级保护机制\n}\n```\n\n\n\n### > 页式管理(Pages)\n\n#### >> Linear Address\n\n对于虚拟地址的构成，再次将上文的图片搬上来：\n\n![image-20200305150546864](https://tva1.sinaimg.cn/large/00831rSTly1gcj2etkyucj30h507ft8n.jpg)\n\n#### >>页表(Page Tables)\n\n页表可以理解为是32bits的页说明符(Page specifiers)的数组。页表本身就是一页，就代表了它本身占用4KB的内存以及其中包含1KB的元素（每个页说明符元素占32-bits）。\n\n而80386可以采用多级页表，比如上图的二级页表。这种情况MMU在索引一个线性地址LA的时候，首先取出LA中的页目录DIR(高10位)，然后这种情况下`cr3`寄存器（也称为页目录基址寄存器page directory base register（PDBR））中存放的是当前页目录的首地址，通过DIR页目录的内容索引到LA所在的**页表首地址**。然后再通过LA中间部分的10位PAGE位（**页表索引部分**），根据DIR找到的页表首地址结合找到页表项。\n\n该过程中，页目录表项被称为DIR Entry，页表表项被称为Page Table Entry。结构在上图已经非常清晰。\n\n#### >>页表项(Page-Table Entries)\n\n无论是哪一级别的页表，其中的表项的形式都是相同的（无论是DIR Entry还是Page Table Entry），如下所示：\n\n![image-20200305152142276](https://tva1.sinaimg.cn/large/00831rSTly1gcj2ve1m96j30ft04zq2v.jpg)\n\n注：如果是两级页表，那DIR Entry(PDE)中的`page frame address`部分就是索引到的页表的地址，Page Table Entry(PTE)中的该部分则是索引到的物理页（page frame）。\n\n而最低12位就是权限位，表示该项的各种权限。其中最低位`P`（Present Bit）代表该entry项是否可以用于地址转换，如果为0则表示不可以使用。\n\n\n\n### 2.1 Virtual, Linear and Physical Addresses\n\nx86中，虚拟地址（virtual address）是由段选择子和段内偏移组成的（段式管理），而线性地址（linear address）是段翻译机制翻译后得到的地址，之所以该地址不能称为物理地址，是因为还未经过页翻译机制。线性地址经过页翻译之后，得到物理地址也就是内存的实际位置：\n\n![image-20200305153427296](https://tva1.sinaimg.cn/large/00831rSTly1gcj38nqj5yj30h403t74e.jpg)\n\n**在JOS中默认的boot过程中，我们通过boot.S设置了GDT，GDT中每个描述符的段基址base为0且段限长limit为0xffffffff，也就是说lab2中，我们不涉及内存的分段机制。**\n\n回忆lab1的part3：`kern/entrypgdir.c`将物理地址的0x00000000-0x00400000（`4M`）映射为虚拟地址0xf0000000-0xf0400000（`4M`），同时也将0x00000000-0x00400000的虚拟地址翻译为0x00000000-0x00400000。\n\n本实验中，我们要映射物理内存的最低256M到`0xf0000000`(KERNBASE)开始的虚拟地址。此外还要映射其它一些虚拟地址空间。\n\n**exercise 3:**\n\n我们首先进入qemu-gdb进入调试状态，输入`ctrl-a c`进入qemu monitor。在这里我们需要用到如下几条指令：\n\n```\nxp/Nx paddr -- 查看paddr物理地址处开始的，N个字的16进制的表示结果。\ninfo registers -- 展示所有内部寄存器的状态。\ninfo mem -- 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。\ninfo pg -- 展示当前页表的结构。\n```\n\ngdb的`x/Nx addr`指令是用来查看指定虚拟地址的数据的。\n\n我们这里将存在映射关系的虚拟地址与物理地址的内容进行对比，观察是否一致：\n\n![image-20200305160716822](https://tva1.sinaimg.cn/large/00831rSTly1gcj46t9za7j318f04d0ur.jpg)\n\n使用`(qemu)info mem`看看内存映射关系以及权限：\n\n```\n(qemu) info mem\n0000000000000000-0000000000400000 0000000000400000 -r-\n00000000f0000000-00000000f0400000 0000000000400000 -rw\n```\n\n刚进入kernel保护模式时，使用`(qemu)info pg`查看当前页表结构：\n\n```\n(qemu) info pg\nVPN range     Entry         Flags        Physical page\n[00000-003ff]  PDE[000]     ---------P\n  [00000-003ff]  PTE[000-3ff] --------WP 00000-003ff\n[f0000-f03ff]  PDE[3c0]     --------WP\n  [f0000-f03ff]  PTE[000-3ff] --------WP 00000-003ff\n```\n\nkernal运行完之后加载完成后再次使用命令`(qemu)info pg`:\n\n```\n(qemu) info pg\nVPN range     Entry         Flags        Physical page\n[00000-003ff]  PDE[000]     ----A----P\n  [00000-00000]  PTE[000]     --------WP 00000\n  [00001-0009f]  PTE[001-09f] ---DA---WP 00001-0009f\n  [000a0-000b7]  PTE[0a0-0b7] --------WP 000a0-000b7\n  [000b8-000b8]  PTE[0b8]     ---DA---WP 000b8\n  [000b9-000ff]  PTE[0b9-0ff] --------WP 000b9-000ff\n  [00100-00102]  PTE[100-102] ----A---WP 00100-00102\n  [00103-00111]  PTE[103-111] --------WP 00103-00111\n  [00112-00112]  PTE[112]     ---DA---WP 00112\n  [00113-00114]  PTE[113-114] --------WP 00113-00114\n  [00115-003ff]  PTE[115-3ff] ---DA---WP 00115-003ff\n[f0000-f03ff]  PDE[3c0]     ----A---WP\n  [f0000-f0000]  PTE[000]     --------WP 00000\n  [f0001-f009f]  PTE[001-09f] ---DA---WP 00001-0009f\n  [f00a0-f00b7]  PTE[0a0-0b7] --------WP 000a0-000b7\n  [f00b8-f00b8]  PTE[0b8]     ---DA---WP 000b8\n  [f00b9-f00ff]  PTE[0b9-0ff] --------WP 000b9-000ff\n  [f0100-f0102]  PTE[100-102] ----A---WP 00100-00102\n  [f0103-f0111]  PTE[103-111] --------WP 00103-00111\n  [f0112-f0112]  PTE[112]     ---DA---WP 00112\n  [f0113-f0114]  PTE[113-114] --------WP 00113-00114\n  [f0115-f03ff]  PTE[115-3ff] ---DA---WP 00115-003ff\n```\n\n\n\n一旦我们进入了保护模式，我们就无法直接使用物理地址或者线性地址，MMU会将所有内存引用转换为虚拟地址。\n\nJOS的kernel通常需要将地址作为不透明值或者integer进行操作，而不对其进行解引用（比如在物理内存分配器中）。为了记录代码，JOS内核有两种表示方式：\n\n* `uintptr_t`：代表虚拟地址，同普通指针一样\n* `physaddr_t`：代表物理地址\n\n实际上他们都只是`uint32_t`的别名。\n\n注意：我们不能直接对int类型进行解引用，而是先转换为指针类型。而且对于`physaddr_t`转换成的指针类型不能解引用，因为MMU会将其视为虚拟地址，这样导致我们无法得到正确的内容。\n\n**Question:** \n\n假定下面的代码正确，x应该是什么类型？`physaddr_t`还是`uintaddr_t`？\n\n```c\n\tmystery_t x;\n\tchar* value = return_a_pointer();\n\t*value = 10;\n\tx = (mystery_t) value;\n```\n\n肯定是`uintaddr_t`，因为第三行可以对指针value进行解引用，所以value肯定是虚拟地址。\n\n\n\nJOS的kernel有些时候需要读写物理地址，可以通过宏KADDR(pa)实现将物理地址+KERNBASE转换为内核虚拟地址。同理，有时候需要能通过内核虚拟地址找到物理地址，-KERNBASE，通过宏PADDR(va)实现。\n\n\n\n### 2.2 Reference Counting\n\n在之后的实验中，我们可能将同一个物理页同时映射到很多虚拟地址，我们必须维护`struct PageInfo`结构体中的`pp_ref`来保持引用计数。当引用计数为0的时候，页面就可以被释放。\n\n一般来说，这个引用计数等同于物理页面在`UTOP`以下的区域出现的次数（这个以上的区域的物理页面大多数都是在启动的时候被内核分配，而且不会被释放）。\n\n同样地，引用计数也可以追踪指向页目录的数量，以及页目录对页表项的引用计数。\n\n\n\n### 2.3 Page Table Management\n\n在这个环节中，我们需要编写管理页表的例程：插入以及删除线性地址到物理地址的映射，同时还需要创建页表。\n\n**exercise 4:**\n\n在`kern/pmap.c`中，实现以下函数：\n\n```c\npgdir_walk()\nboot_map_region()        \npage_lookup()\npage_remove()        \npage_insert()\n//最终通过mem_init()中的check_page()进行检查\n```\n\n* `pgdir_walk()`\n\n这个函数的以一个线性地址`va`和一个页目录`pgdir`作为参数，返回该线性地址对应的页面所在页表项(PTE)的地址。\n\n我们需要使用线性地址进行页目录索引，索引到对应的页表地址。如果索引到的页表还没被创建且`create`参数为1，则我们创建以个新的页表。进而我们获取页表项索引，通过页表结合表项索引，得到页表项。\n\n有一点需要注意的是，页表项实际上都是在KERNBASE之上，我们必须返回一个`kva(kernel virtual address)`。\n\n```c\n// Given 'pgdir', a pointer to a page directory, pgdir_walk returns\n// a pointer to the page table entry (PTE) for linear address 'va'.\n// This requires walking the two-level page table structure.\n//\n// The relevant page table page might not exist yet.\n// If this is true, and create == false, then pgdir_walk returns NULL.\n// Otherwise, pgdir_walk allocates a new page table page with page_alloc.\n//    - If the allocation fails, pgdir_walk returns NULL.\n//    - Otherwise, the new page's reference count is incremented,\n//\tthe page is cleared,\n//\tand pgdir_walk returns a pointer into the new page table page.\n//\n// Hint 1: you can turn a PageInfo * into the physical address of the\n// page it refers to with page2pa() from kern/pmap.h.\n//\n// Hint 2: the x86 MMU checks permission bits in both the page directory\n// and the page table, so it's safe to leave permissions in the page\n// directory more permissive than strictly necessary.\n//\n// Hint 3: look at inc/mmu.h for useful macros that manipulate page\n// table and page directory entries.\n//\npte_t *\npgdir_walk(pde_t *pgdir, const void *va, int create)\n{\n\t// page directory index and entry\n\tuint32_t pd_idx = PDX(va);\n\tpde_t pd_entry = pgdir[pd_idx];\n\t// page table index and entry\n\tuint32_t pt_idx = PTX(va);\n\t// page directory entry ->page table does not exists\n\tif((pd_entry & PTE_P) != 1){\n\t\tif(!create)\n\t\t\treturn NULL;\n\t\t//create page table\n\t\tstruct PageInfo * pg_new = page_alloc(ALLOC_ZERO);\n\t\tif(pg_new == NULL)\n\t\t\treturn NULL;\n\t\tpg_new -> pp_ref += 1;\n\t\tphysaddr_t pg_pa = page2pa(pg_new);\n\t\t// add to page directory entry\n\t\tpgdir[pd_idx] = pg_pa | PTE_P | PTE_W | PTE_U;\n\t\t// return (pte_t *)(KADDR(PTE_ADDR(pd_entry)))+ pt_idx;\n\t\treturn (pte_t *)page2kva(pg_new) + pt_idx;\n\t}\n\t//pte_t : page table entry      pte_t* : page table addr\n\t// 取得pte_t* 仿照其他函数获取pte_t* 的过程\n\t// 这个操作只能return Kernel Virtual Address（物理地址0-4M是不可写的）\n\tpte_t * pg_table = KADDR(PTE_ADDR(pd_entry));\n\treturn (pte_t *)(pg_table + pt_idx);\n}\n```\n\n我们这里要分析一下，当`!(pd_entry & PTE_P)`的情况：也就是说这个时候通过页目录无法索引一个有效的页表，此时我们需要创建一个页表。\n\n创建页表调用`page_alloc()`分配一个空闲页面当作我们的页表即可。（空闲页面4K，页表项32bits = 4B，那么一个页面正好能装下1K个页表项）\n\n完成后，我们就实现了通过虚拟地址以及页目录首址来获取相应的页表项(PTE)地址的功能。\n\n* `boot_map_region()`\n\n这个函数的作用是将一段虚拟内存映射到同样长度的物理内存(都经过页面对齐)。而且映射是以页面为单位。\n\n实际上这个函数的使用过程中只会映射`UTOP`之上的地址。\n\n```c\n// Map [va, va+size) of virtual address space to physical [pa, pa+size)\n// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and\n// va and pa are both page-aligned.\n// Use permission bits perm|PTE_P for the entries.\n//\n// This function is only intended to set up the ``static'' mappings\n// above UTOP. As such, it should *not* change the pp_ref field on the\n// mapped pages.\n//\n// Hint: the TA solution uses pgdir_walk\nstatic void\nboot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)\n{\n\t// Fill this function in\n\tsize_t page_num = size / PGSIZE, i;\n\tfor(i = 0; i < page_num; i++){\n\t\tpte_t * pt_entry = pgdir_walk(pgdir, (void*)(va + i * PGSIZE), 1);\n    // set PTE -> pa\n\t\t*pt_entry = (pa + i * PGSIZE) | perm | PTE_P;\n\t}\n}\n```\n\n* `page_lookup`\n\n这个函数的功能是，给定一个虚拟地址`va`以及相应的页目录地址`pgdir`，我们查找该虚拟地址的页表地址和物理地址，然后将`PageInfo`返回即可。\n\n```c\n// Return the page mapped at virtual address 'va'.\n// If pte_store is not zero, then we store in it the address\n// of the pte for this page.  This is used by page_remove and\n// can be used to verify page permissions for syscall arguments,\n// but should not be used by most callers.\n//\n// Return NULL if there is no page mapped at va.\n//\n// Hint: the TA solution uses pgdir_walk and pa2page.\n//\nstruct PageInfo *\npage_lookup(pde_t *pgdir, void *va, pte_t **pte_store)\n{\n\t// Fill this function in\n\tpte_t *pt_entry = pgdir_walk(pgdir, va, 0);\n\t// no page mapped at va\n\tif(!pt_entry)\n\t\treturn NULL;\n\tif(pte_store){\n\t\t*pte_store = pt_entry;\n\t}\n\treturn pa2page(PTE_ADDR(*pt_entry));\n}\n```\n\n* `page_remove()`\n\n这个函数的作用是解引用，给定虚拟地址`va`以及页目录`pgdir`，我们将其页表中对应的页（如果有）进行解引用。\n\n```c\n// Unmaps the physical page at virtual address 'va'.\n// If there is no physical page at that address, silently does nothing.\n//\n// Details:\n//   - The ref count on the physical page should decrement.\n//   - The physical page should be freed if the refcount reaches 0.\n//   - The pg table entry corresponding to 'va' should be set to 0.\n//     (if such a PTE exists)\n//   - The TLB must be invalidated if you remove an entry from\n//     the page table.\n//\n// Hint: The TA solution is implemented using page_lookup,\n// \ttlb_invalidate, and page_decref.\n//\nvoid\npage_remove(pde_t *pgdir, void *va)\n{\n\t// Fill this function in\n\tpte_t * ptestore_temp;\n\tstruct PageInfo * pg_entry = page_lookup(pgdir, va, &ptestore_temp);\n\t// PTE does not exist\n\tif(!pg_entry) return;\n\t// \n\tpage_decref(pg_entry);\n\t*ptestore_temp = 0;\n\t// invalidate a TLB entry\n\ttlb_invalidate(pgdir, va);\n}\n```\n\n* `page_insert()`\n\n这个函数是将给定的虚拟地址`va`对应的页面映射到给定的物理页面`pp`。\n\n注意一个case：就是我们对同一个`pp`和同一个`va`进行两次重复的insert，如果我们先使用`page_remove()`再增加`pp`的引用数，那会导致`pp`进入了`free_list`但是引用数+1后不为0。所以我们必须先增加引用数。\n\n```c\n// Map the physical page 'pp' at virtual address 'va'.\n// The permissions (the low 12 bits) of the page table entry\n// should be set to 'perm|PTE_P'.\n//\n// Requirements\n//   - If there is already a page mapped at 'va', it should be page_remove()d.\n//   - If necessary, on demand, a page table should be allocated and inserted\n//     into 'pgdir'.\n//   - pp->pp_ref should be incremented if the insertion succeeds.\n//   - The TLB must be invalidated if a page was formerly present at 'va'.\n//\n// Corner-case hint: Make sure to consider what happens when the same\n// pp is re-inserted at the same virtual address in the same pgdir.\n// However, try not to distinguish this case in your code, as this\n// frequently leads to subtle bugs; there's an elegant way to handle\n// everything in one code path.\n//\n// RETURNS:\n//   0 on success\n//   -E_NO_MEM, if page table couldn't be allocated\n//\n// Hint: The TA solution is implemented using pgdir_walk, page_remove,\n// and page2pa.\n//\nint\npage_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)\n{\n\t// Fill this function in\n\t// page table could not be allocated\n\tpte_t * pt_entry = pgdir_walk(pgdir, va, 1);\n\tif(!pt_entry) return -E_NO_MEM;\n\tpp -> pp_ref += 1;\n\t//remove page\n\tif((*pt_entry) & PTE_P){\n\t\tpage_remove(pgdir, va);\n\t}\n\t*pt_entry = page2pa(pp) | perm | PTE_P;\n\treturn 0;\n}\n```\n\n实现这些，我们就可以通过`check_page()`函数了，大功告成。\n\n![image-20200306161147186](https://tva1.sinaimg.cn/large/00831rSTly1gck9xtm008j30hp065q46.jpg)\n\n\n\n## Part3: Kernel Address Space\n\n这一部分我们终于可以讨论内核地址空间了。JOS将32位的线性地址空间分成了两部分：\n\n* 用户环境（在Lab3中涉及）：将控制低地址空间\n\n* 内核：总是完全地控制高地址空间\n\n将内核与用户环境分隔是在`inc/memlayout.h`中进行定义的，且为内核保留了大于256MB的虚拟地址空间。（实际上这解释了为什么我们需要在lab1中给内核提供如此高的链接地址：否则内核的虚拟地址空间将没有足够的空间同时映射到其下方的用户环境中）\n\n\n\n### 3.1 Permissions and Fault Isolation\n\n尽管内核与用户的内存都位于同一地址空间，我们仍然需要在x86页表中使用权限位去保证用户代码仅能够访问低地址空间。否则用户代码可能会覆写内核数据，这就会有潜在的冲突，此外用户代码还可能能窃取其他用户、内核的私有数据。注意可写权限位`PTW_W`会同时影响用户代码以及内核代码。\n\n用户的环境将不具备任何内存权限在`ULIM`之上，而内核是可以读写这些内存的。对于`[UTOP, ULIM)`这个范围的地址，用户环境和内核的权限是相同的：均是只能读不能写。这段内存的主要作用是向用户暴露内核中的一些只读的数据结构。最后，`UTOP`以下的地址空间将是用户环境使用的，用户环境可以自行设置这些内存的权限。\n\n\n\n### 3.2 Initializing the Kernel Address Space\n\n在这个部分，我们需要设置`UTOP`之上的内核地址空间。`inc/memlayout.h`展示了我们可能需要的layout结构，这个结构在文章开头的*JOS分段与分页*这一节已经进行了详细描述。\n\n**exercise 5:**\n\n补全`mem_init()`函数在调用`check_page()`之后未完成的缺失部分。在我们完善了`mem_init()`之后，将可以通过`check_kern_pgdir()`以及`check_page_installed_pgdir()`的检查。\n\n跟着注释读一遍，就没有什么难度了。\n\n```c\n\t//////////////////////////////////////////////////////////////////////\n\t// Now we set up virtual memory\n\n\t//////////////////////////////////////////////////////////////////////\n\t// Map 'pages' read-only by the user at linear address UPAGES\n\t// Permissions:\n\t//    - the new image at UPAGES -- kernel R, user R\n\t//      (ie. perm = PTE_U | PTE_P)\n\t//    - pages itself -- kernel RW, user NONE\n\t// Your code goes here:\n\t// 将pages数组映射到UPAGE地址区域以上\n\tboot_map_region(kern_pgdir, UPAGES, npages * sizeof(struct PageInfo), PADDR(pages), PTE_U | PTE_P);\n\t//////////////////////////////////////////////////////////////////////\n\t// Use the physical memory that 'bootstack' refers to as the kernel\n\t// stack.  The kernel stack grows down from virtual address KSTACKTOP.\n\t// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)\n\t// to be the kernel stack, but break this into two pieces:\n\t//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory\n\t//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if\n\t//       the kernel overflows its stack, it will fault rather than\n\t//       overwrite memory.  Known as a \"guard page\".\n\t//     Permissions: kernel RW, user NONE\n\t// Your code goes here:\n\tboot_map_region(kern_pgdir, (KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);\n\t//////////////////////////////////////////////////////////////////////\n\t// Map all of physical memory at KERNBASE.\n\t// Ie.  the VA range [KERNBASE, 2^32) should map to\n\t//      the PA range [0, 2^32 - KERNBASE)\n\t// We might not have 2^32 - KERNBASE bytes of physical memory, but\n\t// we just set up the mapping anyway.\n\t// Permissions: kernel RW, user NONE\n\t// Your code goes here:\n\tsize_t KERNSIZE = (unsigned)0xffffffff - KERNBASE;\n\tboot_map_region(kern_pgdir, KERNBASE, KERNSIZE, 0, PTE_W | PTE_P);\n```\n\n这里我们同样就大功告成了，再次启动qemu信息如下：（请选择性忽略我debug过程中的log）\n\n![image-20200307132808176](https://tva1.sinaimg.cn/large/00831rSTly1gclatuiullj30k00bqmxn.jpg)\n\n再次，我们回顾一下`mem_init()`的全过程，这就是jos设置页表管理内存的全过程：\n\n```c\n// Set up a two-level page table:\n//    kern_pgdir is its linear (virtual) address of the root\n//\n// This function only sets up the kernel part of the address space\n// (ie. addresses >= UTOP).  The user part of the address space\n// will be set up later.\n//\n// From UTOP to ULIM, the user is allowed to read but not write.\n// Above ULIM the user cannot read or write.\nvoid\nmem_init(void)\n{\n\tuint32_t cr0;\n\tsize_t n;\n\n\t// Find out how much memory the machine has (npages & npages_basemem).\n\ti386_detect_memory();\n\n\t// Remove this line when you're ready to test this function.\n\t//panic(\"mem_init: This function is not finished\\n\");\n\n\t//////////////////////////////////////////////////////////////////////\n\t// create initial page directory.\n\tkern_pgdir = (pde_t *) boot_alloc(PGSIZE);\n\tcprintf(\"kern_pgdir info: %x\\n\",kern_pgdir);\n\tcprintf(\"kern_pgdir address: %x\\n\", &kern_pgdir);\n\tcprintf(\"[mem_init] kern_pgdir[0] addr: %x\\n\", PTE_ADDR(kern_pgdir[0]));\n\tmemset(kern_pgdir, 0, PGSIZE);\n\n\t//////////////////////////////////////////////////////////////////////\n\t// Recursively insert PD in itself as a page table, to form\n\t// a virtual page table at virtual address UVPT.\n\t// (For now, you don't have understand the greater purpose of the\n\t// following line.)\n\n\t// Permissions: kernel R, user R\n\t// UVPT是页表区域的开始\n\tkern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;\n\n\t//////////////////////////////////////////////////////////////////////\n\t// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.\n\t// The kernel uses this array to keep track of physical pages: for\n\t// each physical page, there is a corresponding struct PageInfo in this\n\t// array.  'npages' is the number of physical pages in memory.  Use memset\n\t// to initialize all fields of each struct PageInfo to 0.\n\t// Your code goes here:\n\tn = npages * sizeof(struct PageInfo);\n\tpages = (struct PageInfo *)boot_alloc(n);\n\tmemset(pages, 0, n);\n\t//////////////////////////////////////////////////////////////////////\n\t// Now that we've allocated the initial kernel data structures, we set\n\t// up the list of free physical pages. Once we've done so, all further\n\t// memory management will go through the page_* functions. In\n\t// particular, we can now map memory using boot_map_region\n\t// or page_insert\n\tpage_init();\n\n\tcheck_page_free_list(1);\n\tcheck_page_alloc();\n\tcheck_page();\n\n\t//////////////////////////////////////////////////////////////////////\n\t// Now we set up virtual memory\n\n\t//////////////////////////////////////////////////////////////////////\n\t// Map 'pages' read-only by the user at linear address UPAGES\n\t// Permissions:\n\t//    - the new image at UPAGES -- kernel R, user R\n\t//      (ie. perm = PTE_U | PTE_P)\n\t//    - pages itself -- kernel RW, user NONE\n\t// Your code goes here:\n\t// 将pages数组映射到UPAGE地址区域以上\n\tboot_map_region(kern_pgdir, UPAGES, npages * sizeof(struct PageInfo), PADDR(pages), PTE_U | PTE_P);\n\t//////////////////////////////////////////////////////////////////////\n\t// Use the physical memory that 'bootstack' refers to as the kernel\n\t// stack.  The kernel stack grows down from virtual address KSTACKTOP.\n\t// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)\n\t// to be the kernel stack, but break this into two pieces:\n\t//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory\n\t//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if\n\t//       the kernel overflows its stack, it will fault rather than\n\t//       overwrite memory.  Known as a \"guard page\".\n\t//     Permissions: kernel RW, user NONE\n\t// Your code goes here:\n\tboot_map_region(kern_pgdir, (KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);\n\t//////////////////////////////////////////////////////////////////////\n\t// Map all of physical memory at KERNBASE.\n\t// Ie.  the VA range [KERNBASE, 2^32) should map to\n\t//      the PA range [0, 2^32 - KERNBASE)\n\t// We might not have 2^32 - KERNBASE bytes of physical memory, but\n\t// we just set up the mapping anyway.\n\t// Permissions: kernel RW, user NONE\n\t// Your code goes here:\n\tsize_t KERNSIZE = (unsigned)0xffffffff - KERNBASE;\n\tboot_map_region(kern_pgdir, KERNBASE, KERNSIZE, 0, PTE_W | PTE_P);\n\t// Check that the initial page directory has been set up correctly.\n\tcheck_kern_pgdir();\n\n\t// Switch from the minimal entry page directory to the full kern_pgdir\n\t// page table we just created.\tOur instruction pointer should be\n\t// somewhere between KERNBASE and KERNBASE+4MB right now, which is\n\t// mapped the same way by both page tables.\n\t//\n\t// If the machine reboots at this point, you've probably set up your\n\t// kern_pgdir wrong.\n\tlcr3(PADDR(kern_pgdir));\n\n\tcheck_page_free_list(0);\n\n\t// entry.S set the really important flags in cr0 (including enabling\n\t// paging).  Here we configure the rest of the flags that we care about.\n\tcr0 = rcr0();\n\tcr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;\n\tcr0 &= ~(CR0_TS|CR0_EM);\n\tlcr0(cr0);\n\n\t// Some more checks, only possible after kern_pgdir is installed.\n\tcheck_page_installed_pgdir();\n}\n```\n\n**Question**\n\n* What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:\n\n这个我们需要填写在`mem_init()`过程中映射的地址\n\n| Entry | Base Virtual Address |     Points to (logically)     |\n| :---: | :------------------: | :---------------------------: |\n| 1023  |      0xFFC00000      |        Physical Memory        |\n|   …   |         ……….         |               …               |\n|  960  |      0xF0000000      | First 4 MB on Physical Memory |\n|  959  |      0xEFC00000      |         Kernel Stack          |\n|  957  |      0xEF400000      |     Kernel Page Directory     |\n|  956  |      0xEF000000      |             Pages             |\n\n* We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?\n\n虽然用户环境和内核都在同样的地址空间中，但用户显然无法访问内核区域的内存的。回忆我们在`mem_init()`过程中对所有的映射设置了特权级，没有`PTE_U`特权的页显然是用户无法访问的。\n\n* What is the maximum amount of physical memory that this operating system can support? Why?\n\n操作系统虚拟内存空间部分分布如下：\n\n```\n * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000\n *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE\n *    UVPT      ---->  +------------------------------+ 0xef400000\n *                     |          RO PAGES            | R-/R-  PTSIZE\n *    UPAGES    ---->  +------------------------------+ 0xef000000\n```\n\n回顾我们实验的第一部分，我们建立了一个物理内存分配器。在`page_init()`函数中，我们将所有可用的物理内存按照页面进行划分并且存放在了`pages`结构体数组中。在第三部分设置操作系统内核虚拟空间的过程中，我们在`mem_init()`配置页表的过程中使用`boot_map_regions()`将`pages`映射到了`UPAGES`以上的区域。\n\n那么程序空间是利用虚拟地址进行访问`pages`的，此时对应虚拟空间的`R0 PAGES`，大小为`0xef000000-0xef400000(4MB)`。一旦超过4MB就越界到了`UVPT`这个空间，而`UVPT`这个空间是映射在了`kern_pgdir`中。\n\n也就是说，虚拟空间访问`UPAGES`最多只有4MB，而`pages`的每个元素是`struct PageInfo`类型的结构体，占8B空间，其每一个元素对应的一个页面有4KB大。因此一共支持物理空间2GB。\n\n* How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?（内存管理的开销问题，如果我们有能支持的最大的物理内存，管理内存的开销是什么？且如何减少？）\n\n经过上一问的分析，操作系统支持虚拟空间最多寻址512KB个页面，也就是有512个页表（一个页表能够寻址`2^10`个页面）。再次回顾我们在2.3节进行页表管理的时候，对于每一个`kern_dir`未初始化的页表项，我们都通过`page_alloc()`分配一个页表。也就是说实际上每一个页表的大小都是`PGSIZE`。那么页表所需的空间开销就是`PGSIZE * 512 = 2MB`，再加上4KB的页目录以及刚才所需4MB的空间存放所有`PageInfo`，总共的空间开销就是`6MB + 4KB`。\n\n如果想降低开销的话，可以把`PGSIZE`设置的大一些。\n\n* Revisit the page table setup in `kern/entry.S` and `kern/entrypgdir.c`. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?（在我们刚开启分页机制的时候，程序还运行在低地址1MB上，控制流在什么时候跳转到KERNBASE以上？为什么在打开分页机制之后我们仍能够运行在物理地址的低地址上？）\n\n我们查看`entry.S`的关键代码，这部分代码实际上是`obj/kern/kernal.asm`中的entry部分。\n\n```assembly\nentry:\n\tmovw\t$0x1234,0x472\t\t\t# warm boot\n\n\t# We haven't set up virtual memory yet, so we're running from\n\t# the physical address the boot loader loaded the kernel at: 1MB\n\t# (plus a few bytes).  However, the C code is linked to run at\n\t# KERNBASE+1MB.  Hence, we set up a trivial page directory that\n\t# translates virtual addresses [KERNBASE, KERNBASE+4MB) to\n\t# physical addresses [0, 4MB).  This 4MB region will be\n\t# sufficient until we set up our real page table in mem_init\n\t# in lab 2.\n\n\t# Load the physical address of entry_pgdir into cr3.  entry_pgdir\n\t# is defined in entrypgdir.c.\n\tmovl\t$(RELOC(entry_pgdir)), %eax\n\tmovl\t%eax, %cr3\n\t# Turn on paging.\n\tmovl\t%cr0, %eax\n\torl\t$(CR0_PE|CR0_PG|CR0_WP), %eax\n\tmovl\t%eax, %cr0\n\n\t# Now paging is enabled, but we're still running at a low EIP\n\t# (why is this okay?).  Jump up above KERNBASE before entering\n\t# C code.\n\tmov\t$relocated, %eax\n\tjmp\t*%eax\n```\n\n我们可以看到最后五行，也就是执行指令`movl %eax, %cr0`之后，控制流就使用`jmp`指令跳转到了`KERNBASE`以上的高地址部分。之所以打开分也机制我们还能在低地址运行，是由于实际上低地址和`KERNBASE`以上的高地址区域都被映射在同一片物理内存中。所以运行无误。\n\n\n\n完成了上述的所有问题，就也可以使用`make grade`。\n\n```\n  Physical page allocator: OK\n  Page management: OK\n  Kernel page directory: OK\n  Page management 2: OK\nScore: 70/70\n```\n\n舒服了。完结撒花🎉","tags":["operating system"]},{"title":"手把手带你MIT6.828 - Lab1","url":"/2020/03/02/os/","content":"\n# Lab1 Booting a PC\n\n官方文档: [lectures](https://pdos.csail.mit.edu/6.828/2018/lec/)\n\n## Part 1: PC Bootstrap\n\n这个部分是为了熟悉x86汇编语言，以及PC的启动流程。同时在实验的过程中，我们需要使用qemu和gdb进行调试。\n\n\n\n### 1.1 x86 Assembly\n\n**exercise 1：**熟悉x86汇编。\n\n很显然，这个步骤不需要再次赘述。\n\n如果你看这篇文章的时候没学过assembly，那说明你看这篇文章的时候没学过assembly。可能你入门os比较超前。\n\n请注意哦～本实验的所有assembly都是AT&T格式的，不是INTEL格式的哦～不要把sourse和dest弄反。\n\n\n\n### 1.2 Simulating the x86\n\n在我们的实验中并没有使用真正的PC，而是qemu模拟的PC。我们按照实验要求下载好一切依赖项以及资源后，直接使用`make`指令。\n\n`make`之后，我们就bulid完成了一个低配版6.828boot loader以及kernal（在之后的环节中，我们会逐渐完善这个kernal的）。\n\n同时，我们qemu所需的虚拟硬盘就在`/obj/kern/kernal.img`下生成完毕，这个硬盘镜像中包括我们的boot loader(`obj/boot/boot`)以及我们的kernal(`/obj/kernal`)。\n\n当我们唤起qemu的虚拟PC时，我们只需要在lab文件夹的terminal中输入`make qemu`即可。\n\n这将使用设置硬盘并将串行端口直接输出到终端所需的选项执行qemu，我们可以看到启动时屏幕上显示的一系列字符串：\n\n<img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gcej5omkh1j31400ngwmt.jpg\" alt=\"image-20200301165721235\" style=\"zoom:50%;\" />\n\nbooting from hard disk之后的一切流程都已经呈现在屏幕上。\n\n实际上，我们可以通过regular shell window和qemu display window同时与kernal进行交互。\n\n有一点需要注意的是：我们的kernal monitor是直接运行在仿真的虚拟硬盘上的。这就意味着我们是可以将`obj/kern/kernal.img`的内容拷贝到真实硬盘的前几个扇区的，这样就可以在实际的PC屏幕中看到qemu window中相同的内容。（不建议如此的原因是，将其复制到硬盘的开头会破坏主引导记录master boot record，以及第一个分区的开头beginning of the first partition）\n\n\n\n### > PC物理地址空间\n\nPC的物理空间布局如下：\n\n```\n+------------------+  <- 0xFFFFFFFF (4GB)\n|      32-bit      |\n|  memory mapped   |\n|     devices      |\n|                  |\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n|                  |\n|      Unused      |\n|                  |\n+------------------+  <- depends on amount of RAM\n|                  |\n|                  |\n| Extended Memory  |\n|                  |\n|                  |\n+------------------+  <- 0x00100000 (1MB)\n|     BIOS ROM     |\n+------------------+  <- 0x000F0000 (960KB)\n|  16-bit devices, |\n|  expansion ROMs  |\n+------------------+  <- 0x000C0000 (768KB)\n|   VGA Display    |\n+------------------+  <- 0x000A0000 (640KB)\n|                  |\n|    Low Memory    |\n|                  |\n+------------------+  <- 0x00000000\n```\n\n最初的PC基于16位的8088处理器，仅仅能够支持**2^20B = 2^10KB = 1MB** 的寻址。所以早起的地址空间从0x00000开始到0xFFFFF结束（2^20B）。\n\n* 0x00000 - 0xA0000(640KB)被称为低内存，这就是早期的PC能用的唯一RAM。\n\n* 0xA0000-0xFFFFF(384KB)被硬件保留作特殊用途比如视频缓冲区或者固件。这部分中最重要的区域是从0xF0000-0xFFFFF(64KB)的**基本输入输出系统BIOS**。\n\n  > BIOS的作用是初始化系统，比如激活显卡(video card)、检查内存等。在该初始化过程完成后，BIOS从合适的位置，如硬盘(hard disk)、软盘(floppy disk)、光碟(CD-ROM)甚至网络中读取操作系统，然后将机器的控制权转移给操作系统。\n\n从Intel的80286到80386，处理器能够支持16MB以及4GB的地址空间！但是为了向后兼容(backward compatibility)，PC架构保留了原始的最低的1MB的内存布局。\n\n现代PC因此在0x000A0000-0x00100000的内存中有一个“洞”。这个洞将内存分为了低内存/保留内存(Low Memory)(低640KB)以及拓展内存(Extended Memory)(其他范围)。除此之外，32位的PC的地址空间的最上方，常常被BIOS保留用于32位的PCI设备。\n\n最新的x86处理器可以支持超过4GB的物理内存，也就是说内存可以超过0xFFFFFFFF。因此BIOS需要预留出第二个“洞”以保证那些32位的PCI设备的地址可以被正确的映射。\n\n\n\n### 1.3 ROM BIOS\n\n根据实验的指导，我们使用qemu和gdb的联合调试。输入指令`make qemu-gdb`。此时qemu将在第一条指令执行之前暂停，并且等待gdb的debugging connection。\n\n然后我们新开一个terminal，输入指令`make gdb`我们可以看到如图所示的输出：\n\n![image-20200301173547006](https://tva1.sinaimg.cn/large/00831rSTly1gcek9o3f62j31h80bzte3.jpg)\n\n因为提供了`.gdbinit`文件，所以我们的gdb能够一下子链接进来，自动attach到需要调试的程序上。（前提当然是需要debug的程序已经运行起来了）\n\n我们看到需要执行的第一条指令`ljmp`如下\n\n```assembly\n[f000:fff0] 0xffff0:    ljmp   $0xf000,$0xe05b\n```\n\n* 从这个指令可以看出，从上电开始，IBM PC从0x000ffff0开始执行指令。该处地址位于BIOS的64位空间的顶层。\n* 此时，CS = 0xf000, IP = 0xfff0\n* 第一条指令是一个`jmp`指令，跳转至CS = 0xf000, IP = 0xe05b\n\n这些其实都是早期的8088处理器设计的。这样的设计能够保证BIOS在刚刚上电之后总是能够控制机器。因为在刚上电的时候，内存中并不存在可以执行的代码。\n\n> 在这里我们需要理解CS:IP是如何表示一个实地址空间的：\n>\n> 8086是分段式寻址，也就是通过两个16位的寄存器值构造一个20位的地址。实际地址是CS * 16 + IP = 0xf000 * 16 + 0xfff0 = 0xffff0\n\n**exercise 2:**\n\n使用gdb的`si`（单步调试）命令进入ROM BIOS并且追踪几条指令，猜测这些指令的作用。我们在这里不需要指出指令的细节，只需要了解BIOS开始运行的核心思想即可。\n\n```assembly\n[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b # 跳到一个较早的位置\n[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6ac8 # 测试cs段的0x6ac8字是否为0\n[f000:e062]    0xfe062: jne    0xfd2e1         \n[f000:e066]    0xfe066: xor    %dx,%dx         # 测试为0\n[f000:e068]    0xfe068: mov    %dx,%ss         # 设置栈段-ss段寄存器\n[f000:e06a]    0xfe06a: mov    $0x7000,%esp    # 设置栈指针寄存器\n                                               # 栈的延伸方向和代码段延伸方向相反\n[f000:e070]    0xfe070: mov    $0xf34c2,%edx   # 设置edx寄存器值\n[f000:e076]    0xfe076: jmp    0xfd15c         # 跳转\n[f000:d15c]    0xfd15c: mov    %eax,%ecx       \n[f000:d15f]    0xfd15f: cli                    # 关闭硬件中断\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # 为啥要关中断不用爷多说了吧？启动的时候\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # 你害敢被中断？\n[f000:d160]    0xfd160: cld                    # 设置串传送指令方向\n[f000:d161]    0xfd161: mov    $0x8f,%eax      \n[f000:d167]    0xfd167: out    %al,$0x70       # IO端口指令，8086的端口和内存编址分开\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # 端口0x70的寄存器是控制寄存器\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # 将要访问的CMOS中的数据偏移传入0x70端口\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # 就可以在0x71号端口下读取相应数据\n[f000:d169]    0xfd169: in     $0x71,%al       # 从CMOS读取选择的寄存器\n[f000:d16b]    0xfd16b: in     $0x92,%al       # 读取系统控制端口A\n/*我们知道了，0x70端口和0x71端口是用于控制系统中一个叫做CMOS的设备，这个设备是一个低功耗的存储设备，它可以用于在计算机关闭时存储一些信息，它是由独立的电池供电的。*/\n/*这个CMOS中可以控制跟PC相关的多个功能，其中最重要的就是时钟设备（Real Time Clock）的 ，它还可以控制是否响应不可屏蔽中断NMI(Non-Maskable Interrupt)。\n操作CMOS存储器中的内容需要两个端口，一个是0x70另一个就是0x71。其中0x70可以叫做索引寄存器，这个8位寄存器的最高位是不可屏蔽中断(NMI)使能位。如果你把这个位置1，则NMI不会被响应。低7位用于指定CMOS存储器中的存储单元地址，所以如果你想访问第1号存储单元，并且在访问时，我要使能NMI，那么你就应该向端口0x70里面送入0b10000001 = 0x81。 mov $0x8f, %eax实际做到了这一点*/\n/*\nmov $0x81, %al\nout %al, 0x70\n然后对于这个地址单元的操作，比如读或者写就可以由0x71端口完成，比如你现在想从1号存储单元里面读出它的值，在完成上面的两条指令后，就可以输入这条指令\nin $0x71, %al \n再回到我们的系统，这三条指令可以看出，它首先关闭了NMI中断，并且要访问存储单元0xF的值，并且把值读到al中，但是在后面我们发现这个值并没有被利用，所以可以认为这三条指令是用来关闭NMI中断的。*/\n[f000:d16d]    0xfd16d: or     $0x2,%al        \n[f000:d16f]    0xfd16f: out    %al,$0x92       # 通过快速A20以启动A20\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # A20是个历史遗留的问题，爷不想了解这根线\n/*这三步操作又是在控制端口，此时被控制的端口号为0x92。我们可以查看到，它控制的是 PS/2系统控制端口A，而这两步的操作明显是在把这个端口的1号bit置为1。这个端口的bit1的功能是：\nbit 1= 1 indicates A20 active\n即A20位，即第21个地址线被使能，了解实模式和保护模式的同学肯定清楚，如果A20地址线被激活，那么系统工作在保护模式下。但是在之后的boot loader程序中，计算机首先要工作在实模式下啊。所以这里的这个操作，根据网上 http://kernelx.weebly.com/a20-address-line.html 所说应该是去测试可用内存空间。在boot loader之前，它肯定还会转换回实模式。*/\n[f000:d171]    0xfd171: lidtw  %cs:0x6ab8      # 将cs:0x6ab8加载进入IDT表\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # IDT表是中断描述符表\n[f000:d177]    0xfd177: lgdtw  %cs:0x6a74      # 将cs:0x6a74加载进入GDT表\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # GDT表是全局描述符表\n[f000:d17d]    0xfd17d: mov    %cr0,%eax   \n[f000:d180]    0xfd180: or     $0x1,%eax       \n[f000:d184]    0xfd184: mov    %eax,%cr0       # 将cr0寄存器的保护模式位打开\n\n/*计算机中包含CR0~CR3四个控制寄存器，用来控制和确定处理器的操作模式。其中这三个语句的操作明显是要把CR0寄存器的最低位(0bit)置1。CR0寄存器的0bit是PE位，启动保护位，当该位被置1，代表开启了保护模式。但是这里出现了问题，我们刚刚说过BIOS是工作在实模式之下，后面的boot loader开始的时候也是工作在实模式下，所以这里把它切换为保护模式，显然是自相矛盾。所以只能推测它在检测是否机器能工作在保护模式下。*/\n\n[f000:d187]    0xfd187: ljmpl  $0x8,$0xfd18f   # 通过ljmp指令进入保护模式\n=> 0xfd18f:     mov    $0x10,%eax              # 设置段寄存器\n=> 0xfd194:     mov    %eax,%ds\n=> 0xfd196:     mov    %eax,%es  \n=> 0xfd198:     mov    %eax,%ss\n=> 0xfd19a:     mov    %eax,%fs\n=> 0xfd19c:     mov    %eax,%gs\n=> 0xfd19e:     mov    %ecx,%eax  \n=> 0xfd1a0:     jmp    *%edx                   # 跳转\n```\n\n在这里必须附上一个牛逼的链接：[I/O Func](http://bochs.sourceforge.net/techspec/PORTS.LST)。你可以看到各种I/O设备的端口号清单。\n\n关于CMOS的介绍，请看：[CMOS](http://wiki.osdev.org/CMOS)。\n\n中断向量表，请看：[IDT](http://wiki.osdev.org/Interrupt_Descriptor_Table)。\n\nGDT表实现了保护方式下非常重要的一部分，但是具体介绍将在boot loader过程中。\n\n\n\n## Part2: BootLoader\n\n软盘和硬盘都被分为了512 Bytes的扇区(sector)。一个扇区是磁盘传输的最小粒度：每一个读操作和每一个写操作都必须是一个或者多个扇区，而且必须要扇区边界对齐。\n\n如果说一个磁盘是可引导的，那么该磁盘的第一个扇区就叫做**引导扇区(boot sector)**，也就是引导程序的代码储存的扇区。（意思就是引导盘的引导内容都在磁盘的第一个扇区）**当BIOS发现一个可引导的硬件（软盘或者硬盘等），它将把引导扇区从磁盘中读取至内存的0x7c00-0x7dff位置**，同时使用一个`jmp`指令设置CS:IP = 0000:7000，然后将控制权交给boot loader(引导程序)。与BIOS加载地址相同，这个地址对于PC来说是固定的且是标准化的(说实话原文还说是fairly arbitrary，我没读懂是什么意思)。\n\n> 从光盘中引导的情形更加复杂而且更加powerful，因为光盘的一个扇区大小是2048Bytes，也就是说BIOS可以从光盘中读取一个更大的引导镜像加载到内存中。\n\n在6.828中，我们使用传统的硬盘引导机制，这意味着我们的boot loader必须满足512Bytes的限制。\n\n引导由一个汇编源文件`boot/boot.s`，以及一个C源文件`boot/main.c`组成。\n\n如果我们想要完全理解这些文件，我们需要一些前置知识：下面可能…painful。\n\n\n\n### > 实模式和保护模式\n\n关于这些的简单介绍，请参考[PC Assembly Language](https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf)该书的1.2.7和1.2.8节。内容不多。\n\n实模式是为了与8086兼容而设置的。在实模式下，处理器相当于一个快速8086处理器。\n\n实际上，在**处理器被加电或者复位的时候，实模式就会启动**。\n\n* 实模式下，各寄存器以实模式的初始化值进行工作；\n* 实模式的地址空间一共有20位(1MB)；\n* 实模式下不支持内存分页机制（显然内存分页是为了给保护模式设置的）；\n* 实模式下，各内存段都是可读、可写、可执行的，不支持指令优先级，所有的指令均运行在特权级；\n* 实模式不支持任务切换；\n* 实模式的中断处理与8086相同，使用中断矢量表来定位中断服务程序。\n\n在保护模式下，处理器的所有功能都是可用的，具体来说：\n\n* 保护模式提供了完全的32位空间，寻址空间为4GB；\n* 保护模式支持内存分页机制，提供了对虚拟内存的硬件支持；\n* 保护模式的处理器支持多任务（上下文切换）；\n* 保护模式的处理器支持指令和数据的特权级，配合边界检查等机制，既可以共享数据也可以隔离各个任务。\n\n\n\n### > A20地址线\n\n不要意思，爷本来以为不用了解这个。。。\n\n早期的PC上，处理器只支持20位的地址空间，任何超过20位的地址都会被卷回。\n\n也就是说 0xffff + 0xffff = 0x1fffe -> 0xfffe。\n\n然而从80286开始，Intel支持了24位的地址空间，上例的地址相加不会发生卷回。\n\n为了保证与早期的PC完全兼容，Intel采用“黑魔法”，将A20(第21根)地址线与键盘控制器的一个输出进行了与运算。进而控制了A20地址线的值。\n\n默认情况下，A20是置0的，PC将智能访问1M、3M、5M……这样的奇数段，进入保护模式之前我们必须先打开A20以获得完全寻址能力。\n\nJOS的内核可以通过端口的方式与键盘控制器进行通信而且打开A20。\n\n- 8042有一个1 Byte的输入缓冲区，一个1 Byte的输出缓冲区、一个1 Byte的状态寄存器、以及一个1 Byte的控制寄存器。前三个寄存器可以直接从0x60和0x64端口进行访问。最后一个寄存器通过“Read Command Byte”命令进行读，通过“Write Command Byte”命令进行写。\n- 对0x60端口读会读输入缓冲区；对0x60端口写会写输出缓冲区；对0x64端口读会读状态寄存器；对0x64端口写会发送命令。\n- 状态寄存器的Bit1为IBF - Input Buffer Full，当该Bit为1时，输入缓冲区满，不能对0x60端口或0x64端口写。\n- 对0x64端口写0xd1发送的命令是“Write Output Port”写输出端口，表明将参数写入输出端口（0x60端口写）。\n- A20使用的是键盘控制器输出的Bit 1，向输出端口写入0xdf可以打开A20；向输出端口写入0xdd则会关闭A20。\n\n\n\n### > 分段机制和全局描述符表GDT\n\n注⚠️：**更具体的段管理方式将在lab2中进行介绍。在不具备这些知识的前提下，可以暂时忽略下文关于分段机制的内容和介绍，直接跳到boot.S。**\n\n分段机制可以看看：[分段机制](http://www.kerneltravel.net/chenlj/lecture4.pdf)\n\nx86处理器提供了分段机制和分页机制两种内存管理模式。如果要进入保护模式，就必须要启动分段机制（分页机制不是必须的）。\n\n分段机制将内存划分为若干个段，每一个段都由段基址、段界限和段属性构成。**由一个段描述符表（可以理解为一个数组）描述所有段的信息**。段描述符表可以是全局的也可以是局部的。\n\n简化来说，程序首先将对应的**段选择子（数组索引）加载到段寄存器**中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，然后**根据段寄存器的段选择子再确定最终要使用的段描述符**。结合段描述符中包含的信息加上指令自身的地址构造出实际的线性地址（什么是线性地址呢？这个在lab2中会介绍）。最终将物理地址送到地址总线上，在物理内存中进行寻址，取回相应的数据。\n\n\n\n#### >> 全局描述符表寄存器\n\nx86处理器提供了专门的全局描述符表寄存器GDTR(Global Description Table Register)用于保存全局描述符表的表基址和表限长。GDTR由两个字节的表限长(limit)和4个字节的表基址(base)构成。表基址制定了全局描述符表的起始地址，表限长确定了全局描述符表的大小，结构体描述如下：\n\n```c\nstruct gdtr {\n\tu16 limite;\n\tu32 base;\n} __attribute__ ((packed));\n```\n\n机器刚刚加电，或者处理器复位后，表基址被默认设置为0，而表限长默认设置为0xffff。在保护模式初始化的过程中，必须给GDTR加载新的值。可以使用lgdt指令为GDTR加载新的值。\n\n\n\n#### >> 段选择子\n\n段选择子（2Bytes）用于**选择特定的描述符表以及表中特定的描述符**。段选择子一般都是被放置于段寄存器中，段选择子由**13位的索引**、**1位的表指示位**以及**2位的请求特权级**三部分组成。其中**索引指定了描述符**；**表指示位选择应该访问的描述符表**-0代表全局描述符表，1代表局部描述符表；**请求特权级用于段级的保护机制**，自0到4分别代表ring 0 到ring 3。结构体如下：\n\n```c\nstruct selector {\n    u16 index:13;\n    u16 ti:1;\n    u16 rpl:2;\n}\n```\n\n\n\n#### >> 段描述符\n\n段描述符（8Bytes）是段描述符表这个“数组”的“元素”。结构体描述如下：\n\n```c\nstruct gdtdesc {\n\tu16 lim0_15;\n\tu16 base0_15;\n\tu8 base16_23;\n\tu8 acces;\n\tu8 lim16_19:4;\n\tu8 other:4;\n\tu8 base24_31;\n} __attribute__ ((packed));\n```\n\n总共包含32位的段基址、20位的段界限、12位的类型。\n\n段基址确定了段的起始地址。段界限规定了段的大小。类型用于**区别不同类型的描述符（包括描述符特权级、段存在位、已访问位等）**\n\n\n\n### > GDT与LDT\n\n看了这些我们再来了解一下保护模式的地址。也就是计算机中实际存在两个表GDT、LDT，前者是全局描述符表，后者是本地段描述符表。他们都用来存放某个运行在内存中的程序的分段信息的。只不过全局描述符表是全局可见的，**即每一个运行在内存中的程序都能访问这个表**。**操作系统的内核程序的段信息就存在GDT表里面。**而LDT表是每一个在内存中的程序都包含的，这里面指明了每一个程序的段信息。\n\n<img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gcfn2gz5knj30f506paar.jpg\" alt=\"image-20200302155554248\" style=\"zoom: 67%;\" />\n\n这就是刚才的段描述符的结构了哈。\n\n\n\ngkd好了好了，我们现在回到BootLoader。BootLoader引导程序通过x86特殊的I/O指令直接访问IDE磁盘设备寄存器，从而从硬盘读取内核。如果需要对这个过程进行更加详细的了解，请阅读[the 6.828 reference page](https://pdos.csail.mit.edu/6.828/2018/reference.html)中的\"IDE hard drive controller\"部分。\n\n现在我们就来看一看我们的引导，boot.s和main.c：\n\n\n\n### 2.1 boot.s 代码\n\nboot.s代码在源文件中打开如下：\n\n```assembly\n#include <inc/mmu.h>\n\n# Start the CPU: switch to 32-bit protected mode, jump into C.\n# The BIOS loads this code from the first sector of the hard disk into\n# memory at physical address 0x7c00 and starts executing in real mode\n# with %cs=0 %ip=7c00.\n# boot.S 主要将CPU切换至32位保护模式，并且跳转进入C代码\n\n.set PROT_MODE_CSEG, 0x8         # kernel code segment selector\n.set PROT_MODE_DSEG, 0x10        # kernel data segment selector\n.set CR0_PE_ON,      0x1         # protected mode enable flag\n\n.globl start\nstart:                        # 程序入口\n  .code16                     # Assemble for 16-bit mode 指导生成16位汇编代码\n  cli                         # Disable interrupts 关中断\n  cld                         # String operations increment 设置串传递顺序递增\n\n  # Set up the important data segment registers (DS, ES, SS). 设置重要的段寄存器为0\n  xorw    %ax,%ax             # Segment number zero\n  movw    %ax,%ds             # -> Data Segment\n  movw    %ax,%es             # -> Extra Segment\n  movw    %ax,%ss             # -> Stack Segment\n\n  # Enable A20:\n  #   For backwards compatibility with the earliest PCs, physical\n  #   address line 20 is tied low, so that addresses higher than\n  #   1MB wrap around to zero by default.  This code undoes this.\n  # 开启A20：\n  #   A20的介绍已经给出，不再赘述。\nseta20.1:\n  inb     $0x64,%al               # Wait for not busy 等待缓冲区可用\n  testb   $0x2,%al                # Test for bit1\n                                  # if bit1 = 1 then buffer is full\n  jnz     seta20.1\n\n  movb    $0xd1,%al               # 0xd1 -> port 0x64\n  outb    %al,$0x64               # Prepare to write output port 准备写入输出端口\n\nseta20.2:\n  inb     $0x64,%al               # Wait for not busy 等待缓冲区可用\n  testb   $0x2,%al\n  jnz     seta20.2                # The same as above 同上\n\n  movb    $0xdf,%al               # 0xdf -> port 0x60\n  outb    %al,$0x60               # 0xdf -> A20 gate enable command 打开A20\n\n  # Switch from real to protected mode, using a bootstrap GDT\n  # and segment translation that makes virtual addresses\n  # identical to their physical addresses, so that the\n  # effective memory map does not change during the switch.\n  lgdt    gdtdesc                # Load gdt size/base to gdtr 设置全局描述符表\n  movl    %cr0, %eax             # Control register 0\n                                 # bit0 is protected enable bit\n                                 # 读取控制寄存器0的值，其Bit0为允许保护模式位\n  orl     $CR0_PE_ON, %eax       # Set PE 将允许保护模式位置1\n  movl    %eax, %cr0             # Update Control register 0 设置控制寄存器0\n\n  # Jump to next instruction, but in 32-bit code segment.\n  # Switches processor into 32-bit mode.\n  ljmp    $PROT_MODE_CSEG, $protcseg # 通过ljmp指令（跳转至下一条指令）进入保护模式\n\n  .code32                     # Assemble for 32-bit mode 指导生成32位汇编代码\nprotcseg:\n  # Set up the protected-mode data segment registers 设置保护模式的数据段寄存器\n  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector\n  movw    %ax, %ds                # -> DS: Data Segment\n  movw    %ax, %es                # -> ES: Extra Segment\n  movw    %ax, %fs                # -> FS\n  movw    %ax, %gs                # -> GS\n  movw    %ax, %ss                # -> SS: Stack Segment\n\n  # Set up the stack pointer and call into C. 设置栈指针并且调用C\n  movl    $start, %esp  # Stack has the opposite extension direction than Code\n                        # 注意栈的延伸方向和代码段相反\n  call bootmain #调用main.c中的bootmain函数\n\n  # If bootmain returns (it shouldn't), loop.\nspin:\n  jmp spin\n\n# Bootstrap GDT 引导GDT\n.p2align 2                                # force 4 byte alignment\ngdt:\n  SEG_NULL\t\t\t\t# null seg 默认第一个段描述符为空\n  SEG(STA_X|STA_R, 0x0, 0xffffffff)\t# code seg 设置代码段描述符\n  SEG(STA_W, 0x0, 0xffffffff)\t        # data seg 设置数据段描述符\n  # 关于SEG宏可以参考mmu.h\n\ngdtdesc:                                  # 用于设置全局段描述符寄存器\n  .word   0x17                            # sizeof(gdt) - 1 # Size of gdt\n  .long   gdt                             # address gdt # Base address of gdt\n```\n\n------\n\n看完了boot.s，我们还需要去理解main.c，同时我们需要了解以下内容。\n\n\n\n### > ELF文件格式\n\n可执行和可链接格式(Executable and Linkable Format)，相信学过计算机系统基础课程的朋友都不陌生（这一部分的详细内容可以参见CSAPP图书关于链接的详细章节）。简单来说ELF格式就是一种用于二进制文件、可执行文件、目标代码、共享库、核心转储格式文件。\n\nELF文件可以分为两种视图：链接视图（Linking View）和执行视图（Execution View）。在这里我们只描述执行视图：\n\n```\n+--------------------+\n|     ELF Header     |\n+--------------------+\n|Program Header Table|\n+--------------------+\n|      Segment 1     |\n+--------------------+\n|      Segment 2     |\n+--------------------+\n|         ...        |\n+--------------------+\n|Section Header Table|\n|       optinal      |\n+--------------------+\n```\n\nELF文件格式主要由ELF头（ELF Header）、程序头部表（Program Header Table）个节头表（Section Header Table），执行视图中，节头表是可选的。\n\n<img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gcfndwkks1j30go0g9gna.jpg\" alt=\"image-20200302160913062\" style=\"zoom:67%;\" />\n\n**注意：段（`Segment`）与节（`Section`）的区别。很多地方对两者有所混淆。段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中。相比而言，节的粒度更小。**\n\n有关于这些数据结构的C语言定义可以参考头文件<inc/elf.h>。\n\n- ELF头主要包含了ELF魔数、文件类型、程序头部表偏移和大小、程序入口等信息；\n- 程序头部表可以看做一个数据结构的数组，**每一个元素都描述了一个段。主要包含了段的偏移、段的虚拟地址、段的物理地址、段的大小等信息**。\n\n\n\n### > 磁盘控制器\n\n![image-20200302161557953](https://tva1.sinaimg.cn/large/00831rSTly1gcfnmnm2m6j305m09pjsc.jpg)\n\n![image-20200302161758369](https://tva1.sinaimg.cn/large/00831rSTly1gcfnn0xdabj305m08o0tk.jpg)\n\n磁盘是电脑的主要媒介。磁盘是由盘面构成的。每个盘面有两面或者称为表面，表面覆盖着磁性记录材料。盘面中央有一个可以旋转的主轴，使得盘面能够以固定的旋转速率旋转，通常为5400-15000转每分钟（Revolution Per Minute）。磁盘通常包含一个或多个这样的盘面，并且封装在一个密封的容器内。\n\n每一个表面是**由一组称为磁道的同心圆组成**。**每个磁道被划分为一组扇区**，**每个扇区的数据位是等大的（通常为512字节）**，这些数据编码在扇区上的磁性材料中。扇区之间由一些间隔分开，这些间隔中不存储数据位。间隔用来标识扇区的格式化位。\n\n磁盘的**柱面是所有盘片上到主轴中心距离相等的磁道的集合**。\n\n<img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gcfnx1wkbbj30hq0fwwqb.jpg\" alt=\"image-20200302162737033\" style=\"zoom:50%;\" />\n\n对于磁盘的寻址通常分为CHS和LBA两种。\n\n1. CHS即柱面（cylinder）-磁头（head）-扇区（sector）寻址。每个盘片都对应着一个磁头，每一个盘片都被划分成柱面，每一个柱面都被划分成多个段。磁盘的最小存储单元是段。早期的IBM PC架构上采用CHS进行磁盘寻址。CHS是一个三元组，包括10bit的柱面号，8bit的磁头号以及6bit的扇区号。这样CHS的最大寻址范围为2^10 × 2^8 × 2^6 × 512 = 8GB。\n2. 随着磁盘容量的不断扩大，CHS的8GB寻址范围已经不能满足需要，现在的磁盘普遍采用逻辑区块地址（Logical Block Adress）的方式进行寻址来进行抽象。LBA是一个整数，代表磁盘上的一个逻辑区块编号，通过将这个整数转换成CHS格式来完成磁盘的具体寻址。LBA为48个bit，最大寻址范围为128PB。在本实验中，LBA按照旧的规范采用28个bit。\n\nIDE硬盘控制器（IDE Hard Drive Controller）的0x1F7端口读为磁盘0状态寄存器。\n其Bit6为RDY Bit，当其置1表明磁盘上电完成。在对于磁盘做任何操作（除了复位）之前务必要保证该Bit为1。\n其Bit7为BSY Bit，当其置1表明磁盘忙。在你向磁盘发送任何指令前务必保证该Bit为0。\n\n通过IDE硬盘控制器读取扇区需要如下的步骤：\n\n1. 向0x1F2端口写入待操作的扇区数目；\n2. 向0x1F3-0x1F5端口依次写入LBA的低24位；\n3. 向0x1F6端口的低4位写入LBA的高4位，向0x1F6端口的高4位写入驱动器地址；\n4. 向0x1F7端口写入读命令0x20。\n\n0x1F6寄存器又称Drive/Head寄存器。其低4位是LBA的高4位。其Bit5和Bit7一般是1。其Bit6为LBA位，当置1时表示启用LBA寻址。其Bit4为DRV位。用来选择驱动器，Master驱动器为0，Slave驱动器为1。这里将高4位置为0x1110\n\n在使用读命令0x20之前需要完整的设置柱面/磁头/扇区。当这个命令完成，你可以从磁盘的数据寄存器（0x1F0端口）读取256个字（16Bits）。\n\n------\n\n好了下面我们就开始看main.c。\n\n\n\n### 2.2 main.c 代码\n\n官方的代码注释中已经详细的介绍了代码作用以及BOOT UP的总体流程。务必仔细阅读代码的注释。\n\n```c\n#include <inc/elf.h>\n#include <inc/x86.h>\n/**********************************************************************\n * This a dirt simple boot loader, whose sole job is to boot\n * an ELF kernel image from the first IDE hard disk.\n *\n * DISK LAYOUT\n *  * This program(boot.S and main.c) is the bootloader.  It should\n *    be stored in the first sector of the disk.\n *\n *  * The 2nd sector onward holds the kernel image.\n *\n *  * The kernel image must be in ELF format.\n *\n * BOOT UP STEPS\n *  * when the CPU boots it loads the BIOS into memory and executes it\n *\n *  * the BIOS intializes devices, sets of the interrupt routines, and\n *    reads the first sector of the boot device(e.g., hard-drive)\n *    into memory and jumps to it.\n *\n *  * Assuming this boot loader is stored in the first sector of the\n *    hard-drive, this code takes over...\n *\n *  * control starts in boot.S -- which sets up protected mode,\n *    and a stack so C code then run, then calls bootmain()\n *\n *  * bootmain() in this file takes over, reads in the kernel and jumps to it.\n **********************************************************************/\n\n#define SECTSIZE 512\n#define ELFHDR ((struct Elf *)0x10000)    // scratch space  暂存空间\n\nvoid readsect(void *, uint32_t); //读磁盘扇区\nvoid readseg(uint32_t, uint32_t, uint32_t);//从内核的offset处读取count个字节到物理地址pa处\n\nvoid bootmain(void) {\n    struct Proghdr *ph, *eph;\n\n    // read 1st page off disk 从磁盘上读取第一页\n    readseg((uint32_t)ELFHDR, SECTSIZE * 8, 0);\n\n    // is this a valid ELF? 通过ELF魔数确认ELF有效\n    if (ELFHDR->e_magic != ELF_MAGIC) goto bad;\n\n    // load each program segment (ignores ph flags) 读取各个段\n  \t// ELF header里面指明了第一个program section header的位置。\n    // 也指明了最后一个位置在哪里\n    // [ph, end_of_program_header)这个区间\n    // 这里面表明了每个程序段的大小以及位置。\n    ph = (struct Proghdr *)((uint8_t *)ELFHDR + ELFHDR->e_phoff);\n    // 程序头部表的起始地址\n    eph = ph + ELFHDR->e_phnum;    // 程序头部表的结束地址\n    for (; ph < eph; ph++)\n        // p_pa is the load address of this segment (as well\n        // as the physical address)\n        // p_pa是加载地址也是物理地址\n        readseg(ph->p_pa, ph->p_memsz, ph->p_offset);\n\n    // call the entry point from the ELF header 从ELF头调用程序入口\n    // note: does not return!\n    ((void (*)(void))(ELFHDR->e_entry))();\n\nbad:\n    // stops simulation and breaks into the debug console\n    outw(0x8A00, 0x8A00);\n    outw(0x8A00, 0x8E00);\n    while (1) /* do nothing */;\n}\n\n// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.\n// 从内核的offset处读取count个字节到物理地址pa处\n// Might copy more than asked 可能会读取超过count个（扇区对齐）\nvoid readseg(uint32_t pa, uint32_t count, uint32_t offset) {\n    uint32_t end_pa;\n\n    end_pa = pa + count;    // 结束物理地址\n\n    // round down to sector boundary 对齐到扇区\n    pa &= ~(SECTSIZE - 1);\n\n    // translate from bytes to sectors, and kernel starts at sector 1\n    offset =\n        (offset / SECTSIZE) + 1;    // 算出扇区数 注意扇区从1开始（0为引导扇区）\n\n    // If this is too slow, we could read lots of sectors at a time.\n    // We'd write more to memory than asked, but it doesn't matter --\n    // we load in increasing order.\n    // 在实际中往往将多个扇区一起读出以提高效率。\n    while (pa < end_pa) {\n        // Since we haven't enabled paging yet and we're using\n        // an identity segment mapping (see boot.S), we can\n        // use physical addresses directly.  This won't be the\n        // case once JOS enables the MMU.\n        // 考虑到没有开启分页以及boot.S中使用了一一对应的映射规则，\n        // 加载地址和物理地址是一致的。\n        readsect((uint8_t *)pa, offset);\n        pa += SECTSIZE;\n        offset++;\n    }\n}\n\nvoid waitdisk(void) {\n    // wait for disk reaady 等待磁盘准备完毕。\n    while ((inb(0x1F7) & 0xC0) != 0x40) /* do nothing */;\n}\n\nvoid readsect(void *dst, uint32_t offset) {\n    // wait for disk to be ready\n    waitdisk();\n\n    outb(0x1F2, 1);    // count = 1 0x1F2 Disk 0 sector count\n    // Read one sector each time\n    outb(0x1F3, offset);    // Disk 0 sector number (CHS Mode)\n    // First sector's number\n    outb(0x1F4, offset >> 8);     // Cylinder low (CHS Mode)\n    outb(0x1F5, offset >> 16);    // Cylinder high (CHS Mode)\n    // Cylinder number\n    outb(0x1F6, (offset >> 24) | 0xE0);    // Disk 0 drive/head\n    // MASK 11100000\n    // Drive/Head Register: bit 7 and bit 5 should be set to 1\n    // Bit6: 1 LBA mode, 0 CHS mode\n    outb(0x1F7, 0x20);    // cmd 0x20 - read sectors\n    /*20H       Read sector with retry. NB: 21H = read sector\n                without retry. For this command you have to load\n                the complete circus of cylinder/head/sector\n                first. When the command completes (DRQ goes\n                active) you can read 256 words (16-bits) from the\n                disk's data register. */\n\n    // wait for disk to be ready\n    waitdisk();\n\n    // read a sector\n    insl(0x1F0, dst, SECTSIZE / 4);\n    // Data register: data exchange with 8/16 bits\n    // insl port addr cnt: read cnt dwords from the input port\n    // specified by port into the supplied output array addr.\n    // dword: 4 bytes = 16 bits\n}\n```\n\n------\n\n我们看完了boot.s和main.c就大概知道了BootLoader的流程，下面让我们用gdb实际调试跟踪一下哈。在此之前我们先打开`/obj/boot/boot.asm`，这个汇编文件是我们的GNUmakefile在编译boot loader之后实际生成的机器码经过反汇编得到的。我们之前已经分析了boot.s和main.c，之所以要在这里看boot.asm是为了能够得到代码实际运行时的物理地址，也就是说为我们gdb调试进行服务的哈。\n\n同时，我们经过BootLoader加载的jos kernal实际上在`/obj/kernal/kernal.asm`文件中。\n\n**exercise 3:**\n\n现在我们仍然在qemu启动时，使用gdb在地址0x7c00的地方打一个断点`b *0x7c00`，这是boot sector被加载过程的起始代码地址。我们从这个断点开始，根据boot.asm中的地址继续跟踪。\n\n![image-20200302172636927](https://tva1.sinaimg.cn/large/00831rSTly1gcfpmfrg2tj309o04e0sw.jpg)\n\n果然我们现在来到了程序起始的关中断指令。然后我们跟着流程走一遍很快就会走完boot.s。\n\n紧接着我们需要执行0x7c45处的代码，也就是将程序交给main.c接管，也就是下图的call指令。\n\n![image-20200302173124668](https://tva1.sinaimg.cn/large/00831rSTly1gcfprf7b3hj30a802a3yj.jpg)\n\n我们继续跟踪到bootmain函数中，根据之前的分析bootmain需要调用readseg()，从磁盘中读操作系统内核，而readseg()实际上是调用了一系列的readsect()函数读取磁盘扇区。我们把这一系列指令都执行一遍之后，来回答下面的四个问题。\n\n1. At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode? 处理器是什么时候开始执行32位的代码？什么原因导致了16位模式切换到32位模式？\n\n这一步实际上就在地址0x7c2d的ljmp指令，从这句汇编指令执行完之后可见gdb调试界面输出 The target architecture is assumed to be i386。原因就是ljmp指令。\n\n![image-20200302173526768](https://tva1.sinaimg.cn/large/00831rSTly1gcfpvmih7hj30a502caa4.jpg)\n\n2. What is the *last* instruction of the boot loader executed, and what is the *first* instruction of the kernel it just loaded?boot loader执行的最后一条指令和kernal加载的第一条指令分别是什么？\n\n![image-20200302174416401](https://tva1.sinaimg.cn/large/00831rSTly1gcfq4tg0i4j30a302g0ss.jpg)\n\n一图解决，boot loader最后一条指令显然就是call指令，也就是说将控制权交给加载好的kernal接管。而kernal执行的第一条指令是`movw $0x1234, 0x472`。\n\n3. *Where* is the first instruction of the kernel?内核的第一条指令在哪？\n\n上面那张图其实就说明了，就在0x10000c。\n\n4. How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?引导加载程序如何确定必须读多少个扇区才能从磁盘获取整个内核？它从哪里读取到这个信息？\n\n有意思的来了哈，这就需要对main.c中的bootmain函数进行理解了，上文已经解释过了。这里实际上就是引导从程序头部表中得到了段的数目以及每个段的大小，然后决定了要从磁盘上读多少个扇区。\n\n\n\n###  2.3 Loading the Kernal\n\n为了有更好的学习体验，在此我们必须确保对C语言指针的知识有充分了解。\n\n**exercise4：**\n\n阅读C语言指针，下载pointer.c，编译运行并且确保能够理解。\n\npointer.c的代码和解释如下：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid f(void) {\n    int  a[4];    // 含有4个元素的整形数组\n    int *b =\n        malloc(16);    // 分配16个字节的内存，并且用一个整形指针指向内存首地址\n    int *c;    // 一个悬挂的整形指针\n    int  i;    // 一个整形数\n\n    printf(\"1: a = %p, b = %p, c = %p\\n\", a, b, c);\n    // 打印a和b和c的地址，分别为0xff9bebcc, 0x566fc160和0xf7ede1e8\n\n    c = a;\n    // 令c指向数组a的首地址\n    for (i = 0; i < 4; i++) a[i] = 100 + i;    // 为a[0]到a[3]分配100-103\n    c[0] = 200;                                // 将c[0]也就是a[0]改为200\n    printf(\"2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],\n           a[3]);\n    // 输出200 101 102 103\n\n    c[1]     = 300;    // 将c[1]也就是a[1]改为300\n    *(c + 2) = 301;    //将*(c + 2)也就是a[2]改为301\n    3 [c]    = 302;    // 将3[c]也就是c[3]改为302\n    printf(\"3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],\n           a[3]);\n    // 输出200 300 301 302\n\n    c  = c + 1;    // 令c指向a[1]\n    *c = 400;      // 将a[1]改为400\n    printf(\"4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],\n           a[3]);\n    // 输出200 400 301 302\n\n    c = (int *)((char *)c + 1);\n    // 将c先转换为char指针指向下一个字节后再转回int指针\n    // 现在a数组的字节分布为（小端）C8000000 90010000 2D010000 2E010000\n    | (c的指针)*c = 500;\n    // 执行后的a数组字节分布（小端）C8000000 90F40100 00010000 2E010000\n    printf(\"5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],\n           a[3]);\n    // 输出200 128144 256 302\n\n    b = (int *)a + 1;\n    // 将b指向a[1]\n    c = (int *)((char *)a + 1);\n    // 将a先转换为char指针指向下一个字节后再转回int指针\n    printf(\"6: a = %p, b = %p, c = %p\\n\", a, b, c);\n    // 输出0xff9bebcc, 0xff9bebd0和0xff9bebcd\n}\n\nint main(int ac, char **av) {\n    // 函数入口\n    f();\n    return 0;\n}\n```\n\n为了接下来的实验，我们仍然需要对ELF文件格式有深入了解。至于此部分，详细的介绍全部都在[ELF specfication](https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf)。\n\n简单来说一些除了上文介绍过的结构以外的基本知识。复习一下上文哦，ELF二进制文件是从一个固定长度的ELF头部开始的，然后是程序头表(program header)列出程序要加载的每个程序段，在之后是节头表(section header)。我们要关注几个程序节：\n\n* .text：存放可执行执行程序指令\n* .rodata：存放只读数据，比如一些由编译器生成的ASCII\n* .data：已初始化的数据部分\n* .bss：未赋值的全局变量\n\n在这里我们尝试使用`objdump -h obj/kern/kernel`，看到dump之后的ELF文件信息如下图。其中`-h`参数的意义是显示头部摘要信息。\n\n```\nobj/kern/kernel:\tfile format ELF32-i386\n\nSections:\nIdx Name          Size      Address          Type\n  0               00000000 0000000000000000\n  1 .text         00001736 00000000f0100000 TEXT\n  2 .rodata       00000714 00000000f0101740 DATA\n  3 .stab         00004195 00000000f0101e54 DATA\n  4 .stabstr      0000194b 00000000f0105fe9\n  5 .data         0000a300 00000000f0108000 DATA\n  6 .bss          00000648 00000000f0112300 DATA\n  7 .comment      00000011 0000000000000000\n  8 .debug_info   00001811 0000000000000000\n  9 .debug_abbrev 00000486 0000000000000000\n 10 .debug_loc    00000eef 0000000000000000\n 11 .debug_aranges 00000040 0000000000000000\n 12 .debug_ranges 00000070 0000000000000000\n 13 .debug_line   000006fc 0000000000000000\n 14 .debug_str    00000b87 0000000000000000\n 15 .symtab       000006b0 0000000000000000\n 16 .strtab       00000343 0000000000000000\n 17 .shstrtab     000000a5 0000000000000000\n```\n\n有一说一，节头表的内容还是比列出的那几个多很多的。\n\n在.text节中，地址分为\"VMA\"(link address)和\"LMA\"(load address)，load address也就是加载地址，就是该节需要被加载到内存中的地址；link address也就是链接地址，是该节期望从中执行的内存地址。这次我们来看看boot.out。\n\n我们仍然使用指令`objdump -h obj/boot/boot.out`并换成参数`-x`。参数`-x`说明了显示可使用的头信息，包括符号表、重定位入口等。：\n\n```\nobj/boot/boot.out:\tfile format ELF32-i386\n\nSections:\nIdx Name          Size      Address          Type\n  0               00000000 0000000000000000\n  1 .text         0000018c 0000000000007c00 TEXT\n  2 .eh_frame     0000009c 0000000000007d8c DATA\n  3 .stab         00000744 0000000000000000\n  4 .stabstr      000008e1 0000000000000000\n  5 .comment      00000011 0000000000000000\n  6 .symtab       00000190 0000000000000000\n  7 .strtab       000000a7 0000000000000000\n  8 .shstrtab     00000043 0000000000000000\n```\n\n```\nobj/boot/boot.out:\tfile format ELF32-i386\n\nSections:\nIdx Name          Size      Address          Type\n  0               00000000 0000000000000000\n  1 .text         0000018c 0000000000007c00 TEXT\n  2 .eh_frame     0000009c 0000000000007d8c DATA\n  3 .stab         00000744 0000000000000000\n  4 .stabstr      000008e1 0000000000000000\n  5 .comment      00000011 0000000000000000\n  6 .symtab       00000190 0000000000000000\n  7 .strtab       000000a7 0000000000000000\n  8 .shstrtab     00000043 0000000000000000\n---\n此处略去了symbol table\n---\nProgram Header:\n    LOAD off    0x00000054 vaddr 0x00007c00 paddr 0x00007c00 align 2**2\n         filesz 0x00000228 memsz 0x00000228 flags rwx\n```\n\n我们可以看到最后几行的program header程序头，需要被加载到内存中的区域已经被标记为LOAD，所有程序头的信息都已经被给出，比如vaddr（虚拟地址）以及paddr（物理地址）。\n\n这实际上就解释了BootLoader中读ELF的作用，就是将不同的section加载到不同的地址。\n\n这次我们使用指令`objdump -x obj/kern/kernel`。\n\n```\nobj/kern/kernel:\tfile format ELF32-i386\n\nSections:\nIdx Name          Size      Address          Type\n  0               00000000 0000000000000000\n  1 .text         00001736 00000000f0100000 TEXT\n  2 .rodata       00000714 00000000f0101740 DATA\n  3 .stab         00004195 00000000f0101e54 DATA\n  4 .stabstr      0000194b 00000000f0105fe9\n  5 .data         0000a300 00000000f0108000 DATA\n  6 .bss          00000648 00000000f0112300 DATA\n  7 .comment      00000011 0000000000000000\n  8 .debug_info   00001811 0000000000000000\n  9 .debug_abbrev 00000486 0000000000000000\n 10 .debug_loc    00000eef 0000000000000000\n 11 .debug_aranges 00000040 0000000000000000\n 12 .debug_ranges 00000070 0000000000000000\n 13 .debug_line   000006fc 0000000000000000\n 14 .debug_str    00000b87 0000000000000000\n 15 .symtab       000006b0 0000000000000000\n 16 .strtab       00000343 0000000000000000\n 17 .shstrtab     000000a5 0000000000000000\n---\n此处仍然略去了symbol table\n---\nProgram Header:\n    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12\n         filesz 0x00007934 memsz 0x00007934 flags r-x\n    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12\n         filesz 0x0000a948 memsz 0x0000a948 flags rw-\n\nDynamic Section:\n```\n\n我们可以看到最后几行的program header程序头，需要被加载到内存中的区域已经被标记为LOAD，所有程序头的信息都已经被给出，比如vaddr（虚拟地址）以及paddr（物理地址）。\n\n这里保留一个疑惑：记不记得我们之前通过gdb调试的时候，call指令交给kernal接管操作系统的地址是`0x10000c`，为什么这里LOAD的是`0x100000`？\n\n**exercise5:**\n\n这次我们魔改一下`boot/Makefrag`，我们手动把链接到的.text地址改成一个错误的地址，然后运行指令`make clean`，我们再启动qemu，看看瞎引导会发生什么后果。\n\n![image-20200303160457185](https://tva1.sinaimg.cn/large/00831rSTly1gcgsvs038rj30dz02v74f.jpg)\n\n我们把这个0x7c00给他改了：\n\n![image-20200303161125681](https://tva1.sinaimg.cn/large/00831rSTly1gcgt2ioj44j30os09lq5l.jpg)\n\n谢谢，有被秀到。整个引导因为错误，提前中止了。\n\n然后我们似乎忘记了另一个地址：link address。这就是ELF header中另一个很重要的内容：e_entry。这标记了程序入口点：程序段中程序开始执行的入口内存地址，\n\n我们使用`objdump -f obj/kern/kernel`：\n\n```\nobj/kern/kernel:\tfile format ELF32-i386\n\narchitecture: i386\nstart address: 0x0010000c\n```\n\n这就把上文的疑惑解决了，因为上文的地址是.text段的起始地址，而真正开始执行的地址则是link address。\n\n**exercise 6:**\n\n这波啊，这波我们在之前已经知道kernal加载的内存地址了，我们在BIOS启动过程中就用gdb的`x/Nx addr`指令查看一下从0x10000开始的位置。\n\n然后再次，我们将BootLoader加载kernal之后再使用同样的指令，看看有什么区别没。\n\n我们先直接在引导过程就使用指令查看：\n\n![image-20200303162511445](https://tva1.sinaimg.cn/large/00831rSTly1gcgtgu4kwgj315d034dgo.jpg)\n\n然后我们等执行到bootmain交给kernal接管时，再次使用指令：\n\n![image-20200303163342172](https://tva1.sinaimg.cn/large/00831rSTly1gcgtpoyrnhj30f204c74q.jpg)\n\n懂得都懂，因为BootLoader本身就是把kernal加载到内存中，所以第二次使用指令查看到的就是加载kernal之后的有效内存。我们甚至可以继续看看kernel.asm：\n\n![image-20200303163523218](https://tva1.sinaimg.cn/large/00831rSTly1gcgtrg363nj30c101ea9z.jpg)\n\n看看这个entry的机器码，是不是和0x10000c处的0x7205c766指令对上了？\n\n\n\n## Part 3: The Kernel\n\n\n\n### 3.1 Using virtual memory to work around position dependence\n\n当你观察了链接器加载的内存，你发现内核实际上将自己链接到了非常高的虚拟地址，比如0xf010000，为了将处理器虚拟地址的较低部分交给用户的程序去使用。这个现象将在下一个实验中被介绍。\n\n而实际上，许多机器在物理内存中并没有0xf0100000这样的高地址。也就是说，处理器的内存管理硬件将虚拟地址0xf0100000映射到了实际内存中的物理地址0x0010000（BootLoader将kernel加载到的物理内存）。\n\n在`kern/entry.S`将CR0_FG进行标记之前（还记着这个标志位吗？开保护模式用的），我们的内存引用被当作线性地址。实际上由于`boot/boot.S`设置了线性地址到物理地址的一致映射，我们可以认为线性地址就等同于物理地址。\n\n当CR0_FG被标记之后，所有的内存就是虚拟地址了。虚拟地址通过虚拟内存硬件被翻译成物理地址。\n\n`kern/entrypgdir.c`将0xf0000000-0xf0400000的虚拟地址翻译为物理地址的0x00000000-0x00400000，同时也将0x00000000-0x00400000的虚拟地址翻译为0x00000000-0x00400000。\n\n引用这些范围以外的虚拟地址就会抛出缺页异常。但是现在我们还没有为该异常设置中断程序，所以这就会导致qemu直接退出。\n\n**exercise 7:**\n\n使用qemu和gdb追踪kernel然后停留在`movl %eax, %cr0`。然后此时检查地址0x00100000和0xf0100000。使用`si`指令前进一步再次检查这两个地址。\n\n我们先停留到标记cr0之前进行检查：\n\n![image-20200303170039419](https://tva1.sinaimg.cn/large/00831rSTly1gcguhqethvj30bg057t96.jpg)\n\n\n\n我们看出，此时还没有设置cr0也就是虚拟内存管理硬件并没有将0xf0100000进行映射。\n\n然后执行下一步再次查看：\n\n![image-20200303170133220](https://tva1.sinaimg.cn/large/00831rSTly1gcguio4zokj30f003b3ys.jpg)\n\n确实，这时页表已经启动了，地址映射就此完成。\n\n\n\n### 3.2 Formatted Printing to the Console\n\n这里我们需要了解print()是如何在底层实现的。\n\n首先我们要阅读`kern/printf.c`, `lib/printfmt.c`以及`kern/console.c`。理解一下他们之间的关系。\n\n**exercise 8:**\n\n我们需要补全未完成的 print \"%o\"格式，其实很简单，只要参照上面的\"%d\"即可，注意这里我们处理的是无符号数。\n\n```c\n\t\tcase 'o':\n\t\t\t// Replace this with your code.\n//\t\t\tputch('X', putdat);\n//\t\t\tputch('X', putdat);\n//\t\t\tputch('X', putdat);\n            num = getuint(&ap, lflag);\n            base = 8;\n            goto number;\n\t\t\tbreak;\n```\n\n同时我们需要理解这些文件之间的关系。\n\n1. printf.c以及console.c之间的关系是什么？同时console.c导出的函数是什么，且如何被printf.c使用？\n\nconsole.c是由kernel使用了一系列I/O序列号，提供了基本的I/O操作，然后同时封装了cputchar()、getchar()等函数用于提供printf.c中printf的使用。printf使用了vprintfmt去解析格式化字符串并且提供可变参数的特性。\n\nprint.c的调用链：`cprintf -> vcprintf -> vprintfmt -> putch -> cputchar`。\n\n2. console.c中如下的代码含义？\n\n```c\n//一页写满，滚动一行\nif (crt_pos >= CRT_SIZE) {\n       \tint i;\n  \t// 把从第1~n行的内容复制到0~(n-1)行，第n行未变化\n    // 通过这一行代码完成了整个屏幕向上移动一行的操作。\n        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));\n  \t// 把最后一行清空\n        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)\n            crt_buf[i] = 0x0700 | ' ';\n  \t// 清空了最后一行，同步crt_pos\n        crt_pos -= CRT_COLS;\n    }\n```\n\n3. For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.\n\n单步执行以下代码：\n\n```c\nint x = 1, y = 3, z = 4;\ncprintf(\"x %d, y %x, z %d\\n\", x, y, z);\n```\n\n这里我们需要在`/kern/monitor.c`的monitor函数中插入这段代码。\n\ntips：GNUmakefile中的C_FLAGS -O1优化会重排C代码，这样的话一会儿单步执行时追踪va_arg会变得非常困难，在此处将-O1先变为-O0（尽管这会导致backtrace时的kernal panic）。\n\n![image-20200303182914110](https://tva1.sinaimg.cn/large/00831rSTly1gcgx1wqqppj30ui05gznq.jpg)\n\n配置好之后，我们直接开始在`b kern/monitor.c:118`打断点（别问，就是可以这样断点）\n\n![image-20200303183912619](https://tva1.sinaimg.cn/large/00831rSTly1gcgxcadv6jj30db07o75a.jpg)\n\n我们现在就进入va_start(ap, fmt)。\n\n```\ncprintf(\"x %d, y %x, z %d\\n\",x, y, z);\ncprintf (fmt=0xf0101aae \"x %d, y %x, z %d\\n\") at kern/printf.c:31\nva_start(ap, fmt)\nvcprintf (fmt=0xf0101aae \"x %d, y %x, z %d\\n\", ap=0xf010ff64 \"\\001\") at kern/printf.c:19\n\n(gdb) x/1x 0xf010ff64\n0xf010ff64:\t0x00000001\n```\n\n可见fmt就是我们的格式化字符串\"x %d, y %x, z %d\\n\"，ap指向了局部变量0xf010ff64初始为1。\n\n为了保证接下来的过程能够理解清楚，我们需要了解cprintf()函数里面的一系列调用：\n\n```c\ncprintf(const char *fmt, ...)\n{\n        va_list ap;\n        int cnt;\n        va_start(ap, fmt);\n        cnt = vcprintf(fmt, ap);\n        va_end(ap);\n        return cnt;\n}\n```\n\n要注意这个va_start等va_开头的都是一个宏里面的内容：\n\n```c\ntypedef __builtin_va_list va_list;\n#define va_start(ap, last) __builtin_va_start(ap, last)\n#define va_arg(ap, type) __builtin_va_arg(ap, type)\n#define va_end(ap) __builtin_va_end(ap)\n```\n\n这个宏已经由gcc提供了，我们要阅读代码知道这个宏的作用：\n\n```c\n// 指针定义为char *可以指向任意一个内存地址。\ntypedef char *va_list;\n// 类型大小，注意这里是与CPU位数对齐 ＝ sizeof(long)的作用。\n#define    __va_size(type) \\\n    (((sizeof(type) + sizeof(long) - 1) / sizeof(long)) * sizeof(long))\n\n// 这里个宏并不是取得参数的起始地址。而是说参数将从什么地址开始放。\n#define    va_start(ap, last) \\\n    ((ap) = (va_list)&(last) + __va_size(last))\n\n// va_arg就是用来取参数的起始地址的。然后返回type类型。\n// 从整个表达式的意义来说没有什么好用的。\n// 其实等价于(*(type*)ap)\n// 但是实际上使ap指针移动一个参数大小。\n#define    va_arg(ap, type) \\\n    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))\n\n// 空指令，没有什么用\n#define    va_end(ap)    ((void)0)\n```\n\n所以实际上该操作就是栈操作，从高地址向低地址压栈，并且压栈的时候类型与long对齐，就是说即使压入一个char，我们也要对栈空间以long的大小进行对齐。压入5个char = 需要两个long的空间。\n\n所以回到原来的代码，fmt就是指向const char * 我们的格式化字符串，开始调用时栈结构如下：\n\n```c\n+-----------------+\n|                 |\n|     Z           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     Y           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     X           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     fmt         |\n|                 |\n|                 |\n+-----------------+ <-----------+&fmt\n\n```\n\n然后接下来cprintf需要调用va_start()：\n\n```c\nva_start(fmt, ap) 作用如下\n#define    va_start(ap, last) \\\n    ((ap) = (va_list)&(last) + __va_size(last))\n展开就是\nap = (char *)(&fmt) + align_long(fmt);\n+-----------------+\n|                 |\n|     Z           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     Y           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     X           |\n|                 |\n|                 |\n+-----------------+ <--------------+ap\n|                 |\n|     fmt         |\n|                 |\n|                 |\n+-----------------+\n```\n\n然后进一步调用vcprint至vprintfmt到输出\n\n```c\nvoid\nvprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)\n{\n    while (1) {\n        // 如果只是一般的字符串，直接输出。\n        while ((ch = *(unsigned char *) fmt++) != '%') {\n            if (ch == '\\0')\n                return;\n            putch(ch, putdat);\n        }\n        // 如果发现是%c\n    reswitch:\n        // 先把%号跳掉，取出'c'\n        switch (ch = *(unsigned char *) fmt++) {\n        // .. \n        case 'c':\n            putch(va_arg(ap, int), putdat);\n            break;\n        }\n    }\n}\n```\n\n我们就明白了，根据当前参数栈的位置，通过fmt解析出参数的类型，拿出特定长度的参数。就是这样。\n\n接下来的过程只是逐步重复：\n\n```c\nva_arg(ap, int) 展开后就是\n#define    va_arg(ap, type) \\\n    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))\n// putat用来统计输出的字符的个数。在这里可以不用去管\nchar temp = *(char*)ap;\nputch(temp, putdat); // 输出到console上。\nap += align_long(char);\n执行完成之后。\n+-----------------+\n|                 |\n|     Z           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     Y           |\n|                 |\n|                 |\n+-----------------+ <------+ap\n|                 |\n|     X           |   这个x会被%d提出来进行输出。\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     fmt         |\n|                 |\n|                 |\n+-----------------+\n```\n\n这样我们就明白了实际上是如何调用的。\n\n4. 运行以下代码，会输出什么：\n\n```c\nunsigned int i = 0x00646c72;\ncprintf(\"H%x Wo%s\", 57616, &i);\n-----------------------------------------------------------------------------------\n57616 = 0xE110。\ni = 0x00646c72\n//那么如果把i占用的4byte转换成为char[4]数组。结果就是：\nchar str[4] = {0x72, 0x6c, 0x64, 0x00}; // = {'r', 'l', 'd', 0}\n//所以输出就是\nHell0 World\n```\n\n5. cprintf(\"x=%d y=%d\", 3) 该代码的输出？\n\n这种栈越界行为，显然无法判定操作，因为不知道越界位置的内存放的是什么内容。\n\n\n\n### 3.3 The Stack\n\n在这个环节中，我们将了解x86程序对于堆栈的使用。\n\n**exercise 9:**\n\n确定内核堆栈初始化的位置，以及堆栈在内存中的确切位置。内核如何为其堆栈保留空间？并在此保留区的哪个“末端”初始化堆栈指针指向？\n\n这就又回到kernel了，我们看一下kernel的代码过程中配置%esp的部分：\n\n![image-20200303195812344](https://tva1.sinaimg.cn/large/00831rSTly1gcgzmh0a76j30e907x75i.jpg)\n\n```assembly\nf0100034:\tbc 00 00 11 f0       \tmov    $0xf0110000,%esp\n```\n\n也就是这一条指令初始化了栈指针。\n\n栈指针`esp`寄存器指向当前栈的栈顶（低地址），栈顶的下面（更低的地址）都是栈的可用空间。push和pop就对应着esp指针的变化。\n\n相比之下`ebp`寄存器主要通过软件约定与堆栈进行关联。也就是C函数调用时其初始总是将前一个函数的base pointer压入栈中，然后使用ebp来拷贝此时的esp之后，再让栈空间以及esp进行变化。\n\n关于调用栈仍然没必要详细介绍了，这个还是需要阅读\"CSAPP\"第三章关于栈的内容。\n\n**exercies 10:**\n\n为了更加熟悉x86中C的函数调用和栈帧，我们在`obj/kern/kernel.asm`中的test_backtrace函数设置一个端点，检查内核每一次启动后调用它会发生什么。每个递归嵌套的test_backtrace嵌套级别将多少个32位字压栈？这些字是什么？\n\n我们先找到kernel中`test_backtrace`的位置：\n\n![image-20200303201438802](https://tva1.sinaimg.cn/large/00831rSTly1gch03m6rnhj30dt022dfz.jpg)\n\n然后在该起始地址0xf0100040处打断点。使用`info frame`查看栈：\n\n```assembly\n(gdb) info frame\nStack level 0, frame at 0xf010ffe0:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf01000d4\n called by frame at 0xf0110000\n source language c.\n Arglist at 0xf010ffd8, args: x=5\n Locals at 0xf010ffd8, Previous frame's sp is 0xf010ffe0\n Saved registers:\n  eip at 0xf010ffdc\n ----------------------------------------------------------------------------------\n (gdb) info frame\nStack level 0, frame at 0xf010ffc0:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf0100068\n called by frame at 0xf010ffe0\n source language c.\n Arglist at 0xf010ffb8, args: x=4\n Locals at 0xf010ffb8, Previous frame's sp is 0xf010ffc0\n Saved registers:\n  eip at 0xf010ffbc\n ----------------------------------------------------------------------------------\n (gdb) info frame\nStack level 0, frame at 0xf010ffa0:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf0100068\n called by frame at 0xf010ffc0\n source language c.\n Arglist at 0xf010ff98, args: x=3\n Locals at 0xf010ff98, Previous frame's sp is 0xf010ffa0\n Saved registers:\n  eip at 0xf010ff9c\n  ---------------------------------------------------------------------------------\n  (gdb) info frame\nStack level 0, frame at 0xf010ff80:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf0100068\n called by frame at 0xf010ffa0\n source language c.\n Arglist at 0xf010ff78, args: x=2\n Locals at 0xf010ff78, Previous frame's sp is 0xf010ff80\n Saved registers:\n  eip at 0xf010ff7c\n  ---------------------------------------------------------------------------------\n  (gdb) info frame\nStack level 0, frame at 0xf010ff60:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf0100068\n called by frame at 0xf010ff80\n source language c.\n Arglist at 0xf010ff58, args: x=1\n Locals at 0xf010ff58, Previous frame's sp is 0xf010ff60\n Saved registers:\n  eip at 0xf010ff5c\n  ---------------------------------------------------------------------------------\n  (gdb) info frame\nStack level 0, frame at 0xf010ff40:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf0100068\n called by frame at 0xf010ff60\n source language c.\n Arglist at 0xf010ff38, args: x=0\n Locals at 0xf010ff38, Previous frame's sp is 0xf010ff40\n Saved registers:\n  eip at 0xf010ff3c\n```\n\n本题考察了x86架构下的栈帧与函数调用。有一说一，每次到栈帧我都要重学一遍。\n\n#### >> 函数调用\n\n函数调用分为以下几步:\n\n- 参数入栈: 将参数按照调用约定(C 是从右向左)依次压入系统栈中;\n\n- 返回地址入栈: 将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行;\n\n- 代码跳转: 处理器将代码区跳转到被调用函数的入口处;\n\n- 栈帧调整:  \n\n  1.将调用者的ebp压栈处理，保存指向**调用者栈底**的ebp的地址（方便函数返回之后的现场恢复），此时esp指向新的栈顶位置； `push ebp` \n  2.将当前栈帧切换到新栈帧(将eps值装入ebp- `mov esp, ebp`更新栈帧底部为**被调用者栈底**)\n  3.给新栈帧分配空间 `sub esp, XXX`（这些空间用于临时变量，操作时用ebp-x存取）\n\n#### >> 函数返回\n\n函数返回分为以下几步:\n\n- 保存被调用函数的返回值到 eax 寄存器中 `mov eax, xxx`\n- 恢复 esp 同时回收局部变量空间 `mov ebp, esp`\n- 将上一个栈帧底部位置恢复到 ebp `pop ebp`\n- 弹出当前栈顶元素,从栈中取到返回地址,并跳转到该位置 `ret`\n\n**exercise 11:**\n\n阅读完上述代码后，在`kern/monitor.c`中实现一个`mon_backtrace()`函数。请使用`inc/x86.h`中的`read_ebp()`。我们要先阅读`obj/kern/kernel.asm`中注意到，初始的ebp分配为0:\n\n![image-20200303214913263](https://tva1.sinaimg.cn/large/00831rSTly1gch2tzr5k6j30do028q34.jpg)\n\n```c\nint\nmon_backtrace(int argc, char **argv, struct Trapframe *tf)\n{\n\t// Your code here.\n\tuint32_t ebp = read_ebp();\n\t#define TO_INT(x) *((uint32_t *)(x))\n\twhile(ebp){\n\t\tcprintf(\"ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\\n\",\n\t\t\t\tTO_INT(ebp),\t\t /*ebp*/\n\t\t\t\tTO_INT((ebp + 4)),   /*eip*/\n\t\t\t\tTO_INT((ebp + 8)),   /*arg1*/\n\t\t\t\tTO_INT((ebp + 12)),  /*arg2*/\n\t\t\t\tTO_INT((ebp + 16)),  /*arg3*/\n\t\t\t\tTO_INT((ebp + 20)),  /*arg4*/\n\t\t\t\tTO_INT((ebp + 24))); /*arg5*/\n\t\tebp = TO_INT(ebp);\n\t}\n\treturn 0;\n}\n```\n\n重新make观察qemu的输出即可。\n\n![image-20200303215034236](https://tva1.sinaimg.cn/large/00831rSTly1gch2ve0p0lj30k00bq74v.jpg)\n\n\n\n**exercise 12:**\n\n这次我们需要修改`stack backtrace`函数，让它显示每一个`eip, func_name, source_file_name, line_number`。为了帮助实现这些功能，在`kern/kdebug.c`中已经实现了一个函数`debuginfo_eip()`，这个函数能够查找eip的符号表然后返回关于该地址的debug信息。\n\n1. 在实现好的debuginfo_eip()中，`__STAB_*`这些信息是从哪来的？\n\n- look in the file `kern/kernel.ld` for `__STAB_*`\n\n我们找到了链接脚本\n\n```\n.stab : {\n\t\tPROVIDE(__STAB_BEGIN__ = .);\n\t\t*(.stab);\n\t\tPROVIDE(__STAB_END__ = .);\n\t\tBYTE(0)\t\t/* Force the linker to allocate space\n\t\t\t\t   for this section */\n\t}\n\n\t.stabstr : {\n\t\tPROVIDE(__STABSTR_BEGIN__ = .);\n\t\t*(.stabstr);\n\t\tPROVIDE(__STABSTR_END__ = .);\n\t\tBYTE(0)\t\t/* Force the linker to allocate space\n\t\t\t\t   for this section */\n\t}\n```\n\n`__STAB_BEGIN__,__STAB_END__, __STABSTR_BEGIN__, __STABSTR_END__`等符号均在kern/kern.ld文件定义，它们分别代表.stab和.stabstr这两个段开始与结束的地址。\n\n- run objdump -h obj/kern/kernel (`-h`是显示头部摘要)\n\n```\nobj/kern/kernel:\tfile format ELF32-i386\n\nSections:\nIdx Name          Size      Address          Type\n  0               00000000 0000000000000000\n  1 .text         000017b2 00000000f0100000 TEXT\n  2 .rodata       00000758 00000000f01017c0 DATA\n  3 .stab         00004285 00000000f0101f18 DATA\n  4 .stabstr      00001956 00000000f010619d\n  5 .data         0000a300 00000000f0108000 DATA\n  6 .bss          00000648 00000000f0112300 DATA\n  7 .comment      00000011 0000000000000000\n  8 .debug_info   00001811 0000000000000000\n  9 .debug_abbrev 00000486 0000000000000000\n 10 .debug_loc    00000eef 0000000000000000\n 11 .debug_aranges 00000040 0000000000000000\n 12 .debug_ranges 00000070 0000000000000000\n 13 .debug_line   000006fc 0000000000000000\n 14 .debug_str    00000b87 0000000000000000\n 15 .symtab       000006b0 0000000000000000\n 16 .strtab       00000343 0000000000000000\n 17 .shstrtab     000000a5 0000000000000000\n```\n\n在这里我们看到了Idx为4的.stabstr段\n\n- run objdump -G obj/kern/kernel （只显示部分）\n\n```\nobj/kern/kernel:     file format elf32-i386\nContents of .stab section:\nSymnum n_type n_othr n_desc n_value  n_strx String\n-1     HdrSym 0      1294   00001973 1\n0      SO     0      0      f0100000 1      {standard input}\n1      SOL    0      0      f010000c 18     kern/entry.S\n2      SLINE  0      44     f010000c 0\n15     OPT    0      0      00000000 49     gcc2_compiled.\n16     LSYM   0      0      00000000 64     int:t(0,1)=r(0,1);-2147483648;2147483647;\n17     LSYM   0      0      00000000 106    char:t(0,2)=r(0,2);0;127;\n108    FUN    0      0      f0100040 2946   test_backtrace:F(0,25)\n118    FUN    0      0      f01000a6 2987   i386_init:F(0,25)\n```\n\n\n\n- run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.\n\n```\n.file   \"init.c\"\n.stabs  \"kern/init.c\",100,0,2,.Ltext0\n.text\n.Ltext0:\n.stabs  \"gcc2_compiled.\",60,0,0,0\n.stabs  \"int:t(0,1)=r(0,1);-2147483648;2147483647;\",128,0,0,0\n.stabs  \"char:t(0,2)=r(0,2);0;127;\",128,0,0,0\n.stabs  \"long int:t(0,3)=r(0,3);-0;4294967295;\",128,0,0,0\n.stabs  \"unsigned int:t(0,4)=r(0,4);0;4294967295;\",128,0,0,0\n.stabs  \"long unsigned int:t(0,5)=r(0,5);0;-1;\",128,0,0,0\n.stabs  \"long double:t(0,16)=r(0,1);16;0;\",128,0,0,0\n.stabs  \"_Float32:t(0,17)=r(0,1);4;0;\",128,0,0,0\n.stabs  \"ssize_t:t(4,17)=(4,8)\",128,0,0,0\n.stabs  \"off_t:t(4,18)=(4,8)\",128,0,0,0\n.stabn  162,0,0,0\n.stabn  162,0,0,0\n.section    .rodata.str1.1,\"aMS\",@progbits,1\n.LC0:\n.string \"entering test_backtrace %d\\n\"\n.LC1:\n.string \"leaving test_backtrace %d\\n\"\n.text\n.p2align 4,,15\n.stabs  \"test_backtrace:F(0,25)\",36,0,0,test_backtrace\n.stabs  \"x:P(0,1)\",64,0,0,3\n.globl  test_backtrace\n.type   test_backtrace, @function\ntest_backtrace:\n.stabn  68,0,13,.LM0-.LFBB1\n```\n\n- see if the bootloader loads the symbol table in memory as part of loading the kernel binary\n\n我们如何确认BootLoader加载内核的时候是否把符号表加载进内存呢？\n\n首先使用`objdump -x obj/kern/kernel`查看符号表（节选） 以及地址\n\n```\nf0101f18 l    d  .stab\t\t 00000000 .stab\nf010619d l    d  .stabstr\t\t 00000000 .stabstr\n\nProgram Header:\n    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12\n         filesz 0x00007af3 memsz 0x00007af3 flags r-x\n    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12\n         filesz 0x0000a948 memsz 0x0000a948 flags rw-\n```\n\n只要用gdb查看符号表的地址位置是否储存了符号表信息即可。\n\n```\n(gdb) x/8s 0x10619d      <---注意这个地址！因为这里我自己还没执行到entry.s的标记cr0地址映射\n0x10619d:\t\"\"\n0x10619e:\t\"{standard input}\"\n0x1061af:\t\"kern/entry.S\"\n0x1061bc:\t\"kern/entrypgdir.c\"\n0x1061ce:\t\"gcc2_compiled.\"\n0x1061dd:\t\"int:t(0,1)=r(0,1);-2147483648;2147483647;\"\n0x106207:\t\"char:t(0,2)=r(0,2);0;127;\"\n0x106221:\t\"long int:t(0,3)=r(0,3);-2147483648;2147483647;\"\n-----------------------------------------------------------------------------------\n为了不让大家产生误会：执行完entry.S再打印：\n(gdb) si\n=> 0x100025:\tmov    %eax,%cr0\n0x00100025 in ?? ()\n(gdb) si\n(gdb) x/8s 0xf010619d\n0xf010619d:\t\"\"\n0xf010619e:\t\"{standard input}\"\n0xf01061af:\t\"kern/entry.S\"\n0xf01061bc:\t\"kern/entrypgdir.c\"\n0xf01061ce:\t\"gcc2_compiled.\"\n0xf01061dd:\t\"int:t(0,1)=r(0,1);-2147483648;2147483647;\"\n0xf0106207:\t\"char:t(0,2)=r(0,2);0;127;\"\n0xf0106221:\t\"long int:t(0,3)=r(0,3);-2147483648;2147483647;\"\n```\n\n2. debuginfo_eip函数实现根据地址寻找行号的功能：\n\n熟悉stabs每行记录的含义，我折腾了一两小时才搞清楚。首先，使用`objdump -G obj/kern/kernel > output.md`将内核的符号表信息输出到output.md文件，在output.md文件中可以看到以下片段：\n\n```\nSymnum n_type n_othr n_desc n_value  n_strx String\n118    FUN    0      0      f01000a6 2987   i386_init:F(0,25)\n119    SLINE  0      24     00000000 0\n120    SLINE  0      34     00000012 0\n121    SLINE  0      36     00000017 0\n122    SLINE  0      39     0000002b 0\n123    SLINE  0      43     0000003a 0 \n```\n\n这个片段是什么意思呢？首先要理解第一行给出的每列字段的含义：\n\n- Symnum是符号索引，换句话说，整个符号表看作一个数组，Symnum是当前符号在数组中的下标\n- n_type是符号类型，FUN指函数名，SLINE指在text段中的行号\n- n_othr目前没被使用，其值固定为0\n- n_desc表示在文件中的行号\n- n_value表示地址。特别要注意的是，这里只有FUN类型的符号的地址是绝对地址，SLINE符号的地址是偏移量，其实际地址为函数入口地址加上偏移量。比如第3行的含义是地址f01000b8(=0xf01000a6+0x00000012)对应文件第34行。\n\n这样，调用stab_binsearch就可以找到某个地址对应的行号了，前面的代码已经找到地址在哪个函数里面以及函数入口地址，将原地址减去函数入口地址即可得到偏移量，再根据偏移量在符号表中的指定区间查找对应的记录即可：\n\n```c\n// Search the entire set of stabs for the source file (type N_SO).\n\tlfile = 0;\n\trfile = (stab_end - stabs) - 1;\n\tstab_binsearch(stabs, &lfile, &rfile, N_SO, addr);\n\tif (lfile == 0)\n\t\treturn -1;\n\n\t// Search within that file's stabs for the function definition\n\t// (N_FUN).\n\tlfun = lfile;\n\trfun = rfile;\n\tstab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);\n\n\tif (lfun <= rfun) {\n\t\t// stabs[lfun] points to the function name\n\t\t// in the string table, but check bounds just in case.\n\t\tif (stabs[lfun].n_strx < stabstr_end - stabstr)\n\t\t\tinfo->eip_fn_name = stabstr + stabs[lfun].n_strx;\n\t\tinfo->eip_fn_addr = stabs[lfun].n_value;\n\t\taddr -= info->eip_fn_addr;\n\t\t// Search within the function definition for the line number.\n\t\tlline = lfun;\n\t\trline = rfun;\n\t} else {\n\t\t// Couldn't find function stab!  Maybe we're in an assembly\n\t\t// file.  Search the whole file for the line number.\n\t\tinfo->eip_fn_addr = addr;\n\t\tlline = lfile;\n\t\trline = rfile;\n\t}\n```\n\n3. 给我们的内核模拟器增加backtrace命令。\n\n* `kern/monitor.c`文件中，仿照已有命令进行添加即可。\n\n```c\nstatic struct Command commands[] = {\n\t{ \"help\", \"Display this list of commands\", mon_help },\n\t{ \"kerninfo\", \"Display information about the kernel\", mon_kerninfo },\n\t{ \"backtrace\", \"Display a backtrace of the function stack\", mon_backtrace}\n};\n```\n\n* 给`mon_backtrace`增加打印文件名、函数名、行号功能。\n\n根据之前的源代码阅读，我们只需要调用`debugingo_eip`来获取文件名、函数名、行号。\n\n```c\nmon_backtrace(int argc, char **argv, struct Trapframe *tf)\n{\n\t// Your code here.\n\tuint32_t ebp = read_ebp();\n\tuint32_t eip;\n\tstruct Eipdebuginfo info;\n#define TO_INT(x) *((uint32_t *)(x))\n\twhile(ebp){\n\t\tcprintf(\"ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\\n\",\n\t\t\t\tTO_INT(ebp),\t\t /*ebp*/\n\t\t\t\tTO_INT((ebp + 4)),   /*eip*/\n\t\t\t\tTO_INT((ebp + 8)),   /*arg1*/\n\t\t\t\tTO_INT((ebp + 12)),  /*arg2*/\n\t\t\t\tTO_INT((ebp + 16)),  /*arg3*/\n\t\t\t\tTO_INT((ebp + 20)),  /*arg4*/\n\t\t\t\tTO_INT((ebp + 24))); /*arg5*/\n\t\teip = TO_INT((ebp + 4));\n\t\tdebuginfo_eip(eip, &info);\n\t\tcprintf(\"     %s:%d: %.*s+%d\\n\", info.eip_file, info.eip_line,\n\t\t\t\tinfo.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);\n\t\tebp = TO_INT(ebp);\n\t}\n\treturn 0;\n}\n```\n\n* 补充debuginfo_eip()：\n\n表示行号的成员是n_desc，所以缺失的代码如下：\n\n```c\n\t// Search within [lline, rline] for the line number stab.\n\t// If found, set info->eip_line to the right line number.\n\t// If not found, return -1.\n\t//\n\t// Hint:\n\t//\tThere's a particular stabs type used for line numbers.\n\t//\tLook at the STABS documentation and <inc/stab.h> to find\n\t//\twhich one.\n\t// Your code here.\n\tstab_binsearch(stabs, &lline, &rline, N_SLINE, addr);\n\tif (lline <= rline)\n\t{\n\t\tinfo->eip_line = stabs[lline].n_desc;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n```\n\n一切就绪后我们运行我们的monitor：\n\n![image-20200303233338466](https://tva1.sinaimg.cn/large/00831rSTly1gch5umxyf1j30fz07lmzg.jpg)\n\n大功告成，舒服了。\n\n\n\n## 感想\n\n不去做jos扬名立万，搁那儿画啥GUI？\n\n","tags":["operating system"]},{"title":"Memory Forensics","url":"/2020/03/01/memfor/","content":"\n# Memory Forensics\n\n## Basic Knowledge\n\n* PAE: physical adress extension\n* AS: Address spaces is an interface that provides flexible and consistent accsee to data in RAM.\n* _KDDEBUGGER_DATA64: characteristics of the kernel debugger data block .\n\n```c\ntypedef struct _DBGKD_DEBUG_DATA_HEADER64 { \n\t\tLIST_ENTRY64 List; \n\t\tULONG OwnerTag; \n\t\tULONG Size; \n}\n```\n\nWindows keeps a store of some useful global variables in a structure called **_KDDEBUGGER_DATA64**. This information is used by the microsoft kernel debugger in order to bootstap the analysis of a crash dump.\n\n## Volatility\n\n### selecting a profile\n\nIn some cases that you don't know the profile ahead of time, volatility includes two plugins that can help you determine the proper profile.(Windows only)\n\n1. `imageinfo`\n\ninstruction: `python vol.py -f [filename] imageinfo`\n\n![image-20200306172125272](https://tva1.sinaimg.cn/large/00831rSTly1gckby9o9q2j30ng0c23z7.jpg)\n\n> it also shows you the date and time when the memory sample was collected, the number of CPUS, some characteristics of the AS, such as whether PAE is enabled; and the directory table base (DTB) value used for address translation.\n\n2. kdbgscan\n\ninstruction: `python vol.py -f [filename] kdbgscan`\n\nThe name of the plugin gives you an idea of how the potential profiles are guessed: It finds and analyzes characteristics of the kernel debugger data block (_KDDEBUGGER_DATA64).\n\n![image-20200306173632863](https://tva1.sinaimg.cn/large/00831rSTly1gckcdzzmjhj30mc0j0myc.jpg)\n\n------\n\nNow, you may supply `--profile=WinXPSP3x86` when running other plugins.\n\n## Memory Dump Formats\n\nThe volatility franeworks also provides several plugins, for exploring the metadara associated with many of the common file formats:\n\n![image-20200306195815213](https://tva1.sinaimg.cn/large/00831rSTly1gckghgcb5rj30q509q75x.jpg)\n\n\n\n### > Raw Memory Dump\n\n* The most widely supported format among analysis tools. \n* Does not contain any headers, metadata, or magic values for file type identification.\n* typically includes padding for any memory ranges that were intentionally skipped (i.e., device memory) or that could not be read by the acquisition tool, which helps maintain spatial integrity (relative offsets among data).\n\n### > Windows Crash Dump\n\nThis file format was designed for debugging purposes. It begins with a `_DMP_HEADER` structure. 》 \n\n> The header identifies the major and minor OS version, the kernel DTB(Directory  Table Base), the address of the active process and loaded kernel module list heads, and information on the physical memory runs.\n\n![image-20200306200642283](https://tva1.sinaimg.cn/large/00831rSTly1gckgq8q2mkj30o90d3goe.jpg)\n\n### > Windows Hibernation File\n\nA hibernation file (hiberfil.sys) contains a compressed copy of memory that the system dumps to disk during the hibernation process.\n\n> Hibernation files consist of a standard header (PO_MEMORY_IMAGE), a set of kernel contexts and registers such as CR3, and several arrays of compressed data blocks.\n\nAn example of the hibernation file header:\n\n![image-20200306202051606](https://tva1.sinaimg.cn/large/00831rSTly1gckh508ml5j30lg08mdh7.jpg)\n\n### > Virtual Machine Memory\n\nTo acquire memory from a VM, you can run one of the aforementioned software tools within the guest OS (VM) or you can perform the acquisition from the hypervisor. \n\n\n\n## Windows Objects and Pool Allocations\n\n### > Windows Executive Objects\n\nWindows is written in C and makes heavy use of C structures to organize related data and attributes. Several of these structures are called executive objects because they are managed (created, protected, deleted, etc.) by the Windows Object Manager—a component of the kernel implemented by the NT module.\n\n> All executive objects are structures, but not all structures are executive objects.\n\nThe most forensically relevant executive objects types are described below:\n\n![image-20200306205927113](https://tva1.sinaimg.cn/large/00831rSTly1gcki94tb52j30mr0mbdji.jpg)\n\n![image-20200306205941411](https://tva1.sinaimg.cn/large/00831rSTly1gcki9dg2blj30mr0700ts.jpg)\n\n### > Object Headers\n\n* One of the common traits shared between all executive object types is the presence of an object header (` _OBJECT_HEADER`)\n* The object header immediately precedes the executive object structure in memory.\n\nFinding the structure (i.e.,`_FILE_OBJECT` in the figure) given the address of its `_OBJECT_HEADER`, or vice versa, is simple because the two are always directly adjacent; and the size of `_OBJECT_HEADER` is consistent per operating system.\n\n![image-20200306210659152](https://tva1.sinaimg.cn/large/00831rSTly1gckigz0i1sj30lr0ggjte.jpg)\n\n![image-20200306210737514](https://tva1.sinaimg.cn/large/00831rSTly1gckihmt5gnj30j40bhgmy.jpg)\n\n* `PointerCount`: Contains the total number of pointers to the object, including kernelmode references.\n\n* `HandleCount`: Contains the number of open handles to the object.\n\n* `TypeIndex`: This value tells you what type of object you’re dealing with (e.g., process, thread, file).\n\n* `InfoMask`: This value tells you which of the optional headers, if any, are present. SecurityDescriptor: Stores information on the security restrictions for the object, such as which users can access it for reading, writing, deleting, and so on.\n\n* `Body`: This member is just a placeholder that represents the start of the structure contained within the object.\n\n### > Optional Headers\n\nAn object's optional headers contain various types of metadata that help describe the object.\n\n![image-20200306211042526](https://tva1.sinaimg.cn/large/00831rSTly1gckiktybbxj30n50a3tac.jpg)\n\n","tags":["工具","memory forensics"],"categories":["工具"]},{"title":"Data Structure for Graphics","url":"/2019/07/31/FOCG-01/","content":"<script type=\"text/javascript\"\n   src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n</script>\n# Data Structures for Graphics\n\n## 1 Triangle Meshes(三角网格)\n---\n\n*Triangle meshes are generally used to represent surfaces, so a mesh is not just a collection of unrelated triangles, but rather a network of triangles that connect to one another through shared vertices and edges to form a single continuous surface.*\n\n---\n\n### 1.1 Mesh Topology\n\n\n**manifold**: a surface in which a small neighborhood around any point could be smoothed out into a bit of ﬂat surface.\n> 表面上的任意一点的周围领域都可以平滑进入该表面\n\n**figures**    \n\n* Every edge is shared by exactly two triangles.    \n\n\n![figure1.1](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564538894/blog/figure1.1_ut9yft.jpg)\n> Non-manifold (left) and manifold (right) interior edges.\n\n* Every vertex has a single, complete loop of triangles around it.\n\n![figure1.2](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564538894/blog/figure1.2_iv5flz.jpg)\n> Non-manifold (left) and manifold (right) interior vertices.\n\n**direction**    \n\n* For a single triangle, we deﬁne orientation based on the order in which the vertices are listed: the front is the side from which the triangle’s three vertices are arranged in counterclockwise order.\n\n> 顶点顺序按照逆时针排列的三角形视为前面\n\n![orient](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564539441/blog/5ADF80BC-E440-48B1-AEFC-C3C2B4F3D249_ojbeph.jpg)\n\n> Triangles (B,A,C) and (D,C,A) are consistently oriented, whereas (B,A,C) and (A,C,D) are inconsistently oriented.    \n\n### 1.2 Indexed Mesh Storage        \n\n*The minimum information required for a triangle mesh is a set of triangles (triples of vertices) and the positions (in 3D space) of their vertices.*\n\n**Triangle-to-vertax** data structure\n\n```\nTriangle {\n\tVertex v[3]\n}\n\nVertex {\n\tvector3 position \n\t// or other vertex data\n}\n```\n![Triangle-to-vertax data structure](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564540141/blog/111aa_yth3n1.png)\n\n**Triangle-to-vertax shared vertex mesh** data structure\n\n```\nIndexedMesh {\n\tint tInd[nt][3]\n\tvector3 verts[nv] \n}\n```\n> `tInd[i][k]`: the index of *k*th vertice of *i*th triangle.     \n> `verts[nv]`: the position of `vertex[nv]`(sharing vertex)\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564540496/blog/WX20190731-103442_2x_wg6qe0.png)\n\n### 1.3 fans and strips \n\n**Triangle fan**\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564540922/blog/WX20190731-104150_2x_p7gn1m.png)\n\n> In an indexed mesh, the triangles array would contain [(0, 1, 2), (0, 2, 3), (0, 3, 4), (0, 4, 5)].    \n\nThe fan in the ﬁgure could be speciﬁed with the sequence `[0, 1, 2, 3, 4, 5]`: **the ﬁrst vertex establishes the center**, and subsequently each pair of adjacent vertices (1-2, 2-3, etc.).\n\n**Triangle strip**\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564541079/blog/WX20190731-104415_2x_uvquoc.png)\n\nThe triangle strip in the ﬁgure could be speciﬁed by the sequence `[0 1 2 3 4 5 6 7]`, and every subsequence of three adjacent vertices (0-1-2, 1-2-3, etc.).    \n\n**For consistent orientation, every other triangle needs to have its order reversed**. In the example, this results in the triangles (0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 5), etc.\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564541240/blog/WX20190731-104708_2x_q4ic3t.png)\n\n### 1.4 Mesh connectivity data structure\n*more complicated data structures are needed to efﬁciently answer queries such as:*   \n\n* Given a triangle, what are the three adjacent triangles?\n* Given an edge, which two triangles share it?\n* Given a vertex, which faces share it?\n* Given a vertex, which edges share it?\n\nimplementation like following:\n\n```\nTriangle {\n\tVertex v[3] \n\tEdge e[3] \n}\n\nEdge {\n\tVertex v[2] \n\tTriangle t[2]\n}\n\nVertex {\n\tTriangle t[]\n\tEdge e[]\n}\n```\n**1.4.1 The Triangle-Neighbor Structure:**\n\n```\nTriangle {\n\tTriangle nbr[3]; \n\tVertex v[3]; \n}\n\nVertex {\n\t// ... per-vertex data ... \n\tTriangle t; // any adjacent tri \n}\n```\n> notice that in the array Triangle.nbr, the **k**th entry points to the **neighboring triangle** that **shares vertices k and k + 1**\n\n```\nMesh { \n\t// ... per-vertex data ...\n\tint tInd[nt][3]; // vertex indices    \n\tint tNbr[nt][3]; // indices of neighbor triangles    \n\tint vTri[nv]; // index of any adjacent triangle\n}\n```\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564542561/blog/WX20190731-110903_2x_jajbdd.png)\n\n* feature:\n**If triangle t has vertex v as its kth vertex, then the triangle t.nbr[k] is the next triangle around v in the clockwise direction.**(用于计算三角形t对于某一个顶点v的最近邻接三角形t.nbr[k]，如图中绿色箭头)\n\ntraverse all the triangles adjacent to a given vertex(对于一个给定顶点，遍历该点所有邻接三角形)：\n\n```\nTrianglesOfVertex(v) {\n\tt = v.t\n\tdo {\n\t\tfind i such that (t.v[i] == v)\n\t\tt = t.nbr[i]\n\t} while (t != v.t)\n}\n```\n\n**1.4.2 winged-edge data structure**\n\nmakes edges the ﬁrst-class citizen of the data structure.    \n\neach edge stores pointers to the **two vertices it connects (the head and tail vertices)**, the **two faces it is part of (the left and right faces)**, and, most importantly, **the next and previous edges in the counterclockwise traversal of its left and right faces**. Each vertex and face also stores a pointer to a single, arbitrary edge that connects to it.\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564544627/blog/WX20190731-114329_2x_kguihc.png)\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564556779/blog/54B0707E-9E44-44BB-BD3E-7E3377A12021_vhougd.jpg)\n\n```\nEdge { \n\tEdge lprev, lnext, rprev, rnext;\n\tVertex head, tail;\n\tFace left, right;\n}\n\nFace {\n\t// ... per-face data ...\n\tEdge e; // any adjacent edge\n}\n\nVertex { \n\t// ... per-vertex data ... \n\tEdge e; // any incident edge \n}\n```\n\nThe winged-edge data structure supports constant-time access to the edges of a face or of a vertex:\n\n```\nEdgesOfVertex(v) {\n\te = v.e;\n\tdo { \n\t\tif (e.tail == v) \n\t\t\te = e.lprev; \n\t\telse \n\t\t\te = e.rprev; \n\t} while (e != v.e);\n}\n\nEdgesOfFace(f) {\n\te = f.e;\n\tdo { \n\t\tif (e.left == f) \n\t\t\te = e.lnext; \n\t\telse \n\t\t\te = e.rnext; \n\t} while (e != f.e);\n}\n```\n\n> 应注意的是，使用winged-edge进行搜索时，我们每次在移动到下一条边之前需要检查边的方向。\n\n**1.4.3 The Half-Edge Structure**\n\nEach half-edge **points to the face on its side of the edge** and to **the vertex at its head**, and each contains **the edge pointers for its face**. It also points to **its neighbor on the other side of the edge.\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564558625/blog/WX20190731-153648_2x_lixjc4.png)\n\n```\nHEdge {\n\tHEdge pair, next; \n\tVertex v; \n\tFace f;\n}\n\nFace { \n\t// ... per-face data ...\n\tHEdge h; // any h-edge of this face \n}\n\nVertex { \n\t// ... per-vertex data ...\n\tHEdge h; // any h-edge pointing toward this vertex\n}\n```\nWe no longer need to check orientation, and we follow the pair pointer to access the edges in the opposite face.\n\n```\nEdgesOfVertex(v) { \n\th = v.h; \n\tdo { \n\t\th = h.pair.next; \n\t} while (h != v.h); \n}\n\nEdgesOfFace(f) { \n\th = f.h; \n\tdo {\n\t\th = h.next; \n\t} while (h != f.h); \n}\n```\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564558839/blog/WX20190731-154026_2x_pgzvwd.png)\n\n## 2 Scene Graphs\n\n---\n\nMost scenes admit to a hierarchical organization, and the transformations can be managed according to this hierarchy using a scene graph.\n\n---\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564561356/blog/WX20190731-162207_2x_hillvh.png)\n\n> On the left are the two pieces in their “local” coordinate systems. The hinge of the bottom piece is at point b and the attachment for the bottom piece is at its local origin. The degrees of freedom for the assembled object are the angles (θ,φ) and the location p of the top hinge.\n\n* draw the top part of the pendulum\n\n$$M_1 = rotate(\\theta)$$\n\n$$M_2 = translate(\\mathsf{p})$$\n\n$$M_3 = M_1M_2$$\n\n* draw the bottom part of the pendulum\n\n$$M_a = rotate(\\phi)$$\n\n$$M_b = translate(\\mathsf{b})$$\n\n$$M_c = M_bM_a$$\n\n$$M_d = M_3M_c$$\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564562754/blog/WX20190731-164539_2x_fqvkyt.png)\n\n> The scene graph for the hinged pendulum\n\n## 3 Spatial Data Structures\n\n---\n\n*We will use ray tracing as the primary motivation while discussing these structures, though they can all also be used for view culling or collision detection.*\n> 主要用于光照检测 \n\n---\n\n### 3.1 Bounding Boxes\n\nThis differs from conventional intersection tests in that **we do not need to know where the ray hits the box; we only need to know whether it hits the box.**\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564564422/blog/WX20190731-171329_2x_b7emcm.png)\n\n> The ray is **only tested for intersection with the surfaces if it hits the bounding box**.\n\n#### 3.1.1 Bounding Boxes\n\n$$x = x_{min}$$\n\n$$x = x_{max}$$\n\n$$y = y_{min}$$\n\n$$y = y_{max}$$\n\nThe points bounded by these lines can be described in interval notation:\n\n$$(x,y) \\in [x_{min},x_{max}] \\times[y_{min},y_{max}]$$\n\nFor intersection test:\n\n* assume that the light source position $e(x_e, y_e)$\n* assume that the light source direction $d(x_d, y_d)$\n\nlight source: \n\n$$\\vec P = \\vec e + t\\vec d$$\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564565510/blog/WX20190731-173136_2x_tdkvuo.png)\n\n> The ray will be inside the interval $x \\in [x_{min} , x_{max} ]$ for some interval in its parameter space $t \\in [t_ {xmin} , t_{xmax} ]$ . A similar interval exists for the y interval. **The ray intersects the box if it is in both the x interval and y interval at the same time**, i.e., the intersection of the two one-dimensional intervals is not empty.\n\n**Three possibilities for hitting test:**\n\n* $x_e \\leq x_{min}$ (no hit)\n* $x_{min} < x_e < x_{max}$ (hit)\n* $x_{max} < x_e$ (no hit)\n\n**Final code of hitting test:**\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564623288/blog/WX20190801-093429_2x_kopleh.png)\n\n### 3.1.2 Hierarchical Bounding Boxes\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564623700/blog/WX20190801-094129_2x_om2f8r.png)\n\n> The bounding boxes can be nested by creating boxes around subsets of the model.\n\n","tags":["Fundamentals of Computer Graphics"],"categories":["图形学基础"]},{"title":"MAC_MASM","url":"/2019/03/19/MAC-MASM/"},{"title":"LLDB简易指南","url":"/2019/03/14/lldb/","content":"# 关于LLDB\nLLDB is a next generation, high-performance debugger. It is built as a set of reusable components which highly leverage existing libraries in the larger LLVM Project, such as the Clang expression parser and LLVM disassembler.    \n\nLLDB is the default debugger in Xcode on Mac OS X and supports debugging C, Objective-C and C++ on the desktop and iOS devices and simulator.    \n\n# 教程\n\n## 调试可执行文件\n假设编译文件main.c:   \n \n```c\ngcc main.c -g -o debug.run\n```\n   \n> 必须 -g 才可以使用lldb指令查看代码\n  \n对可执行文件进行调试:    \n\n```c    \nlldb debug.run\n```\n\n如果可执行文件是带参数的，那就写入参数，比如：     \n\n```c   \nlldb -- debug.run 1 2 3\n```\n\n> debug.run是编译出来的可执行文件\n\n## 调试正在运行的进程\n***进程标识符pid：***    \n在计算机领域，进程标识符`pid`(process identifier)是大多数操作系统的内核用于唯一标识一个进程的数值。    \n\n***进程的状态：***    \n1.*R* 运行   \n2.*S* 中断（休眠中、受阻、在等待某个条件的形成或接收到信号）   \n3.*D* 不可中断    \n4.*Z* 僵死（进程终止，但进程描述符存在，直到父进程调用wait4()系统调用后释放）   \n5.*T* 停止（收到SIGSTOP、SIGSTP、SIGTIN、SIGTOU等信号后停止运行）      \n   \n\n***进程查看器 ps命令：***      \nps命令是最基本的进程查看命令。使用该命令可以确定有哪些进程正在运行以及运行的状态等等。    \n一般使用\n```\nps -aux | grep\n```\n查找特定进程，如\n```\nps aux | grep chuqiz\n```\n查找我的用户名进行的进程\n\n### 1. 启动lldb\n\n终端输入\n```\nlldb\n```\n\n### 2. 挂载进程的pid\n```\nprocess attach --pid xxxxxx\n```\n(xxxxxx为进程的pid)    \n同时也可以挂载到进程的名下：    \n```\nprocess attacj --name Safari\n```\n简写：\n```\npro att -n Safari\n```\n## 使用lldb看代码\n只有在之前编译选项带-g时才可以通过命令查看代码。    \n\n### 1. 使用list查看代码\n在lldb下输入`list` 或者`l` \n输入\n```\nl row\n```\n表示从第row行开始往下看      \n> 每次list只能查看10行代码，继续往下查看只需要继续输入list就可以     \n\n### 2. 查看其他文件代码\n如果程序编译的时候是由很多文件组成的，那么只需要\n```\nlist fileName\n```\n就可以查看其他文件的代码，以后再list时就是查看设置的fileName的代码。比如\n```\nlist CNFClause.c\n```\n### 3. 查看某函数的代码\n直接输入待查看函数的名字即可\n```\nlist funcName\n```\n比如: \n```\nlist deepCpyClause\n```\n     \n```\n(lldb) list deepCpyClause   \nFile: /Users/chuqiz/2018/CourseDesign/DPLL2/CourseDesign/DataStructure/CNFClause.c    \n   22  \t//    cls -> literals = (int *)malloc(sizeof(int) * literalNum) ;    \n   23  \t//    memcpy(cls -> literals, literals, literalNum * sizeof(int)) ;\n   24  \t//    return cls ;\n   25  \t//}\n   26\n   27  \tclause deepCpyClause(clause aclause){\n   28  \t//    int literalNum = aclause -> literalCount ;\n   29  \t//    ClauseStatus clsStatus = aclause -> clauseStatus ;\n   30  \t//    int * literals = (int *)malloc(sizeof(int) * literalNum) ;\n   31  \t//    memcpy(literals, aclause -> literals, literalNum * sizeof(int)) ;\n   32  \t//    clause cls = createClause(literalNum, literals) ;\n(lldb) list\n   33  \t    clause cpyCls = NULL ;\n   34  \t    initClause(&cpyCls) ;\n   35  \t    while (aclause) {\n   36  \t        addLiteral(&cpyCls, aclause -> literal) ;\n   37  \t        aclause = aclause -> next ;\n   38  \t    }\n   39  \t    return cpyCls ;\n   40  \t}\n```\n## 打断点\n让lldb调试器挂载进程显示代码以后，其余的步骤就是找地方下断点然后让程序运行。    \n\n### 1. 根据文件名和行号下断点\n\n```\n(lldb) breakpoint set --file main.c --line 27\nBreakpoint 1: where = CourseDesign`main + 22 at main.c:27, address = 0x0000000100001d16\n```\n\n### 2. 根据函数名下断点\n\n```\n(lldb) breakpoint set --name functionName           //C 函数\n(lldb) breakpoint set --method foo                  //C++ 类方法\n(lldb) breakpoint set --selector msgNameWithArg:    //Objective-C 选择器\n```\n\n### 3. 根据某个函数调用语句下断点(Objective-C常用)\n```\nbreakpoint set -n \"-[UIView viewDidLoad:]\"\n```\n\n### 4.设置命令别名化简指令\n命令: \n```\n(lldb)breakpoint set --file main.c --line 27\n```\n化简: \n```\n(lldb)command alias bfl breakpoint set -f %1 -l %2\n```\n使用:\n```\n(lldb)bfl main.c 27\n```\n\n### 5. 查看断点列表、禁用/启用断点、删除断点\n***查看断点列表：***`(lldb) breakpoint list`\n\n```\n(lldb) breakpoint list\nCurrent breakpoints:\n1: file = 'main.c', line = 27, exact_match = 0, locations = 1\n  1.1: where = CourseDesign`main + 22 at main.c:27, address = CourseDesign[0x0000000100001d16], unresolved, hit count = 0\n\n2: name = 'deepCpyClause', locations = 1\n  2.1: where = CourseDesign`deepCpyClause + 16 at CNFClause.c:33, address = CourseDesign[0x0000000100000ab0], unresolved, hit count = 0\n\n3: name = 'deepCpyFormula', locations = 0 (pending)\n\n4: name = 'addClause', locations = 1\n  4.1: where = CourseDesign`addClause + 16 at CNFFormula.c:45, address = CourseDesign[0x00000001000024d0], unresolved, hit count = 0\n```\n> 可以看出使用指令查看断点列表，会根据下断点的顺序给断点自动编号。只需要操作对应的编号即可处理相应的断点（禁用/启用，删除）   \n\n***禁用断点：***`(lldb) breakpoint disable x`（x为禁用的断点序号）   \n\n```\n(lldb) breakpoint disable 2\n1 breakpoints disabled.\n(lldb) breakpoint list\nCurrent breakpoints:\n1: file = 'main.c', line = 27, exact_match = 0, locations = 1\n  1.1: where = CourseDesign`main + 22 at main.c:27, address = CourseDesign[0x0000000100001d16], unresolved, hit count = 0\n\n2: name = 'deepCpyClause', locations = 1 Options: disabled\n  2.1: where = CourseDesign`deepCpyClause + 16 at CNFClause.c:33, address = CourseDesign[0x0000000100000ab0], unresolved, hit count = 0\n\n3: name = 'deepCpyFormula', locations = 0 (pending)\n\n4: name = 'addClause', locations = 1\n  4.1: where = CourseDesign`addClause + 16 at CNFFormula.c:45, address = CourseDesign[0x00000001000024d0], unresolved, hit count = 0\n\n```\n> 注意到刚才disable编号为2的断点，再次list断点列表，2号断点显示options为disabled\n\n***启用断点：***`(lldb) breakpoint enable x` (x为启用的断点编号)    \n\n```\n(lldb) breakpoint enable 2\n1 breakpoints enabled.\n(lldb) breakpoint list\nCurrent breakpoints:\n1: file = 'main.c', line = 27, exact_match = 0, locations = 1\n  1.1: where = CourseDesign`main + 22 at main.c:27, address = CourseDesign[0x0000000100001d16], unresolved, hit count = 0\n\n2: name = 'deepCpyClause', locations = 1\n  2.1: where = CourseDesign`deepCpyClause + 16 at CNFClause.c:33, address = CourseDesign[0x0000000100000ab0], unresolved, hit count = 0\n\n3: name = 'deepCpyFormula', locations = 0 (pending)\n\n4: name = 'addClause', locations = 1\n  4.1: where = CourseDesign`addClause + 16 at CNFFormula.c:45, address = CourseDesign[0x00000001000024d0], unresolved, hit count = 0\n```\n\n***删除断点：***`(lldb breakpoint delete x)` (x为删除的断点编号)    \n\n```\n(lldb) breakpoint delete 2\n1 breakpoints deleted; 0 breakpoint locations disabled.\n(lldb) breakpoint list\nCurrent breakpoints:\n1: file = 'main.c', line = 27, exact_match = 0, locations = 1\n  1.1: where = CourseDesign`main + 22 at main.c:27, address = CourseDesign[0x0000000100001d16], unresolved, hit count = 0\n\n3: name = 'deepCpyFormula', locations = 0 (pending)\n\n4: name = 'addClause', locations = 1\n  4.1: where = CourseDesign`addClause + 16 at CNFFormula.c:45, address = CourseDesign[0x00000001000024d0], unresolved, hit count = 0\n```\n> 再次list断点列表可以发现，编号为2的断点已经被删除\n\n## 运行环境操作\n### 1. 启动\n`(lldb) run`即为启动命令，(详情见上述 “调试”)，程序会运行到断点处停下。\n\n```\n(lldb) run\nProcess 42740 launched: '/Users/chuqiz/2018/CourseDesign/DPLL2/CourseDesign/CourseDesign' (x86_64)\nProcess 42740 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x0000000100001d16 CourseDesign`main(argc=1, argv=0x00007ffeefbff808) at main.c:27\n   24  \tint b[9][10] = {0} ;\n   25\n   26  \tint main(int argc, const char * argv[]) {\n-> 27  \t    showModule() ;\n   28  \t    return 0;\n   29  \t}\nTarget 0: (CourseDesign) stopped.\n```\n\n### 2. 下一步、步入、步出、继续执行\n\n```\n下一步：(lldb) next/n\n步入： (lldb) step/s\n步出： (lldb) finish\n继续执行： (lldb)continue        //会在下一个断点处停下\n```\n\n### 3. 查看变量\n```\npo allLiteralArr       //po一般输出指针指向的对象\np allLiteralArr        //p一般输出基础变量\n(普通数组两者都可使用)\n```","tags":["工具"],"categories":["工具"]},{"title":"Electra越狱下的iOS11配置debugserver+lldb","url":"/2019/03/14/debugserver-1/","content":"# Electra越狱下的iOS11配置debugserver+lldb\n\ndebugserver实际执行lldb（作为客户端）传过来的命令，再将执行结果反馈给lldb最终显示给用户。（来自小黄书第二版）\n\n### 配置debugserver\n***1.帮debugserver减肥***    \n\n将未经处理的debugserver从iOS拷贝到OSX中。\n首先通过ssh连接设备，查看`/Developer/usr/bin/debugserver`是否存在。**如果不存在：**    \n\n* 在OSX设备上运行Xcode\n* 为iOS打开一个objc项目\n* 将iOS设备通过usb连接并且加载项目\n\n再次检查`/Developer/usr/bin/debugserver`，此时该二进制文件应该存在。\n\niOS11不需要减肥，因为只支持64位架构的程序。\n    \n***2.添加task_for_pid权限***    \n \n下载[ent.xml](http://iosre.com/ent.xml)到保存debugserver的目录下，cd到该目录，执行命令    \n`/opt/theos/bin/ldid -Sent.xml debugserver`\n     \n***3.将处理的debugserver拷贝回iOS***\n\n使用ssh连接设备。    \n`scp debugserver root@localhost:/usr/bin/debugserver`    \n`ssh root@localhost`\n`iceGrave:~ root# chmod +x /usr/bin/debugserver`\n\n**如果运行debugserver报错killed 9：**    \n编辑之前的xml，添加key`platform-application`为true\n\n### 使用debugserver启动或者附加进程\n* 启动进程：    \n`debugserver -x backboard IP:port /path/to/executable`\n\n> debugserver会启动executable，并且开启port端口，等待来自IP的lldb接入\n\n* 附加进程：    \n`debugserver IP:port -a \"ProcessName\"`\n\n> debugserver会附加ProcessName，并开启port端口，等待来自IP的lldb接入","tags":["iosre","工具"],"categories":["工具"]},{"title":"CNCC2018随笔","url":"/2018/10/26/DO/","content":"# Digital Object & The Internet\n\n## Abstract （About） \n\n* **Evolving the Internet to facilitate management of digital information**\n\n\t- Over both short and very long time frames\n\t- With simplicity of Design \n\t- Open Architecture*\n\t- Independence form underlying technology(独立于底层技术)\n\n> **Open Architecture**:    \n> This is a type of computer architecture of software architecture intended to make adding, upgrading, and swapping components easy.    \n> 具有应用系统的可移植性和可裁剪性、网络上各节点机间的可操作性和易于多方获得软件的体系结构。    \n> 可移植性：各种计算机应用系统可以在具有开放结构性的各种计算机系统间进行移植。    \n> 可互操作性：计算机网络中的各节点都具有开放结构的特性。(可以互相操作和资源共享，不论各节点机是否是同种机型和机器)    \n> 易获得性：在具有开放结构性的机器上运行的软件环境易于从多方获得、不受某个来源所限制\n\n* **Focus on the Digital Object Architecture**\n\n\t- Goals \n\t- Basic componments & protocols\n\t- Implementations, reference software and applications\n\nKeywords: Digital Object, identfier, Digital Object Architecture\n> 几十年前，互联网是将各种物体连接在一起，处理各种数据包，以及实现计算机的互动。现如今，我们更多处理的是信息，即Digital Object。\n\n## What is Internet \n**Original FNC Definition**: global information system that makes use of IP, TCP.    \n\n**Key Attributes**:    \n- Designed to move bits from one computer to another.   \n- In a packet network environment consisting of mutiple networks and computers of different kinds.    \n- Open Architecture and Scalable over time.    \n- Non-Proprietary Architecture.  \n> 互联网的最早的设计初衷是将位元从一台机器移动到另一台机器。这些协议以及架构更加接近于独立的网络和计算机?\n\n##Some About DOA\n\n**Digital Object Architecture** as a logical extension of the Internet - with same properties of simplicity, scalability, open architecture and non-proprietary.\n\nSome Properties:\n\n- enables interoperability of such heterogeneous information systems with integrated security based on use of public key infrastructure.\n\n> 基于公开密钥的使用，这种异构信息系统具有集成安全性的互操作性。\n\n- lower the barriers to managing digital information in the internet - long & short term.\n\nAssume:\n\n- Assumes that many different kinds of information systems will exist over time. Some old, some new and changing dynamically.\n\n> DOA架构的主要动力：新旧的信息系统一直在动态变化。\n                                                                                                                                                                                                                                                    \n### Components & Protocols of the DOA\n* **Three basic components**:\n\t* DO Repositories that store DOs and from which they can be accessed via their identifier.\n\t* DO Registers that store metadata about individual DOs and which can be used to search.                                                                                                                                                                                                                                        \n\t* An identifier/resolution system that maps given identifiers to information helpful in accessing the DOs they identify - known as state information.\n\n> 调用储存库时，通过object的identifier访问他们。任何DO只要通过独特的标识符，便可以与其他的DO区分开来，方便储存查找以及管理。    \n> state information:状态信息是一种identifier/解析 系统，可以将给定的identifier映射到能够帮助访问DO的信息。    \n> 通过identifier，可以在任何时候访问这些信息。\n\n*KEYWORD: Identifier*\n\n* **Two Protocols**:\n\t* Digital Object Identifier Protocol(DOIP)\n\t* Identifier/Resolution Protocol\n\n### Digital Object Identifier\n\nIn computing, a Digital Object Identifier or DOI is a persistent identifier or handle used to uniquely identify objects.\n\n> 一套识别数字资源的机制，涵盖的对象有视频、报告或书籍等等。它既有一套为资源命名的机制，也有一套将识别解析为具体地址的协议。    \n> 发展动机：在于补充统一资源标志符的不足，URI指涉的URL经常会变动，而且URI表达的其实是资源所在地(网址)，而不是数字资源本身的信息。    \n> 一个DOI经过解析以后，可以连至一个或者更多的数据。但是identifier本身与解析之后所导向的数据并不相关(也可能无法获取全部的数据)\n\nA Digital Object Identifier has the form of prefix/suffix.\n> DOI码由前缀和后缀两部分组成。前缀再以`.`符号分割成两部分，如：10.1000/182\n\n","tags":["随笔"]},{"title":"iOS开发架构以及OC基础知识","url":"/2018/04/26/article1/","content":"# iOS开发架构\n### 框架层(应用程序层级结构)\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/001.png)\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/002.png)\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/003.png)\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/004.png)\n### 平台组件\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/005.png)\n### 设计模式\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/006.png)\n# 初步了解OBJC-Runtime&@property\n\n## RunTime(待填坑)\n### 一、简介\nObjective-C 语言是一门动态语言，是扩充C语言的面向对象的语言。其在C语言的基础上增加了一层很小的面向对象语法并且完全兼容C语言。  \n\n+ OC是一门动态语言，他在运行过程中处理很多静态语言在编译与链接时做的事\n+ Runtime库使得C语言有面向对象的能力\n+ OBJC调用对象方法的过程基于Runtime\n\n> 在Runtime中，C语言中的`结构体`可以表示成`对象`，而`方法`则可以通过C语言的函数实现。\n\n当程序执行`[Object doSomeThing]`时，会动态向`object`发送一条`doSomeThing`信息，Runtime根据消息接受着是否能相应该消息而做出反应。\n\n### 二、底层结构\nObjective-C类通过Class类型表示，实际上是一个指向`objc_class`结构体的指针。  \n\n```\ntypedef struct object_class * Class\n```\n查看objc_class结构体：\n\n```\nstruct objective_class{\n\t Class isa OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n\t Class super_class                        OBJC2_UNAVAILABLE;  // 父类，如果该类是最顶层根类，则它为NULL\n     const char *name                         OBJC2_UNAVAILABLE;  // 类名\n     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0\n     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识\n     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小\n     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表\n     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表\n     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存\n     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表\n#endif\n}OBJC2_UNAVAILABLE;\n```\n\n其中的成员变量列表以及方法列表：\n\n```\n// 成员变量列表\nstruct objc_ivar_list {\n    int ivar_count                                           OBJC2_UNAVAILABLE;\n#ifdef __LP64__\n    int space                                                OBJC2_UNAVAILABLE;\n#endif\n    /* variable length structure */\n    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;\n}                                                            OBJC2_UNAVAILABLE;\n\n// 方法列表\nstruct objc_method_list {\n    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;\n\n    int method_count                                         OBJC2_UNAVAILABLE;\n#ifdef __LP64__\n    int space                                                OBJC2_UNAVAILABLE;\n#endif\n    /* variable length structure */\n    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;\n}\n```\n\n### objc_object\n\nobjc_object是表示一个类的实例的结构体：\n\n```\nstruct objc_object{\n     Class isa OBJC_ISA_AVAILABILITY;\n};\ntypedef struct objc_object *id;\n```\n\n+ isa指针  \n\n**在Objective-C中，任何类的定义都是对象。类和类的实例（对象）没有本质区别，任何一个对象都有isa指针。**  \nisa指针是一个Class类型指针，指向对象的类，Class中也有一个isa指针，指向meteClass(元类)。**元类保存了类方法的列表。**\n> 类方法调用过程：1.从本身查找 2.向父类查找  \n\n元类也是类，也是类对象。元类的isa指针指向**根元类(root meteClass)**。根元类的isa对象指向**本身**，形成封闭内循环。\n\n![Underlying structure](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/1.png)\n\n### Category\nCategory表示一个指向分类的结构体的指针。\n\n```\ntypedef struct objc_category *Category\nstruct objc_category{\n     char *category_name                         OBJC2_UNAVAILABLE; // 分类名\n     char *class_name                            OBJC2_UNAVAILABLE;  // 分类所属的类名\n     struct objc_method_list *instance_methods   OBJC2_UNAVAILABLE;  // 实例方法列表\n     struct objc_method_list *class_methods      OBJC2_UNAVAILABLE; // 类方法列表\n     struct objc_protocol_list *protocols        OBJC2_UNAVAILABLE; // 分类所实现的协议列表\n}\n```\n该结构体主要包含分类的实例方法与类方法。\n> instance_methods是objc_class中方法列表的一个子集  \n> class_method是元类方法列表的一个子集  \n\n**分类中没有ivar成员变量指针，因此分类中不能添加实例变量和属性。**  \n\n\n### objc_ivar\n\nOC中类和对象的实例变量，实际上就是一个指向objc_ivar的结构体指针ivar\n\n```\ntypedef struct objc_ivar * Ivar ;\n```\n\n在Runtime机制中，通过runtime方法`class_copyIvarList`可以获取一个指向类和对象所有实例变量的Ivar类型指针。  \n获取到Ivar类型指针后，可以通过`ivar_getName`方法获取该实例变量的名称并由C语言字符串表示。\n> 由于笔者能力有限，此处不再展示示例。\n\n### 属性\n\nOC中类和对象的属性@property，是一个指向`objc_property`的结构体指针`objc_property_t`。\n\n```\ntypedef struct objc_property *objc_property_t ;\n```\n\n同理，runtime方法`class_copyPropertyList`可以获取一个指向类和对象所有属性的`objc_property_t`类型指针。  \n获取到`objc_property_t`类型指针之后，通过runtime方法`property_getName`可以获取属性名称。\n> 由于笔者能力有限，此处仍然没有示例\n\n### 方法\nOC中类和对象的方法，是一个指向objc_method的结构体指针Method。\n\n```\ntypedef struct objc_method *Method ;\n```\n\n通过runtime方法`class_copyMehtodLists`可以获取一个指向类和对象所有方法的Method类型指针。  \n获取到Method类型指针之后，通过method_getName方法获取方法名称。\n> 依然没有示例 \n\n### * Method Swizzling\n在runtime中，可以通过修改一个已经存在的类方法，实现方法的替换。\n**网上抄的demo:**  \nUIView的load方法中:  \n\n```\n+ (void)load {\n     Method origin = class_getInstanceMethod([UIView class], @selector(touchesBegan:withEvent:));\n     Method custom = class_getInstanceMethod([UIView class], @selector(custom_touchesBegan:withEvent:));\n     method_exchangeImplementations(origin, custom);\n}\n- (void)custom_touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n     // TODO\n}\n```\n\n这样触发UIView的`touchesBegan:withEvent:`方法时，实际调用了自定义方法`custom_touchesBegan:withEvent:`方法。\n\n### 关联对象\n\n上文`objc_class`结构体中，我们可以看出，通过动态修改 `* methodList`的值添加成员方法，同样这也是Category实现原理。但是分类中没有`ivar`成员变量类型指针，这就说明分类中不能够添加实例变量和属性。\n> 这个也解释了Category不能添加属性的原因。对于分类的详解请参考:[深入理解Objective-C: Category](https://tech.meituan.com/DiveIntoCategory.html)。\n\n关于Category无法向现有的类添加属性，可以使用runtime风的关联对象(associated objdects)实现。\n\n**有待补充**\n\n---\n## @Property(基础使用)\n\n[Apple官方在 Adopting Modern Objective-C](https://developer.apple.com/library/content/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html) 提及现代化的OC写法，其中就讲到尽量使用@property属性: \n\nProperties capture the state of an object. They reflect the object’s intrinsic attributes and relationships to other objects. Properties provide a safe, convenient way to interact with these attributes without having to write a set of custom accessor methods (although properties do allow custom getters and setters, if desired).\n\nUsing properties instead of instance variables in as many places as possible provides many benefits:\n\n+ **Autosynthesized getters and setters**. When you declare a property. by default getter and setter methods are created for you.\n+ **Better declaration of intent of a set of methods.** Because of accessor method naming conventions, it's clear exactly what the getter and setter are doing.\n+ **Property keywords that express additional information about behavior.** Properties provide the potential for declaration of attributes like `assign` (vs`copy`),`weak`, `atomic`(vs`nonatomic`), and so on\n\n**对于属性自动合成的setter和getter方法命名以及使用等基本内容，不再赘述。**\n### @property指示符\n常用指示符有：  \n\n+ `nonatomic` `atomic`\n+ `strong` `weak`\n+ `readwrite` `readonly`\n+ `assign`\n+ `copy`\n+ `unsafe_unretained`\n+ `retain`\n\n### atomaic/nonatomic\n\n该指示符指定合成的存取方法是否为原子操作，与线程安全有关。(待)  \n但几乎所有代码的属性设置都会使用`nonatomic`，这样能提高访问性能。\n\n### readonly/readwrite\n编译器合成的默认选项时`readwrite`，即自动生成getter以及setter。  \n`readonly`表示只合成`getter`而不合成`setter`。\n\n### assign\n`assign`表示不更改对属性所赋值的引用计数，只进行简单的赋值操作，同时也不改变旧值的引用计数。  \n通常`assign`常用标量类型，如`NSInteger``NSUInteger``CGFloat``NSTimeInterval`。  \n`assign`其实也可以修饰对象(比如`NSString`)，但是该修饰符不会改变所赋新值的引用计数以及旧值的引用计数，如果新值对象引用计数为0而被销毁时属性并不知道，编译器也不会将该属性值设为`nil`，这样指针仍然会指向被销毁的内存，访问该属性就会出现悬挂指针，导致程序崩溃。\n\n```\n#import <Foundation/Foundation.h>\n\n@interface Person : NSObject\n\n@property(nonatomic, assign) NSUInteger age ;\n@property(nonatomic, assign) NSString * name ;\n\n\n@end\n@implementation Person\n\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person * aPerson = [[Person alloc] init] ;\n        NSMutableString * name = [[NSMutableString alloc] initWithString:@\"Chuqi Zhang\"] ;\n        \n        //设置属性仅仅是将name的地址赋给aPerson.name\n        aPerson.name = name ;\n        \n        //输出两变量内存地址 ，一致\n        NSLog(@\"%p %p\",aPerson.name , name) ;\n        NSLog(@\"%@ %lu\",aPerson.name , (unsigned long)aPerson.age) ;\n        \n        //将name置空，引用计数为0，对象被销毁\n        name = nil ;\n        //地址仍然指向该内存，但是访问会崩溃\n        NSLog(@\"%p\",aPerson.name) ;\n    }\n    return 0;\n}\n```\n\n### strong/weak\n\n`strong`表示属性对所赋的值持有强引用，表示拥有关系(owning relationship)，使用该指示符，会先保留新值(增加新值的引用计数)，然后释放旧值(减少旧值引用计数)。该修饰符只能修饰对象，即对对象持有一种强引用。  \n\n`weak`表示属性对所赋的对象持有一种弱引用，表示非拥有关系(nonowning relationship)，对新值不会增加引用计数，也不会减少旧值的引用计数。所赋的值在引用计数为0被销毁以后，该修饰符修饰的属性会自动设置成`nil`，有效防止悬挂指针问题。\n\n使用`strong`:\n\n```\n#import <Foundation/Foundation.h>\n\n@interface Person : NSObject\n//使用强引用\n@property(nonatomic, strong) NSString * name ;\n@end\n@implementation Person\n\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person * aPerson = [[Person alloc] init] ;\n        NSMutableString * name = [[NSMutableString alloc] initWithString:@\"Chuqi Zhang\"] ;\n        //将name地址赋给property，aPerson.name持有强引用\n        aPerson.name = name ;\n        //两地址相同\n        NSLog(@\"%p %p\",aPerson.name , name) ;\n        //将name置空\n        name = nil ;\n        NSLog(@\"%@ %@ %p %p\",aPerson.name, name,aPerson.name , name) ;\n    }\n    \n    //最终输出结果：aPerson.name地址和值并没有改变,name地址变为0X0，值为(null)，即引用保留。\n    return 0;\n}\n\n```\n### copy\n`copy`修饰符修饰的属性会在内存中拷贝一份对象，两个指针指向不同地址。  \n该修饰符通常用来修改**有对应 可变类型子类 的对象**。如:`NSString/NSMutableString` `NSArray/NSMutableArray` 以及 `NSDictionary/NSMutableDictionary` 等。  \n使用`copy`修饰符进行备份，可防止对象由于可变类型子类影响，防止属性值被修改。  \n\n使用strong导致属性可能被修改:\n\n```\n@interface Person : NSObject\n@property(nonatomic, strong) NSString * name ;\n@end\n@implementation Person\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person * aPerson = [[Person alloc] init] ;\n        NSMutableString * name = [[NSMutableString alloc] initWithString:@\"Chuqi Zhang\"] ;\n        //将name地址赋值给aPerson.name\n        aPerson.name = name ;\n    \t//修改name\n        [name appendString:@\"hi\"] ;\n        //aPerson.name也会随之改变\n        NSLog(@\"%@\",aPerson.name) ;\n    }\n    return 0;\n}\n```\n`Foundation`框架提供的所有类都实现了`NSCopying`协议，使用`copy`都会返回一个不可变对象，因此属性如果为可变对象类别(如`NSMutableString`)就不能够使用`copy`修饰符修饰，应该用`strong`，这样会得到一个不可变的对象。\n\n## @Property(深入)\n\n### 关于copy\n","tags":["iOS"],"categories":["iOS"]},{"title":"Hello World","url":"/2018/04/03/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]