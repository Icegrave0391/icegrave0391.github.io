[{"title":"手把手带你MIT6.828 - Lab4","url":"/2020/03/19/joslab4/","content":"\n# Lab4 Preemptive Multitasking\n\n官方文档: [lectures](https://pdos.csail.mit.edu/6.828/2018/lec/)\n\n### > 实验介绍\n\n本次实验分为三个部分，我们在多个同时激活的用户模式环境下实现一个抢占式（preemptive）的多任务管理系统。\n\n在Part A中，我们将会为jos添加多处理器支持，实现轮询调度（round-robin scheduling），同时添加基本的环境管理系统调用（负责创建和销毁环境的系统调用，以及内存分配和映射的调用）。\n\n在Part B中，我们会实现一个Unix-like的`fork()`函数，使得用户环境可以创建一份自己进程的拷贝（copy）。\n\n在Part C中，我们将会实现进程间通讯功能IPC（inter-process communication），允许不同的用户环境之间显式相互通信和同步（communicate and synchronize）。我们还需要实现对于硬件时钟中断和抢占的支持。\n\n\n\n### > 实验准备\n\n仍旧需要将lab4的分支merge到lab3下。实验四包含了以下新增的文件：\n\n- kern/cpu.h 内核私有的关于多处理器的支持\n- kern/mpconfig.c 读取多处理器配置的代码\n- kern/lapic.c 内核驱动每个处理的的APIC（高级可编程中断控制器）的代码\n- kern/mpentry.S 非引导CPU的汇编入口代码\n- kern/spinlock.h 内核私有的自旋锁定义，包括大内核锁\n- kern/spinlock.c 内核实现自旋锁的代码\n- kern/sched.c 需要实现的调度器的代码框架\n\n\n\n## Part A: Multiprocessor Support and Cooperative Multitasking\n\n在实验的这部分中，我们首先拓展jos使其运行在多处理器系统上，然后实现jos内核一些系统功能调用以支持用户级环境去创建新环境。我们还需要实现协同式轮询调度（cooperative round-robin scheduling）算法，允许内核在旧的用户环境资源放弃CPU或者退出的时候切换到一个新的用户环境。\n\n\n\n### A.1 Multiprocess Support\n\n我们将要使jos支持**对称式多处理SMP**（symmetric multiprocessing）。在这种多处理器模型下，所有的CPU都有着对系统资源（内存、I/O总线）的平等使用权。虽然所有CPU在SMP中的功能都是相同的，但是在引导过程中它们可以被分为两种：\n\n* **引导处理器BSP**（bootstrap processor）负责初始化系统并且引导操作系统。\n\n* **应用处理器AP**（application processor）在操作系统启动之后被BSP激活。\n\n由哪个（些）处理器来担任BSP的功能是由BIOS和硬件决定的，迄今为止我们前三个实验到现在所有代码都是在BSP上实现的。\n\n在一个SMP系统中，每一个CPU都有一个伴随的**本地APIC（LAPIC）单元**。LAPIC单元负责整个系统的中断传递。LAPIC为其相连接的CPU提供了一个唯一的标识符。在这个实验中我们会使用LAPIC的一些基本功能（在`kern/lapic.c`中）：\n\n* 读取LAPIC标识符（APIC ID），告知我们的代码正运行在哪个CPU上（参考`cpunum()`）\n* 从BSP向AP发送`STARTUP`**处理器间中断信号IPI**（interprocessor interrupt），唤醒其他CPU（参考`lapic_startup()`）\n* 在Part C中，我们编程LAPIC单元内置的定时器来触发时钟中断，实现抢占式多任务（参考`apic_init()`）\n\n处理器通过**内存映射I/O也称为MMIO**（memory-mapped I/O）来访问LAPIC单元。在MMIO中，一部分的物理内存被硬链接到某些I/O设备的寄存器。因此`load/store`访存指令也可以特别用于访问设备寄存器。\n\n在之前的实验中我们已经知道了在物理地址`0xA0000`处有一个I/O hole（这个hole用于写VGA显示缓存）。LAPIC单元同样也存在于第二个I/O hole上，物理地址`0xFE000000`（4064MB）。这个高地址无法用之前设置对KERNBASE的直接映射去访问。jos的虚拟内存映射在`MMMIOBASE`处留了4MB的空隙，所以我们可以在这里映射硬件去访问。之后的实验中还会引入更多的MMIO区域，我们需要实现一个分配这部分区域并且映射到设备内存的函数。\n\n**exercise 1**\n\n实现`kern/pmap.c`中的`mmio_map_region()`函数。我们可以看到它在`kern/lapic.c`中`lapic_init()`的开头被调用。\n\n(为了让这个函数的测试案例能够正常运行，我们还需要把下一个练习也做了。)\n\n```c\n//\n// Reserve size bytes in the MMIO region and map [pa,pa+size) at this\n// location.  Return the base of the reserved region.  size does *not*\n// have to be multiple of PGSIZE.\n//\nvoid *\nmmio_map_region(physaddr_t pa, size_t size)\n{\n\t// Where to start the next region.  Initially, this is the\n\t// beginning of the MMIO region.  Because this is static, its\n\t// value will be preserved between calls to mmio_map_region\n\t// (just like nextfree in boot_alloc).\n\tstatic uintptr_t base = MMIOBASE;\n\n\t// Reserve size bytes of virtual memory starting at base and\n\t// map physical pages [pa,pa+size) to virtual addresses\n\t// [base,base+size).  Since this is device memory and not\n\t// regular DRAM, you'll have to tell the CPU that it isn't\n\t// safe to cache access to this memory.  Luckily, the page\n\t// tables provide bits for this purpose; simply create the\n\t// mapping with PTE_PCD|PTE_PWT (cache-disable and\n\t// write-through) in addition to PTE_W.  (If you're interested\n\t// in more details on this, see section 10.5 of IA32 volume\n\t// 3A.)\n\t//\n\t// Be sure to round size up to a multiple of PGSIZE and to\n\t// handle if this reservation would overflow MMIOLIM (it's\n\t// okay to simply panic if this happens).\n\t//\n\t// Hint: The staff solution uses boot_map_region.\n\t//\n\t// Your code here:\n\tsize = ROUNDUP(size, PGSIZE);\n\tif(base + size > MMIOLIM){\n\t\tpanic(\"[mmio_map_region] allocation size overflow!\\n\");\n\t}\n\tboot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);\n\tuintptr_t save_base = base;\n\tbase += size;\n\treturn (void *)save_base;\n}\n```\n\n\n\n### A.2 Application Processor Bootstrap\n\n在引导AP之前，BSP首先需要收集多处理器系统的信息，比如总CPU数，每个CPU对应的APIC ID以及LAPIC的内存映射地址等。**`kern/mpconfig.c`中的`mp_init()`函数通过读取BIOS内存中的MP配置表来获取相关信息。**\n\n`kern/init.c`中的**`boot_aps()`函数驱动了AP的引导过程**。AP从实模式开始启动（类似于bootloader），因此`boot_aps()`从`kern/mpentry.S`中拷贝了一份AP入口代码（entry code）**到一个实方式下可以寻址的内存位置**。与bootloader不同的是，我们对于AP入口代码存放的位置可以有一定控制权：在jos中使用`MPENTRY_PADDR`作为入口地址的存放位置，但是实际上`640KB`下任何未使用的页对齐的地址都是可以使用的。\n\n接下来，`boot_aps()`向对应AP的LAPIC单元发送`STARTUP`的IPI信号（处理器间中断），使用AP的entry code初始化其CS:IP地址（在这里我们就使用`MPENTRY_PADDR`）依次激活APs。\n\n在一些简单的设置之后，AP将启动分页并进入保护模式，然后调用在`kern/init.c`中的启动例程`mp_main`。`boot_aps()`在唤醒下一个AP之前会等待当前AP发出一个`CPU_STARTED`启动标记，这个标记位在`struct CpuInfo`中的`cpu_status`域。\n\n**exercise 2**\n\n阅读`kern/init.c`中的`boot_aps()`以及`mp_main()`和`kern/mpentry.S`汇编代码。我们需要确保理解AP的bootstrap过程中的控制流切换。然后修改我们之前在`kern/pmap.c`中`page_init()`的实现，避免将`MPENTRY_PADDR`的区域也添加到`page_free_list`中，这样我们才可以安全地在该物理地址处拷贝以及运行AP的引导代码。\n\n* 控制流\n\n在系统加载的过程中，`boot_aps()`被调用，然后按照前文所述使用`memmove()`函数从`mpentry.S`中拷贝文件中`.global mpentry_start`标签处开始的入口代码直到`.global mpentry_end`结束，代码被拷贝到`MPENTRY_PADDR`（此处是0x7000的I/O hole）对应的内核虚拟地址（别忘了必须拷贝到内核虚拟地址才可以被内核所操作）。然后`boot_aps()`根据每一个CPU的栈配置`percpu_kstacks[]`来为每一个AP设置栈地址`mpentry_stack`。再之后调用`lapic_startup()`函数来启动AP，并等待AP的状态变为`CPU_STARTED`以切换到下一个AP的配置。\n\nAP启动后，执行从`mpentry.S`中复制的入口代码：\n\n```assembly\n#include <inc/mmu.h>\n#include <inc/memlayout.h>\n\n###################################################################\n# entry point for APs\n###################################################################\n\n# Each non-boot CPU (\"AP\") is started up in response to a STARTUP\n# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor\n# Specification says that the AP will start in real mode with CS:IP\n# set to XY00:0000, where XY is an 8-bit value sent with the\n# STARTUP. Thus this code must start at a 4096-byte boundary.\n#\n# Because this code sets DS to zero, it must run from an address in\n# the low 2^16 bytes of physical memory.\n#\n# boot_aps() (in init.c) copies this code to MPENTRY_PADDR (which\n# satisfies the above restrictions).  Then, for each AP, it stores the\n# address of the pre-allocated per-core stack in mpentry_kstack, sends\n# the STARTUP IPI, and waits for this code to acknowledge that it has\n# started (which happens in mp_main in init.c).\n#\n# This code is similar to boot/boot.S except that\n#    - it does not need to enable A20\n#    - it uses MPBOOTPHYS to calculate absolute addresses of its\n#      symbols, rather than relying on the linker to fill them\n\n#define RELOC(x) ((x) - KERNBASE)\n#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)\n\n.set PROT_MODE_CSEG, 0x8\t# kernel code segment selector\n.set PROT_MODE_DSEG, 0x10\t# kernel data segment selector\n\n.code16           \n.globl mpentry_start\nmpentry_start:\n\tcli            \n\n\txorw    %ax, %ax\n\tmovw    %ax, %ds\n\tmovw    %ax, %es\n\tmovw    %ax, %ss\n\n\tlgdt    MPBOOTPHYS(gdtdesc)\n\tmovl    %cr0, %eax\n\torl     $CR0_PE, %eax\n\tmovl    %eax, %cr0\n\n\tljmpl   $(PROT_MODE_CSEG), $(MPBOOTPHYS(start32))\n\n.code32\nstart32:\n\tmovw    $(PROT_MODE_DSEG), %ax\n\tmovw    %ax, %ds\n\tmovw    %ax, %es\n\tmovw    %ax, %ss\n\tmovw    $0, %ax\n\tmovw    %ax, %fs\n\tmovw    %ax, %gs\n\n\t# Set up initial page table. We cannot use kern_pgdir yet because\n\t# we are still running at a low EIP.\n\tmovl    $(RELOC(entry_pgdir)), %eax\n\tmovl    %eax, %cr3\n\t# Turn on paging.\n\tmovl    %cr0, %eax\n\torl     $(CR0_PE|CR0_PG|CR0_WP), %eax\n\tmovl    %eax, %cr0\n\n\t# Switch to the per-cpu stack allocated in boot_aps()\n\tmovl    mpentry_kstack, %esp\n\tmovl    $0x0, %ebp       # nuke frame pointer\n\n\t# Call mp_main().  (Exercise for the reader: why the indirect call?)\n\tmovl    $mp_main, %eax\n\tcall    *%eax\n\n\t# If mp_main returns (it shouldn't), loop.\nspin:\n\tjmp     spin\n\n# Bootstrap GDT\n.p2align 2\t\t\t\t\t# force 4 byte alignment\ngdt:\n\tSEG_NULL\t\t\t\t# null seg\n\tSEG(STA_X|STA_R, 0x0, 0xffffffff)\t# code seg\n\tSEG(STA_W, 0x0, 0xffffffff)\t\t# data seg\n\ngdtdesc:\n\t.word   0x17\t\t\t\t# sizeof(gdt) - 1\n\t.long   MPBOOTPHYS(gdt)\t\t\t# address gdt\n\n.globl mpentry_end\nmpentry_end:\n\tnop\n```\n\n通过阅读代码的注释我们可以知道，AP启动后会开启分页机制和保护模式，切换运行栈，然后跳转到`mp_main()`函数。\n\n在`mp_main()`函数中，使用`lcr3`指令切换页目录到`kern_pgdir`，初始化LAPIC、用户环境和陷阱处理机制。最后设置`struct CpuInfo`中的`cpu_status`为`CPU_STARTED`来告知BPS已经启动成功。\n\n所以我们修改`page_init()`：\n\n```c\n//\n// Initialize page structure and memory free list.\n// After this is done, NEVER use boot_alloc again.  ONLY use the page\n// allocator functions below to allocate and deallocate physical\n// memory via the page_free_list.\n//\nvoid\npage_init(void)\n{\n\t// LAB 4:\n\t// Change your code to mark the physical page at MPENTRY_PADDR\n\t// as in use\n\n\t// The example code here marks all physical pages as free.\n\t// However this is not truly the case.  What memory is free?\n\t//  1) Mark physical page 0 as in use.\n\t//     This way we preserve the real-mode IDT and BIOS structures\n\t//     in case we ever need them.  (Currently we don't, but...)\n\t//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)\n\t//     is free.\n\t//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must\n\t//     never be allocated.\n\t//  4) Then extended memory [EXTPHYSMEM, ...).\n\t//     Some of it is in use, some is free. Where is the kernel\n\t//     in physical memory?  Which pages are already in use for\n\t//     page tables and other data structures?\n\t//\n\t// Change the code to reflect this.\n\t// NB: DO NOT actually touch the physical memory corresponding to\n\t// free pages!\n\tsize_t i;\n\t// 跳过page[0]，分配npages_basemem数量\n\t// lab4: 跳过mpentry\n\tint mpentry_idx = ROUNDUP(MPENTRY_PADDR, PGSIZE) / PGSIZE;\n\tfor (i = 1; i < npages_basemem; i++){\n\t\tif(i == mpentry_idx){\n\t\t\tcontinue;\n\t\t}\n\t\tpages[i].pp_ref = 0;\n\t\tpages[i].pp_link = page_free_list;\n\t\tpage_free_list = &pages[i];\n\t}\n\t// 无视I/O hole，这部分之前使用了npages_basemem所以不用操作\n\t// 从extended_memory的kernel使用之后的位置开始分配\n\t\t\t// 首先取出最后一块目录项的地址\n\tphysaddr_t next_page = PADDR(boot_alloc(0));\n\t\t\t// 得到索引\n\tsize_t idx_free = next_page / PGSIZE;\n\tfor(i = idx_free; i < npages; i++){\n\t\tpages[i].pp_ref = 0;\n\t\tpages[i].pp_link =page_free_list;\n\t\tpage_free_list = &pages[i];\n\t}\n}\n```\n\n完成之后，我们应该可以通过`check_page_free_list()`但是无法通过当前的`check_kern_pgdir()`。\n\n**Question**\n\nQ：比较`kern/mpentry.S`和`boot/boot.S`，记住两个代码都是编译连接后加载到`KERNBASE`之上运行的，为什么`mpentry.S`需要一个多余的红`MPBOOTPHYS`？\n\n> 提示：回顾Lab1中的链接地址（link address）和加载地址（load address）\n\nA：lab1中我们使用objdump研究bootloader发现，其链接地址和加载地址是一样的。但是`mpentry.S`的链接地址是物理地址，因此需要这个宏转换为内核区的虚拟地址。\n\n\n\n### A.3 Per-CPU State and Initalization\n\n当编写多核操作系统的时候，区分每一个CPU的私有状态以及整个系统共享的全局状态是非常重要的。`kern/cpu.h`中定义了绝大部分CPU的状态，包括用于储存cpu变量的`struct CpuInfo`。\n\n`cpunum()`总是返回调用它的CPU ID，能用来索引例如`cpus`的数组。宏`thiscpu`是当前CPU的`struct CpuInfo`的简写。\n\n下面列举一下需要注意的CPU状态（per-CPU state）：\n\n* **每CPU内核栈**（Per-CPU Kernel stack）\n\n  多CPU可能同时陷入内核，我们需要为每个CPU设置独立的内核栈来避免相干扰。`percpu_kstacks[NCPU][KSTKSIZE]`为`NCPU`个内核栈预留了空间。\n\n  * 实验二中`bootstack`指向的物理内存作为BSP的栈，映射在了`KSTACKTOP`下。相似地我们在本次实验中需要为每个CPU的内核栈映射到数组的对应区域。\n  * CPU 0的内核栈从`KSTACKTOP`开始向下增长，之后第n个CPU的内核栈从`KSTACKTOP - n*KSTKGAP`处开始向下增长。如`inc/memlayout.h`中所示。\n\n* **每CPU的TSS和TSS描述符**（Per-CPU TSS and TSS descriptor）\n\n  * 每个CPU的任务状态段`TSS`同样需要指明其对应的内核栈位置。每个CPU的TSS存放在`CpuInfo`中的`cpu_ts`域中，对应的描述符在GDT表项的`gdt[(GD_TSS0 >> 3)+i]`中。\n\n  * 这次实验中，定义在`kern/trap.c`中的全局`ts`变量不再有作用。\n\n* **每CPU的当前环境指针**（Per-CPU current environment pointer）\n\n  每个CPU都能同步地执行不同的用户环境。\n\n  * 将`curenv`定义为指向当前CPU（当前代码正在执行的CPU）正在执行的环境的`cpus[cpunum()].cpu_env`（或是`thiscpu->cpu_env`）\n\n* **每CPU的系统寄存器**（Per-CPU system registers）\n\n  包括系统寄存器在内的所有寄存器都属于CPU私有。因此初始化这些寄存器的指令如`lcr3`, `ltr`, `lgdt`等，必须在每个CPU上都被执行。函数`env_init_percpu()`和`trap_init_percpu`的功能就在于此。\n\n除此之外，如果之前lab中有设置其他的cpu私有初始化函数，在这个实验也要对所有cpu执行。\n\n\n\n**exercise 3**\n\n修改`kern/pmap.c`中的`mem_init_mp()`，使CPU内核栈映射到相应的虚拟内存。\n\n```c\n// Modify mappings in kern_pgdir to support SMP\n//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)\n//\nstatic void\nmem_init_mp(void)\n{\n\t// Map per-CPU stacks starting at KSTACKTOP, for up to 'NCPU' CPUs.\n\t//\n\t// For CPU i, use the physical memory that 'percpu_kstacks[i]' refers\n\t// to as its kernel stack. CPU i's kernel stack grows down from virtual\n\t// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is\n\t// divided into two pieces, just like the single stack you set up in\n\t// mem_init:\n\t//     * [kstacktop_i - KSTKSIZE, kstacktop_i)\n\t//          -- backed by physical memory\n\t//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)\n\t//          -- not backed; so if the kernel overflows its stack,\n\t//             it will fault rather than overwrite another CPU's stack.\n\t//             Known as a \"guard page\".\n\t//     Permissions: kernel RW, user NONE\n\t//\n\t// LAB 4: Your code here:\n\tint i;\n\tfor(i = 0; i < NCPU; i++){\n\t\tboot_map_region(kern_pgdir,\n\t\t\t\t\t\tKSTACKTOP - i*(KSTKSIZE+KSTKGAP) - KSTKSIZE,\n\t\t\t\t\t\tKSTKSIZE,\n\t\t\t\t\t\tPADDR(percpu_kstacks[i]),\n\t\t\t\t\t\tPTE_W);\t\t\n\t}\n}\n```\n\n完成后我们就可以通过`check_kern_pgdir()`。\n\n\n\n**exercise 4**\n\n`kern/trap.c`中的`trap_init_percpu()`初始化了BSP的TSS和TSS描述符（它可以在lab3中给正常工作，但是本实验运行在其他CPU时不能正常工作），我们需要修改代码以使其支持所有CPU。\n\n> 注意：全局变量`ts`应该废弃\n\n很简单，只需要仿照之前的代码，将对应的ts部分修改到每个CPU各自的ts。\n\n```c\n// Initialize and load the per-CPU TSS and IDT\nvoid\ntrap_init_percpu(void)\n{\n\t// The example code here sets up the Task State Segment (TSS) and\n\t// the TSS descriptor for CPU 0. But it is incorrect if we are\n\t// running on other CPUs because each CPU has its own kernel stack.\n\t// Fix the code so that it works for all CPUs.\n\t//\n\t// Hints:\n\t//   - The macro \"thiscpu\" always refers to the current CPU's\n\t//     struct CpuInfo;\n\t//   - The ID of the current CPU is given by cpunum() or\n\t//     thiscpu->cpu_id;\n\t//   - Use \"thiscpu->cpu_ts\" as the TSS for the current CPU,\n\t//     rather than the global \"ts\" variable;\n\t//   - Use gdt[(GD_TSS0 >> 3) + i] for CPU i's TSS descriptor;\n\t//   - You mapped the per-CPU kernel stacks in mem_init_mp()\n\t//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments\n\t//     from doing IO (0 is not the correct value!)\n\t//\n\t// ltr sets a 'busy' flag in the TSS selector, so if you\n\t// accidentally load the same TSS on more than one CPU, you'll\n\t// get a triple fault.  If you set up an individual CPU's TSS\n\t// wrong, you may not get a fault until you try to return from\n\t// user space on that CPU.\n\t//\n\t// LAB 4: Your code here:\n\t// Setup a TSS so that we get the right stack\n\t// when we trap to the kernel.\n\tthiscpu -> cpu_ts.ts_esp0 = (uintptr_t)percpu_kstacks[cpunum()];\n\tthiscpu -> cpu_ts.ts_ss0 = GD_KD;\n\tthiscpu -> cpu_ts.ts_iomb = sizeof(struct Taskstate);\n\t// Initialize the TSS slot of the gdt.\n\tgdt[(GD_TSS0 >> 3) + cpunum()] = SEG16(STS_T32A, (uint32_t)(&(thiscpu->cpu_ts)), sizeof(struct Taskstate) - 1, 0);\n\tgdt[(GD_TSS0 >> 3) + cpunum()].sd_s = 0;\n\t// Load the TSS selector (like other segment selectors, the\n\t// bottom three bicurts are special; we leave them 0)\n\tltr(GD_TSS0 + (cpunum() << 3));\n\t// Load the IDT\n\tlidt(&idt_pd);\n}\n```\n\n完成后运行`make qemu CPUS=4`，输出如下：\n\n```\ncheck_page_free_list() succeeded!\ncheck_page_installed_pgdir() succeeded!\nSMP: CPU 0 found 4 CPU(s)\nenabled interrupts: 1 2\nSMP: CPU 1 starting\nSMP: CPU 2 starting\nSMP: CPU 3 starting\n```\n\n\n\n### A.4 Locking\n\n当前我们的代码会在`mp_main()`初始化完成所有AP之后陷入自旋（spin）。在让这些AP做出下一步操作之前，我们需要解决多个CPU同时执行内核代码的竞争条件。\n\n最简单的方式就是使用一个大内核锁（big kernel lock）。这个大内核锁是一个单一的全局锁，当一个环境进入内核模式的时候就可以被获取，然后返回到用户态的时候被释放。在这种模型下，用户模式的环境可以在任意多个CPU下并发运行（concurrently），但是只有一个环境能处于内核态，其余环境进入内核态需要强制等待。\n\n`kern/spinlock.h`中声明了这个大内核锁的实现函数`kernel_lock()`。同时它提供了`lock_kernel()`和`unlock_kernel()`两个函数用于上锁和解锁，我们需要在以下四个场景使用大内核锁：\n\n* `i386_init()`：BSP唤醒其它CPU之前进行上锁\n\n* `mp_main()`：初始化AP之后进行上锁，然后调用`sched_yield()`在当前AP上运行环境\n\n* `trap()`：从用户模式陷入内核之前获得大锁进行上锁\n\n  > 这里注意，内核态异常不能上锁（会死锁），我们需要用`tf_cs`检查环境是否位于用户态\n\n* `env_run()`：在切换回用户态之前进行解锁。时机不对会导致竞争或死锁\n\n**exercise 5**\n\n按照以上所给出的场景和函数，实现大锁机制。\n\n* `i386_init()`\n\n```c\n...\n// Lab 4 multiprocessor initialization functions\n\tmp_init();\n\tlapic_init();\n\n\t// Lab 4 multitasking initialization functions\n\tpic_init();\n\n\t// Acquire the big kernel lock before waking up APs\n\t// Your code here:\n\tlock_kernel();\n\t// Starting non-boot CPUs\n\tboot_aps();\n...\n```\n\n* `mp_main()`\n\n```c\n// Setup code for APs\nvoid\nmp_main(void)\n{\n\t// We are in high EIP now, safe to switch to kern_pgdir\n\tlcr3(PADDR(kern_pgdir));\n\tcprintf(\"SMP: CPU %d starting\\n\", cpunum());\n\n\tlapic_init();\n\tenv_init_percpu();\n\ttrap_init_percpu();\n\txchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up\n\n\t// Now that we have finished some basic setup, call sched_yield()\n\t// to start running processes on this CPU.  But make sure that\n\t// only one CPU can enter the scheduler at a time!\n\t//\n\t// Your code here:\n\tlock_kernel();\n\tsched_yield();\n\t// Remove this after you finish Exercise 6\n\tfor (;;);\n}\n```\n\n* `trap()`\n\n```c\n...\nif ((tf->tf_cs & 3) == 3) {\n\t\t// Trapped from user mode.\n\t\t// Acquire the big kernel lock before doing any\n\t\t// serious kernel work.\n\t\t// LAB 4: Your code here.\n\t\tassert(curenv);\n\t\tlock_kernel();\n\t\t// Garbage collect if current enviroment is a zombie\n\t\tif (curenv->env_status == ENV_DYING) {\n\t\t\tenv_free(curenv);\n\t\t\tcurenv = NULL;\n\t\t\tsched_yield();\n\t\t}\n...\n```\n\n* `env_run()`\n\n```c\nvoid\nenv_run(struct Env *e)\n{\n...\n\tlcr3(PADDR(e->env_pgdir));\n\tcprintf(\" env_tf :  %x\\n \", &curenv -> env_tf);\n\tunlock_kernel();\n\tenv_pop_tf(&curenv->env_tf);\n}\n```\n\n我们还需要完成exercies 6才能检查是否正确。\n\n**Question**\n\nQ：看起来大内核锁机制保证了同时只能有一个CPU在内核态运行。那为什么我们还需要将每个CPU的内核栈分开？请描述一个场景，我们不分开内核栈而导致错误。\n\nA：假设CPU0因中断陷入内核并在内核栈中保留了相关的信息，此时若CPU1也发生中断而陷入内核，在同一个内核栈的情况下，CPU0中的信息将会被覆盖从而导致出现错误。\n\n\n\n### A.5 Round-Robin Scheduling\n\n我们的下一个任务是改变jos内核，实现对用户环境的轮询调度：\n\n* `kern/sched.c`中的`sched_yield()`负责从用户环境中选择一个新环境执行。其按照顺序遍历`envs[]`数组，从上一次运行的环境开始，找到第一个`ENV_RUNNABLE`的环境然后调用`env_run()`。\n* `sched_yield()`**一定不能**在两个CPU上同时运行相同的环境。它可以通过环境的状态是否为`ENV_RUNNING`来判断这个环境是否正运行在某个CPU上。\n* 一个新的系统调用`sys_yield()`，使得用户环境可以通过该系统调用唤醒`sched_yield()`，主动放弃CPU。\n\n**exercise 6**\n\n在`sched_yield()`中实现上述机制，注意我们要修改`syscall()`来支持对`sys_yield()`的调度。\n\n确保在`mp_main()`中调用`sched_yield()`。\n\n修改`kern/init.c`来创建三个或者更多的用户环境，使其同时运行`user/yield.c`程序。\n\n* `sched_yield()`\n\n```c\n// Choose a user environment to run and run it.\nvoid\nsched_yield(void)\n{\n\tstruct Env *idle;\n\n\t// Implement simple round-robin scheduling.\n\t//\n\t// (1) Search through 'envs' for an ENV_RUNNABLE environment in\n\t// circular fashion starting just after the env this CPU was\n\t// last running.  Switch to the first such environment found.\n\t//\n\t// (2) If no envs are runnable, but the environment previously\n\t// running on this CPU is still ENV_RUNNING, it's okay to\n\t// choose that environment.\n\t//\n\t// Never choose an environment that's currently running on\n\t// another CPU (env_status == ENV_RUNNING). If there are\n\t// no runnable environments, simply drop through to the code\n\t// below to halt the cpu.\n\n\t// LAB 4: Your code here.\n\t//\n\tsize_t cur_idx;\n\n\tint cur_flag = 1;\n\tint start_loc = 0;\n\tenvid_t i;\n\tif(thiscpu->cpu_env == NULL){\n\t\tfor(i = 0; i < NENV; i++){\n\t\t\tif(envs[i].env_status == ENV_RUNNABLE){\n\t\t\t\tenv_run(&envs[i]);\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t// (1)\n\t\tcur_idx = ENVX(thiscpu->cpu_env -> env_id);\n\t\ti = (cur_idx == NENV - 1)? 0 : cur_idx + 1;\n\t\tfor(;i != cur_idx; i = ((i == NENV - 1)? 0 : i+1)){\n\t\t\tif(envs[i].env_status == ENV_RUNNABLE){\n\t\t\t\tenv_run(&envs[i]);\n\t\t\t}\n\t\t}\n\t\t// (2)\n\t\tif(thiscpu->cpu_env->env_status == ENV_RUNNING){\n\t\t\tenv_run(&envs[i]);\n\t\t}\n\t}\n\t// sched_halt never returns\n\tsched_halt();\n}\n```\n\n* `syscall()`\n\n```c\n// Dispatches to the correct kernel function, passing the arguments.\nint32_t\nsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)\n{\n\t// Call the function corresponding to the 'syscallno' parameter.\n\t// Return any appropriate return value.\n\t// LAB 3: Your code here.\n\tswitch (syscallno) {\n\tcase SYS_cputs:\n\t\t//check memory before dereference\n\t\tuser_mem_assert(curenv, (void *)a1, (size_t)a2, PTE_U);\n\t\tsys_cputs((const char *)a1, a2);\n\t\treturn 0;\n\tcase SYS_cgetc:\n\t\treturn sys_cgetc();\n\tcase SYS_getenvid:\n\t\treturn sys_getenvid();\n\tcase SYS_env_destroy:\n\t\treturn sys_env_destroy((envid_t)a1);\n\t\tbreak;\n\tcase SYS_yield:\n\t\tsys_yield();\n\t\treturn 0;\n\tdefault:\n\t\treturn -E_INVAL;\n\t}\n}\n```\n\n* `kern/init.c`\n\n运行`user/yield.c`三次的方式并不难，我们连续三次创建环境即可。\n\n```c\n#if defined(TEST)\n\t// Don't touch -- used by grading script!\n\tENV_CREATE(TEST, ENV_TYPE_USER);\n#else\n\t// Touch all you want.\n\t//ENV_CREATE(user_primes, ENV_TYPE_USER);\n\tENV_CREATE(user_yield, ENV_TYPE_USER);\n\tENV_CREATE(user_yield, ENV_TYPE_USER);\n\tENV_CREATE(user_yield, ENV_TYPE_USER);\n#endif // TEST*\n\n\t// Schedule and run the first user environment!\n\tsched_yield();\n}\n```\n\nmake qemu：\n\n```\nSMP: CPU 0 found 1 CPU(s)\nenabled interrupts: 1 2\n[00000000] new env 00001000\n[00000000] new env 00001001\n[00000000] new env 00001002\nHello, I am environment 00001000.\nHello, I am environment 00001001.\nHello, I am environment 00001002.\nBack in environment 00001000, iteration 0.\nBack in environment 00001001, iteration 0.\nBack in environment 00001002, iteration 0.\nBack in environment 00001000, iteration 1.\nBack in environment 00001001, iteration 1.\nBack in environment 00001002, iteration 1.\nBack in environment 00001000, iteration 2.\nBack in environment 00001001, iteration 2.\nBack in environment 00001002, iteration 2.\nBack in environment 00001000, iteration 3.\nBack in environment 00001001, iteration 3.\nBack in environment 00001002, iteration 3.\nBack in environment 00001000, iteration 4.\nAll done in environment 00001000.\n[00001000] exiting gracefully\n[00001000] free env 00001000\nBack in environment 00001001, iteration 4.\nAll done in environment 00001001.\n[00001001] exiting gracefully\n[00001001] free env 00001001\nBack in environment 00001002, iteration 4.\nAll done in environment 00001002.\n[00001002] exiting gracefully\n[00001002] free env 00001002\nNo runnable environments in the system!\nWelcome to the JOS kernel monitor!\n```\n\n**Questions**\n\nQ：我们在`env_run()`的实现中调用了`lcr3()`。在这个函数的调用之前以及调用之后，你的代码对`env_run()`的参数`e`进行了引用。在加载`%cr3`寄存器之后，MMU的寻址上下文就改变了（页目录切换了）。为什么我们在页目录改变前后都可以对`e`进行解引用？\n\nA：在我们lab3实现的过程中，任务的`env_pgdir`是基于`kern_pgdir`产生的，也就是说对于`UTOP`上的地址映射关系在两个页表中是一样的。而`e`所对应的`Env`结构由操作系统管理，在虚拟空间地址都是`UENVS-UPAGES`的范围，因此在所有用户环境的映射也是一样的。\n\nQ：当内核进行用户环境切换的时候，必须要保证旧的环境的寄存器值被保存起来以便之后恢复。这个过程是在哪里发生的？\n\nA：用户环境进行环境切换是通过系统调用`syscall()`，最终通过`kern/trap.c`中的`trap()`产生异常然后陷入内核。因而中断触发会进入`trapentry.S`的代码入口然后调用`trap()`，系统会在栈上创建一个`Trapframe`然后赋给用户环境的`env_tf`从而保护用户环境寄存器。如下所示代码片段：\n\n```assembly\n_alltraps:\n\t;ds es\n\tpush %ds\n\tpush %es\n\tpushal   #;其余寄存器\n\n\t#;load DS and ES with GD_KD (不能用立即数设置段寄存器)\n\tmov $GD_KD, %ax\n\tmov %ax, %ds\n\tmov %ax, %es\n\tpushl %esp\n\tcall trap\n```\n\n这里我们将环境的现场全部保护起来压栈使得其结构与`Trapframe`一样，然后调用`trap()`就可以使得其作为`tf`被保存。\n\n\n\n\n### A.6 System Calls for Environment Creation\n\n现在我们的内核已经能够运行用户环境并且在不同的用户环境之间进行切换了，但是其仍旧只能被限制于运行内核初始化时创建的用户环境。我们现在需要实现一些必要的jos系统给调用使得用户能够创建自己的用户环境并且启动其它的用户环境。\n\nUnix系统提供了`fork()`系统调用作为进程创建原语（process creation primitive）。Unix的`fork()`拷贝调用进程（父进程）的整个进程空间以创建子进程，这种情况下父子进程之间唯一可观察的区别就是他们的进程ID分别为`pid`和`ppid`（可以通过`getpid()`和`getppid()`查看）。在父进程中，`fork()`函数返回子进程的ID，而在子进程中返回0.\n\n默认情况下，每一个进程都有其私有的地址空间，而且任意一个进程对于内核的修改都是对于其他进程而言不可见的。\n\n现在我们将实现一个jos系统调用原语以使用户创建新的用户模式环境。完成这些这些系统调用，我们会不止实现了类Unix下的`fork()`，而且涉及其他类型环境的创建。我们将实现以下的系统调用集：\n\n* `sys_exofork()`：创建一个几乎为空白状态的新环境：这个地址空间没有任何用户部分映射，也无法运行。新环境将会有和父亲环境在执行`sys_exofork()`系统调用时完全一致的寄存器状态，而在父亲环境执行该系统调用后会返回新创建环境的`envid_t`（如果创建失败则返回错误码），子环境返回0。由于子环境最初被标记为不可执行，故在子环境中`sys_exofork()`直到父环境显式标记子环境为可执行，其才会在子环境中返回。\n* `sys_env_set_status()`：设置指定的环境的状态为`ENV_RUNNABLE`或者`RUN_NOT_RUNNABLE`。这个系统调用通常在一个新环境的地址空间和寄存器状态完全初始化完成之后将其标记为可执行。\n* `sys_page_alloc()`：分配一页的物理内存然后将其映射到特定环境的地址空间的给定虚拟地址。\n* `sys_page_map()`：将一个页映射关系（不是页的具体内容）从一个环境的地址空间拷贝到另一个环境的地址空间。实现共享内存。\n* `sys_page_unmap()`：将给定环境的虚拟地址页面解除映射。\n\n上述所有系统调用集都需要接受一个环境ID，jos的内核支持了环境号`0`代表当前环境。在`kern/env.c`中的`envid2env()`实现了这种映射。\n\n已经在`user/dumpfork.c`中提供了非常原始的类Unix的`fork()`实现。测试程序用上述系统调用创建并运行一个当前地址空间拷贝的子进程，然后两个环境使用`sys_yield()`来回切换。父进程在10次迭代后退出；子进程在20次迭代后退出。\n\n**exercise 7**\n\n实现上述在`kern/syscall.c`中的系统调用集，确保`syscall()`可以调用它们。你可能需要用到`kern/pmap.c`和`kern/env.c`中的一些函数，尤其是`envid2env()`。\n\n现在你使用`envid2env()`的时候，将`checkperm`参数设置为1，确保当你的一些系统调用参数无效的时候会返回`-E_INVAL`。使用`user/dumpfork.c`测试你实现的这些系统调用。\n\n* `sys_exofork()`\n\n这里的关键点在于如何让子环境对该系统调用返回0。\n\n这个用户态的触发系统调用的函数定义实际上在`inc/lib.h`中：\n\n```c\n// This must be inlined.  Exercise for reader: why?\nstatic inline envid_t __attribute__((always_inline))\nsys_exofork(void)\n{\n\tenvid_t ret;\n\tasm volatile(\"int %2\"\n\t\t     : \"=a\" (ret)\n\t\t     : \"a\" (SYS_exofork), \"i\" (T_SYSCALL));\n\treturn ret;\n}\n```\n\n整个过程的控制流如下：父环境显式调用该系统调用，通过内联汇编`int %2`触发中断，然后硬件控制流通过`trapentry.S`中的入口地址进行保护现场并将控制流转到`trap.c`最终进入`trap_dispatch()`:\n\n```c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n...\n\tif (tf->tf_trapno == T_SYSCALL)\n\t{\n\t\tint32_t retval = syscall(tf->tf_regs.reg_eax,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_edx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_ecx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_ebx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_edi,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_esi);\n\t\tif (retval < 0)\n\t\t{\n\t\t\tpanic(\"[trap_dispatch] syscall : %e\\n\", retval);\n\t\t}\n\t\ttf->tf_regs.reg_eax = retval;\n\t\treturn;\n\t}\n...\n}\n```\n\n可见这里系统调用获取返回值的方式是：`env_tf`中的`reg_eax`寄存器设置为将系统调用的返回值。然后回到`trap`中直接通过调用`env_run()`来返回用户态：\n\n```c\n// Dispatch based on what type of trap occurred\n\ttrap_dispatch(tf);         // <-  这里是上面的返回，返回值存在了其tf的reg_eax中\n\n\t// If we made it to this point, then no other environment was\n\t// scheduled, so we should return to the current environment\n\t// if doing so makes sense.\n\tif (curenv && curenv->env_status == ENV_RUNNING)\n\t\tenv_run(curenv);\n\telse\n\t\tsched_yield();\n```\n\n而在我们的`sys_exofork()`执行过程中，只有父环境发生了系统调用，在陷入内核之前保护了用户环境的下一条指令`eip`（详见lab3 A.6部分），子环境是没有产生中断以及系统调用的，子环境会从其地址空间的`eip`指定的代码处继续执行（别忘了子环境的寄存器实际上就是拷贝父环境的）。因此整个`kern/trap.c`以及`kern/syscall.c`并没有影响子环境，自环境只会等待内核调用`sched_yield()`开始执行，因此返回值就是我们伪造的`eax=0`：\n\n```c\n// Allocate a new environment.\n// Returns envid of new environment, or < 0 on error.  Errors are:\n//\t-E_NO_FREE_ENV if no free environment is available.\n//\t-E_NO_MEM on memory exhaustion.\nstatic envid_t\nsys_exofork(void)\n{\n\t// Create the new environment with env_alloc(), from kern/env.c.\n\t// It should be left as env_alloc created it, except that\n\t// status is set to ENV_NOT_RUNNABLE, and the register set is copied\n\t// from the current environment -- but tweaked so sys_exofork\n\t// will appear to return 0.\n\n\t// LAB 4: Your code here.\n\tstruct Env * cldenv;\n\tint errno;\n\tif((errno = env_alloc(&cldenv, curenv->env_id)) < 0){\n\t\treturn errno;\n\t}\n\t//same as parent\n\tcldenv -> env_tf = curenv-> env_tf;\n\tcldenv -> env_status = ENV_NOT_RUNNABLE;\n\t// child environment\n\tcldenv -> env_tf.tf_regs.reg_eax = 0;   //for cld \n\treturn cldenv -> env_id;        //for parent\n}\n```\n\n\n\n* `sys_env_set_status()`\n\n```c\n// Set envid's env_status to status, which must be ENV_RUNNABLE\n// or ENV_NOT_RUNNABLE.\n//\n// Returns 0 on success, < 0 on error.  Errors are:\n//\t-E_BAD_ENV if environment envid doesn't currently exist,\n//\t\tor the caller doesn't have permission to change envid.\n//\t-E_INVAL if status is not a valid status for an environment.\nstatic int\nsys_env_set_status(envid_t envid, int status)\n{\n\t// Hint: Use the 'envid2env' function from kern/env.c to translate an\n\t// envid to a struct Env.\n\t// You should set envid2env's third argument to 1, which will\n\t// check whether the current environment has permission to set\n\t// envid's status.\n\t// LAB 4: Your code here.\n\tif((status != ENV_RUNNABLE) && (status != ENV_NOT_RUNNABLE)){\n\t\treturn -E_INVAL;\n\t}\n\tstruct Env * env;\n\tint errno;\n\tif((errno = envid2env(envid, &env, 1) < 0){\n\t\treturn errno;\n\t}\n\tenv->env_status = status;\n\treturn 0;\n}\n```\n\n\n\n* `sys_page_alloc()`\n\n```c\n// Allocate a page of memory and map it at 'va' with permission\n// 'perm' in the address space of 'envid'.\n// The page's contents are set to 0.\n// If a page is already mapped at 'va', that page is unmapped as a\n// side effect.\n//\n// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,\n//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.\n//\n// Return 0 on success, < 0 on error.  Errors are:\n//\t(1) -E_BAD_ENV if environment envid doesn't currently exist,\n//\t\t or the caller doesn't have permission to change envid.\n//\t(2) -E_INVAL if va >= UTOP, or va is not page-aligned.\n//\t(3) -E_INVAL if perm is inappropriate (see above).\n//\t(4) -E_NO_MEM if there's no memory to allocate the new page,\n//\t\t or to allocate any necessary page tables.\nstatic int\nsys_page_alloc(envid_t envid, void *va, int perm)\n{\n\t// Hint: This function is a wrapper around page_alloc() and\n\t//   page_insert() from kern/pmap.c.\n\t//   Most of the new code you write should be to check the\n\t//   parameters for correctness.\n\t//   If page_insert() fails, remember to free the page you\n\t//   allocated!\n\n\t// LAB 4: Your code here.\n\tstruct Env * env;\n\t// (1)\n\tif(envid2env(envid, &env, 1) < 0){\n\t\treturn -E_BAD_ENV;\n\t}\n\t// (2)\n\tif((uintptr_t)va > UTOP || PGOFF(va)){\n\t\treturn -E_INVAL;\n\t}\n\t// (3)\n\tif(!(perm & PTE_U) || !(perm & PTE_P) || (perm & (~PTE_SYSCALL))){\n\t\treturn -E_INVAL;\n\t}\n\t// (4)\n\tstruct PageInfo * pg_info;\n\tpg_info = page_alloc(ALLOC_ZERO);\n\tif(!pg_info){\n\t\treturn -E_NO_MEM;\n\t}\n\tif(page_insert(env->env_pgdir, pg_info, va, perm) < 0){\n\t\t//page table could not be allocated\n\t\tpage_free(pg_info);\n\t\treturn -E_NO_MEM;\n\t}\n\treturn 0;\n}\n```\n\n\n\n* `sys_page_map()`\n\n```c\n// Map the page of memory at 'srcva' in srcenvid's address space\n// at 'dstva' in dstenvid's address space with permission 'perm'.\n// Perm has the same restrictions as in sys_page_alloc, except\n// that it also must not grant write access to a read-only\n// page.\n//\n// Return 0 on success, < 0 on error.  Errors are:\n//\t-E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,\n//\t\tor the caller doesn't have permission to change one of them.\n//\t-E_INVAL if srcva >= UTOP or srcva is not page-aligned,\n//\t\tor dstva >= UTOP or dstva is not page-aligned.\n//\t-E_INVAL is srcva is not mapped in srcenvid's address space.\n//\t-E_INVAL if perm is inappropriate (see sys_page_alloc).\n//\t-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's\n//\t\taddress space.\n//\t-E_NO_MEM if there's no memory to allocate any necessary page tables.\nstatic int\nsys_page_map(envid_t srcenvid, void *srcva,\n\t     envid_t dstenvid, void *dstva, int perm)\n{\n\t// Hint: This function is a wrapper around page_lookup() and\n\t//   page_insert() from kern/pmap.c.\n\t//   Again, most of the new code you write should be to check the\n\t//   parameters for correctness.\n\t//   Use the third argument to page_lookup() to\n\t//   check the current permissions on the page.\n\n\t// LAB 4: Your code here.\n\tstruct Env *srcenv, *dstenv;\n\tif((envid2env(srcenvid, &srcenv, 1) < 0) || (envid2env(dstenv, &dstenv, 1) < 0)){\n\t\treturn -E_BAD_ENV;\n\t}\n    if (((uintptr_t)srcva >= UTOP) || ((uintptr_t)dstva >= UTOP) ||\n        (PGOFF(srcva) != 0) || (PGOFF(dstva) != 0)) {\n        return -E_INVAL;\n    }\n\n    struct PageInfo *srcpage;\n    pte_t * src_pte;\n    // get src_va pageinfo and src_ page table entry\n    if ((srcpage = page_lookup(srcenv->env_pgdir, srcva, &src_pte)) ==\n        NULL) {\n        return -E_INVAL;\n    }\n    // check perm\n    if ((perm & (~PTE_SYSCALL)) || !(perm & PTE_U) || !(perm & PTE_P)) {\n        return -E_INVAL;\n    }\n\n    // perm has PTE_W -> srcva writable\n    if ((perm & PTE_W) && (!((*src_pte) & PTE_W))) {\n        // perm has PTE_W while srcva ISN'T writable\n        return -E_INVAL;\n    }\n\n    // insert srcpage to dst_va\n    if (page_insert(dstenv->env_pgdir, srcpage, dstva, perm) < 0) {\n\t\treturn -E_NO_MEM;\n\t}\n    return 0;\n}\n```\n\n\n\n* `sys_page_unmap()`\n\n```c\n// Unmap the page of memory at 'va' in the address space of 'envid'.\n// If no page is mapped, the function silently succeeds.\n//\n// Return 0 on success, < 0 on error.  Errors are:\n//\t-E_BAD_ENV if environment envid doesn't currently exist,\n//\t\tor the caller doesn't have permission to change envid.\n//\t-E_INVAL if va >= UTOP, or va is not page-aligned.\nstatic int\nsys_page_unmap(envid_t envid, void *va)\n{\n\t// Hint: This function is a wrapper around page_remove().\n\n\t// LAB 4: Your code here.\n\tstruct Env *env;\n\tif (envid2env(envid, &env, true) < 0){\n\t\treturn -E_BAD_ENV;\n\t}\n\tif ((uintptr_t)va >= UTOP || PGOFF(va) != 0){\n\t\treturn -E_INVAL;\n\t}\n\tpage_remove(env->env_pgdir, va);\n\treturn 0;\n}\n```\n\n接下来修改系统调用：\n\n```c\nint32_t\nsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)\n{\n...\n\tcase SYS_exofork:\n\t\treturn sys_exofork();\n\tcase SYS_env_set_status:\n\t\treturn sys_env_set_status((envid_t)a1, (int)a2);\n\tcase SYS_page_alloc:\n\t\treturn sys_page_alloc((envid_t)a1, (void*)a2, (int)a3);\n\tcase SYS_page_map:\n\t\treturn sys_page_map((envid_t)a1, (void*)a2, (envid_t)a3, (void*)a4, (int)a5);\n\tcase SYS_page_unmap:\n\t\treturn sys_page_unmap((envid_t)a1, (void*)a2);\n\n\tcase SYS_env_set_pgfault_upcall:\n\t\treturn sys_env_set_pgfault_upcall((envid_t)a1, (void *)a2);\n...\n}\n```\n\n\n\n全部实现之后，我们可以通过Part A的`dumbfork`测试。\n\n\n\n## Part B: Copy-on-Write Fork\n\n前文提及，Unix下的`fork()`系统调用将整个调用进程的地址空间复制给了子进程。\n\nxv6实现`fork()`是通过从父进程页中所有数据复制到子进程的新页。这实际上也是测试案例`dumbfork()`的做法。`fork()`操作中，代价最大的（expensive）部分就是将父进程的整个地址空间拷贝给子进程。\n\n然而通常来说，一个调用`fork()`最普遍的场景就是，在子进程中紧接着调用`exec()`，用一个新程序来替换子进程的内存（这也是一个典型shell所做的事情）。在这种情况下，复制父进程所需的大量开销被浪费，因为在子进程调用`exec()`之前只用了很少内存。\n\n因此，新版本的Unix利用了虚拟内存硬件来允许父进程和子进程共享内存映射到各自地址空间的内存，直到有其中一个进程进行实际修改。这个技术就是著名的**写时复制（copy-on-write）**。\n\n这个机制的原理是，`fork()`执行之后只将父进程的地址映射拷贝给子进程，而非地址的实际页面内容。而且将共享的页面标记权限为只读。当这两个进程中的任意一个尝试修改共享页面的时候，处理器会抛出页错误（page fault）。\n\n内核在这时会发现这些页面实际上是“虚拟”或者说是“写时复制”的，然后此时在给发生错误的进程创建一个该页的新的且具有可写权限的私有页面。\n\n也就是说，**这样只有在实际进行修改页面的时候，这个页面的内容才会真正被复制。**那么这种机制使得`exec()`降低了开销：实际上子进程可能只需要在调用`exec()`之前复制当前栈上的一页。\n\n下面，我们就需要实现一个Unix-like的具有写时复制的`fork()`，作为**用户空间库函数**例程。（之所以作为用户库函数而不是内核函数，是为了让内核保持简单，同时能让用户定制自身`fork()`的实现）\n\n\n\n### B.1 User-level page fault handling\n\n用户级的写时复制`fork()`的第一个关键点，在于能够使得用户发现由写权限问题引发的page fault的能力。\n\n通常来说，是设置一个地址空间用以让page fault来指示发生错误时应该采取哪种行为。比如说，大多数的Unix内核通常会为新的进程的栈区域分配一个页的大小，随着进程栈逐渐增长一直到了未映射分配的区域，就会引发page fault，然后内核再按需分配。这时典型的Unix内核需要追踪进程空间不同区域在发生page fault时应该采取何种措施（栈区发生page fault，则表示需要新的页面的分配和映射；BSS区的page faule，则表示应该分配一个新页面并且填充0再映射；对于具有可执行文件的系统，text段的page fault则表示从磁盘上的二进制文件中读取页面并映射）。\n\n和传统的内存追踪大量信息的方法不同，这个实验中我们需要让用户自己决定如何处理用户空间的每个页面错误（这些bug的损害通常不大）。这种设计方式为用户定义储存区域带来了较强的灵活性，我们之后将会使用用户级别的错误处理程序来进行映射以及访问磁盘系统的文件。\n\n\n\n#### >> Setting the Page Fault Handler\n\n为了能够处理页错误，用户环境必须向jos的内核注册一个页错误处理程序入口（page fault handler entrypoint）。用户环境通过系统调用`sys_env_set_pgfault_upcall()`来注册错误处理程序入口。实验中已经对于`Env`结构增加了新的成员`env_pgfault_upcall`来记录该信息。\n\n**exercise 8**\n\n实现`sys_env_set_pgfault_upcall()`系统调用。\n\n```c\n// Set the page fault upcall for 'envid' by modifying the corresponding struct\n// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the\n// kernel will push a fault record onto the exception stack, then branch to\n// 'func'.\n//\n// Returns 0 on success, < 0 on error.  Errors are:\n//\t-E_BAD_ENV if environment envid doesn't currently exist,\n//\t\tor the caller doesn't have permission to change envid.\nstatic int\nsys_env_set_pgfault_upcall(envid_t envid, void *func)\n{\n\t// LAB 4: Your code here.\n\tstruct Env * env;\n\tif(envid2env(envid, &env, 1) < 0){\n\t\treturn -E_BAD_ENV;\n\t}\n\tenv->env_pgfault_upcall = func;\n\treturn 0;\n}\n```\n\n我们还需要修改系统调用：\n\n```c\n\tcase SYS_env_set_pgfault_upcall:\n\t\treturn sys_env_set_pgfault_upcall((envid_t)a1, (void *)a2);\n```\n\n\n\n#### >> Normal and Exception Stacks in User Environments\n\n正常执行时，jos用户环境将会运行正常栈（normal user stack）：从`USTACKTOP`向下增长，压入的栈数据会存放于`USTACKTOP - PGSIZE`到`USTACKTOP - 1`的区域。但是如果用户环境需要处理page fault，则需要切换到异常处理栈（user exception stack）。我们将会让jos内核实现一个自动切换机制，使得用户环境实现程序栈和异常处理栈的切换。\n\njos已经在虚拟内存中规划好了这个异常处理栈，从`UXSTACKTOP`开始向下增长，仍然大小是一个页。当用户环境在异常处理栈上运行时，用户级别页错误处理程序可以使用jos系统调用来映射新的页面以解决page fault，最终通过一些汇编代码回到正常栈。\n\n对于每一个需要支持页错误处理机制的用户环境，其都需要手动为自己的异常处理栈分配内存，可以通过之前实现的`sys_page_alloc()`系统调用来实现。\n\n\n\n#### >> Invoking the User Page Fault Handler\n\n现在我们需要修改`kern/trap.c`中的缺页异常处理函数，使其能够按照特定的方式处理用户模式页错误。我们将用户环境发生错误时的状态称为**异常状态（trap-time state）**。\n\n如果我们没有注册任何页错误处理函数，jos的内核将会废除用户环境并且抛出一条信息，如同之前一样。否则，**内核将会在用户的异常处理栈上建立一个`struct UTrapframe`**（在`inc/trap.h`中定义）：\n\n```\n                    <-- UXSTACKTOP\ntrap-time esp\ntrap-time eflags\ntrap-time eip\ntrap-time eax       start of struct PushRegs\ntrap-time ecx\ntrap-time edx\ntrap-time ebx\ntrap-time esp\ntrap-time ebp\ntrap-time esi\ntrap-time edi       end of struct PushRegs\ntf_err (error code)\nfault_va            <-- %esp when handler is run\n```\n\n然后**内核会让用户环境在异常处理栈上运行处理程序**。`fault_va`是导致页错误发生的虚拟地址。\n\n如果这个时候，用户在执行页错误处理程序的时候再次发生页错误，就说明页错误处理程序本身存在问题。在这种情况下，我们不应该再次从`UXSTACKTOP`处再建立异常处理栈，而是应该在当前的异常处理栈（即`tf->tf_esp`）上面一入一个32bits的空字，再压入异常帧`struct UTrapframe`。\n\n要检查我们是否在用户环境的页错误处理程序运行中又发生页错误，只需要检查`tf->tf_esp`是否在`UXSTACKTOP - PGSIZE`到`UXSTACKTOP - 1`范围之间。\n\n**exercise 9**\n\n实现`kern/trap.c`中的`page_fault_handler()`。注意上述提及的异常处理栈的机制。（当用户环境用完异常处理栈的空间该怎么办？）\n\n* `page_fault_handler()`\n\n再次分析控制流，当用户环境陷入中断时将`tf`保护起来，这里传递的参数`tf`实际上就是用户环境的现场。我们在这个系统调用之后需要将控制权还给用户环境，但是**需要让用户环境进入页异常处理函数（如果有）并且将栈切换为异常处理栈**。也就是说我们需要改变`curenv`的`ip`以及`esp`。\n\n同时我们只需要将`tf`中保护的现场原样传递给`utf`即可。\n\n```c\nvoid\npage_fault_handler(struct Trapframe *tf)\n{\n\tuint32_t fault_va;\n\n\t// Read processor's CR2 register to find the faulting address\n\tfault_va = rcr2();\n\n\t// Handle kernel-mode page faults.\n\n\t// LAB 3: Your code here.\n\tif((tf->tf_cs & 3) == 0){\n\t\tpanic(\"[page_fault_handler] Page fault in kernel.\\n\");\n\t}\n\t// We've already handled kernel-mode exceptions, so if we get here,\n\t// the page fault happened in user mode.\n\n\t// Call the environment's page fault upcall, if one exists.  Set up a\n\t// page fault stack frame on the user exception stack (below\n\t// UXSTACKTOP), then branch to curenv->env_pgfault_upcall.\n\t//\n\t// The page fault upcall might cause another page fault, in which case\n\t// we branch to the page fault upcall recursively, pushing another\n\t// page fault stack frame on top of the user exception stack.\n\t//\n\t// It is convenient for our code which returns from a page fault\n\t// (lib/pfentry.S) to have one word of scratch space at the top of the\n\t// trap-time stack; it allows us to more easily restore the eip/esp. In\n\t// the non-recursive case, we don't have to worry about this because\n\t// the top of the regular user stack is free.  In the recursive case,\n\t// this means we have to leave an extra word between the current top of\n\t// the exception stack and the new stack frame because the exception\n\t// stack _is_ the trap-time stack.\n\t//\n\t// If there's no page fault upcall, the environment didn't allocate a\n\t// page for its exception stack or can't write to it, or the exception\n\t// stack overflows, then destroy the environment that caused the fault.\n\t// Note that the grade script assumes you will first check for the page\n\t// fault upcall and print the \"user fault va\" message below if there is\n\t// none.  The remaining three checks can be combined into a single test.\n\t//\n\t// Hints:\n\t//   user_mem_assert() and env_run() are useful here.\n\t//   To change what the user environment runs, modify 'curenv->env_tf'\n\t//   (the 'tf' variable points at 'curenv->env_tf').\n\n\t// LAB 4: Your code here.\n\tstruct UTrapframe * utf;\n\tuintptr_t utf_top;\n\t//curenv has pg fault handler\n\tif(curenv -> env_pgfault_upcall){\n\t\t//esp already in handler (recursive)\n\t\tif ((tf->tf_esp >= UXSTACKTOP - PGSIZE) && (tf->tf_esp < UXSTACKTOP)){\n\t\t\t// recursive exception stack\n\t\t\tutf_top = tf->tf_esp - sizeof(struct UTrapframe) - 4;\n\t\t}\n\t\telse{\n\t\t\tutf_top = UXSTACKTOP - sizeof(struct UTrapframe);\n\t\t}\n\n\t\t//check permission on exception stack\n\t\tuser_mem_assert(curenv, utf_top, sizeof(struct UTrapframe), PTE_W | PTE_U);\n\t\t//push UTrapframe\n\t\tutf = (struct UTrapframe *)utf_top;\n\t\tutf->utf_fault_va = fault_va;\n\t\tutf->utf_err = tf->tf_err;\n\t\tutf->utf_regs = tf->tf_regs;\n\t\tutf->utf_eip = tf->tf_eip;\n\t\tutf->utf_eflags = tf->tf_eflags;\n\t\tutf->utf_esp = tf->tf_esp;\n\t\t//modify stack and ip\n\t\t(&(curenv->env_tf))->tf_eip = (uintptr_t)curenv->env_pgfault_upcall;\n\t\t(&(curenv->env_tf))->tf_esp = utf_top;\n\t\tenv_run(curenv);\n\t}\n\t// Destroy the environment that caused the fault.\n\tcprintf(\"[%08x] user fault va %08x ip %08x\\n\",\n\t\tcurenv->env_id, fault_va, tf->tf_eip);\n\tprint_trapframe(tf);\n\tenv_destroy(curenv);\n}\n```\n\n\n\n#### >> User-mode Page Fault Entrypoint\n\n刚才我们已经实现了用户模式下页异常情况的系统调用，现在，我们需要实现汇编例程，该例程将会调用C页面错误处理程序（`sys_env_set_pgfault_upcall()`）。\n\n**exercise 10**\n\n实现`lib/pfentry.S`中的`_pgfault_upcall`例程。这部分~~最有趣~~的在于如何返回用户触发page fault的代码。我们在这里将要直接返回而无需再陷入内核。难点在于如何同时切换栈以及重新加载`eip`。\n\n* `_pgfault_upcall()`\n\n分析其汇编代码逻辑，我们知道它将`_pgfault_handler()`这个全局函数指针放入eax中并执行，这个全局函数`_pgfault_handler()`实际上就是我们的C处理页异常的例程（在`pgfault.c`中定义并且通过用户环境程序显式调用`set_pgfault_handler()`去定制该处理函数）。\n\n仔细阅读注释，这里有一些坑点：\n\n首先我们要跳转回发生异常的`eip`时，已经恢复了所有现场（包括`esp`），这里不能使用`jmp`进行跳转（因为需要一个目的地址，我们不能用寄存器存了）。而且我们不能直接`ret`（因为`ret`会改变`esp`）。所以我们应该在切换栈之前将**异常时的`eip`**装载到**异常处理栈**的栈顶，切换栈的时候设置`esp = esp-4`，然后这样使用`ret`返回时就会取出`eip`并且返回同时使`esp=esp+4`。这样做是完全合理的，非嵌套情况下的异常处理栈栈顶之上（更低的地址）是空的，而嵌套情况两个异常处理栈之间会存在32bits的空白空间，因此完全没问题。\n\n```c\n#include <inc/mmu.h>\n#include <inc/memlayout.h>\n\n// Page fault upcall entrypoint.\n\n// This is where we ask the kernel to redirect us to whenever we cause\n// a page fault in user space (see the call to sys_set_pgfault_handler\n// in pgfault.c).\n//\n// When a page fault actually occurs, the kernel switches our ESP to\n// point to the user exception stack if we're not already on the user\n// exception stack, and then it pushes a UTrapframe onto our user\n// exception stack:\n//\n//\ttrap-time esp\n//\ttrap-time eflags\n//\ttrap-time eip\n//\tutf_regs.reg_eax\n//\t...\n//\tutf_regs.reg_esi\n//\tutf_regs.reg_edi\n//\tutf_err (error code)\n//\tutf_fault_va            <-- %esp\n//\n// If this is a recursive fault, the kernel will reserve for us a\n// blank word above the trap-time esp for scratch work when we unwind\n// the recursive call.\n//\n// We then have call up to the appropriate page fault handler in C\n// code, pointed to by the global variable '_pgfault_handler'.\n\n.text\n.globl _pgfault_upcall\n_pgfault_upcall:\n\t// Call the C page fault handler.\n\tpushl %esp\t\t\t// function argument: pointer to UTF\n\tmovl _pgfault_handler, %eax\n\tcall *%eax\n\taddl $4, %esp\t\t\t// pop function argument\n\n\t// Now the C page fault handler has returned and you must return\n\t// to the trap time state.\n\t// Push trap-time %eip onto the trap-time stack.\n\t//\n\t// Explanation:\n\t//   We must prepare the trap-time stack for our eventual return to\n\t//   re-execute the instruction that faulted.\n\t//   Unfortunately, we can't return directly from the exception stack:\n\t//   We can't call 'jmp', since that requires that we load the address\n\t//   into a register, and all registers must have their trap-time\n\t//   values after the return.\n\t//   We can't call 'ret' from the exception stack either, since if we\n\t//   did, %esp would have the wrong value.\n\t//   So instead, we push the trap-time %eip onto the *trap-time* stack!\n\t//   Below we'll switch to that stack and call 'ret', which will\n\t//   restore %eip to its pre-fault value.\n\t//\n\t//   In the case of a recursive fault on the exception stack,\n\t//   note that the word we're pushing now will fit in the\n\t//   blank word that the kernel reserved for us.\n\t//\n\t// Throughout the remaining code, think carefully about what\n\t// registers are available for intermediate calculations.  You\n\t// may find that you have to rearrange your code in non-obvious\n\t// ways as registers become unavailable as scratch space.\n\t//\n\t// LAB 4: Your code here.\n\n\t// now esp is the top of utf\n\t// 此时utf_eip在utf中的位置为0x28(而当前esp就在utf顶端)\n\tmovl 0x28(%esp), %eax\n\t// 原始tf_esp在utf中的位置为0x30\n\tsub $0x4, 0x30(%esp)\n\t// 将处理(-4)后的tf_esp值 -> ebx\n\tmovl 0x30(%esp), %ebx\n\t// 将tf_eip放到处理后的tf_esp顶部\n\tmovl %eax, (%ebx)\n\t// 删去无用的utf_err，utf_fault_va\n\tpop %eax\n\tpop %eax\n\t// Restore the trap-time registers.  After you do this, you\n\t// can no longer modify any general-purpose registers.\n\t// LAB 4: Your code here.\n\tpopal\n\n\t// Restore eflags from the stack.  After you do this, you can\n\t// no longer use arithmetic operations or anything else that\n\t// modifies eflags.\n\t// LAB 4: Your code here.\n\taddl $0x4, %esp\n\tpopfl\n\t// Switch back to the adjusted trap-time stack.\n\t// LAB 4: Your code here.\n\tpopl %esp\n\t// Return to re-execute the instruction that faulted.\n\t// LAB 4: Your code here.\n\tret\n\n```\n\n> 错误记录：将`movl %eax, (%ebx)`这一步取`tf_esp`顶部时写成了`movl %eax, %ebx`，这样就没改`tf_esp`!\n\n接下来我们还需要实现`lib/pgfault.c`中的`set_pgfault_handler()`，实现以后用户环境就可以使用这个函数来设置页错误处理函数了。\n\n```c\n// Set the page fault handler function.\n// If there isn't one yet, _pgfault_handler will be 0.\n// The first time we register a handler, we need to\n// allocate an exception stack (one page of memory with its top\n// at UXSTACKTOP), and tell the kernel to call the assembly-language\n// _pgfault_upcall routine when a page fault occurs.\n//\nvoid\nset_pgfault_handler(void (*handler)(struct UTrapframe *utf))\n{\n\tint r;\n\n\tif (_pgfault_handler == 0) {\n\t\t// First time through!\n\t\t// LAB 4: Your code here.\n\t\tr = sys_page_alloc(thisenv->env_id, (void *)(UXSTACKTOP - PGSIZE), PTE_U | PTE_W | PTE_P);\n\t\tif(r < 0){\n\t\t\tpanic(\"[set_pgfault_handler] failed in sys_page_alloc: %e\\n\", r);\n\t\t}\n\t\t_pgfault_handler = handler;\n\t\tr = sys_env_set_pgfault_upcall(thisenv->env_id, _pgfault_upcall);\n\t\tif(r < 0){\n\t\t\tpanic(\"[set_pgfault_handler] failed in sys_env_set_pgfault_handler: %e\\n\", r);\n\t\t}\n\t}\n\n\t// Save handler pointer for assembly to call.\n\t_pgfault_handler = handler;\n}\n```\n\n至此，我们应该能一路通关通过到`user/faultallocbad`。我个人在这里遇到了非常多的坑，总结一下：\n\n1. debug的时候打log太多了，冲掉了控制台中的正确输出，导致`faultregs`无法通过。\n2. `faultallocbad`通过不了，是由于lab3中`user_mem_check()`函数的问题，所以需要重写。\n\n这里我们还要明白`user/faultalloc`以及`user/faultallocbad`的区别：\n\n```c\n// test user-level fault handler -- alloc pages to fix faults\n// faultalloc.c\n#include <inc/lib.h>\n\nvoid\nhandler(struct UTrapframe *utf)\n{\n\tint r;\n\tvoid *addr = (void*)utf->utf_fault_va;\n\n\tcprintf(\"fault %x\\n\", addr);\n\tif ((r = sys_page_alloc(0, ROUNDDOWN(addr, PGSIZE),\n\t\t\t\tPTE_P|PTE_U|PTE_W)) < 0)\n\t\tpanic(\"allocating at %x in page fault handler: %e\", addr, r);\n\tsnprintf((char*) addr, 100, \"this string was faulted in at %x\", addr);\n}\n\nvoid\numain(int argc, char **argv)\n{\n\tset_pgfault_handler(handler);\n\tcprintf(\"%s\\n\", (char*)0xDeadBeef);\n\tcprintf(\"%s\\n\", (char*)0xCafeBffe);\n}\n\n\n// test user-level fault handler -- alloc pages to fix faults\n// doesn't work because we sys_cputs instead of cprintf (exercise: why?)\n// faultallocbad.c\n#include <inc/lib.h>\n\nvoid\nhandler(struct UTrapframe *utf)\n{\n\tint r;\n\tvoid *addr = (void*)utf->utf_fault_va;\n\n\tcprintf(\"fault %x\\n\", addr);\n\tif ((r = sys_page_alloc(0, ROUNDDOWN(addr, PGSIZE),\n\t\t\t\tPTE_P|PTE_U|PTE_W)) < 0)\n\t\tpanic(\"allocating at %x in page fault handler: %e\", addr, r);\n\tsnprintf((char*) addr, 100, \"this string was faulted in at %x\", addr);\n}\n\nvoid\numain(int argc, char **argv)\n{\n\tset_pgfault_handler(handler);\n\tsys_cputs((char*)0xDEADBEEF, 4);\n}\n\n```\n\n唯一的区别就是`faultallocbad`直接通过系统调用进行输出，`sys_cputs()`会首先调用`user_mem_assert()`：\n\n```c\n// Print a string to the system console.\n// The string is exactly 'len' characters long.\n// Destroys the environment on memory errors.\nstatic void\nsys_cputs(const char *s, size_t len)\n{\n\t// Check that the user has permission to read memory [s, s+len).\n\t// Destroy the environment if not.\n\n\t// LAB 3: Your code here.\n\tuser_mem_assert(curenv, (void *)s, len, PTE_U);\n\t// Print the string supplied by the user.\n\tcprintf(\"%.*s\", len, s);\n}\n\n//\n// Checks that environment 'env' is allowed to access the range\n// of memory [va, va+len) with permissions 'perm | PTE_U | PTE_P'.\n// If it can, then the function simply returns.\n// If it cannot, 'env' is destroyed and, if env is the current\n// environment, this function will not return.\n//\nvoid\nuser_mem_assert(struct Env *env, const void *va, size_t len, int perm)\n{\n\tif (user_mem_check(env, va, len, perm | PTE_U) < 0)\n\t{\n\t\tcprintf(\"[%08x] user_mem_check assertion failure for \"\n\t\t\t\"va %08x\\n\", env->env_id, user_mem_check_addr);\n\t\tenv_destroy(env);\t// may not return\n\t}\n}\n```\n\n这里我们由于用户访问了不该访问的区域`deadbeef`（这个区域尚未分配给用户，`env`的`pgdir`不具备访问权限）。\n\n\n\n### B.2 Implementing Copy-on-Write Fork\n\n经过上述痛苦的考量，我们实现了用户级别的page fault的处理和`fork()`所需的一切基础设施。\n\n现在同样在`lib/fork.c`中给出了`fork()`的框架。与`dumbfork()`类似，`fork()`首先也创建了一个新的环境，然后扫描父环境地址空间，在子环境中建立相同的地址映射。\n\n区别在于`dumbfork()`复制页；而`fork()`复制页映射，直到某个环境要尝试对页进行写操作时才复制页。\n\n`fork()`的控制流如下所示：\n\n* 父环境设置`pgfault()`作为C级别的页异常处理程序，然后使用`set_pgfault_handler()`进行注册。\n\n* 父环境调用`sys_exofork()`创建一个子环境。\n\n* 父环境对于每一个`UTOP`以下的有**可写权限**或者**写时复制权限**的页面调用`duppage()`，这个函数的作用是把一个页面以写时复制权限(`PTE_COW`)映射到子环境，然后再以写时复制权限映射到父进程（这个顺序很重要）。\n\n  * 以写时复制映射：先取消**写权限（如果有）**，然后再加上**写时复制权限**用以区分普通只读页面。\n\n  > **用户异常栈**不能通过这种方式映射。我们必须给子环境重新分配一个用户异常栈（分配一个新的页面。）\n  >\n  > `fork()`同样需要处理`PTE_P`权限的页面（非可写或写时复制的）\n\n* 父环境为子环境设置用户页错误处理入口。\n\n* 子环境已经准备好运行，父环境将其标记为可运行。\n\n每当环境尝试写入一个写时复制的页面时，就会引发page fault，然后触发用户页错误处理程序的控制流：\n\n* `pgfault()`检查错误号（error code）是否为`FEC_WR`（写操作），即是由于写操作触发了异常。然后检查触发异常的页面是否为写时复制的，如果不是则直接panic内核。\n* `pgfault()`分配一个新的页面并且将引发异常的页面的内容原样拷贝。将新的页面以**可读可写权限**映射到合适的位置并且取代原来的映射。\n\n\n\n用户级别的`lib/fork.c`代码需要查看环境的页表（查询某个页面是否为写时复制），这也是内核将环境的页表映射到`UVPT`位置的原因（因为用户环境不能访问内核，不具备访问`kern_pgdir`以及使用`pgdir_walk`的权限）。所以为了能够让用户环境访问到`PTE`和`PDE`，jos采取了这种[clever mapping trick](https://pdos.csail.mit.edu/6.828/2018/labs/lab4/uvpt.html)：\n\n解释一下，每个4GB虚拟地址空间对应一个页目录，一个页目录包含2^10（10bits）个页表，每个页表有 2^10(10bits)页，每页的大小是 2^12B(12bits)，最终形成4GB地址空间。\n\n解析一个线性地址，MMU会跟据其PDX，PTX和OFFSET三个部分依次去在页目录（通过目录项找到页表）和页表（通过表项找到页）中进行索引。\n\n`UVPT`是页目录中的一个特殊的entry，它指向的是**页目录自身**。若`UVPT`的索引值是`V`，如果我们用一个PDX和PTX都是V的线性地址去进行解析，就会发现由于在页目录中对第V个entry的索引仍然是页目录本身的地址，这个地址最终解析出的就是页目录的物理地址（你可以理解为页目录本身就是一个页表，这种方式下我们连续两次解析到页目录本身的地址）。同理，如果PDX为V而PTX不为V，则会解析出各个页表的地址。通过这种方式，用户可以在`UVPT`内存区中访问到页目录和各个页表。\n\n\n\n**exercise 12**\n\n完成`lib/fork.c`中的`fork`, `duppage`以及`pgfault`\n\n* `fork()`\n\n> 错误记录：在`cld_envid=0`的case情况下（也就是子环境配置）忘记`return 0`了。\n\n```c\n//\n// User-level fork with copy-on-write.\n// Set up our page fault handler appropriately.\n// Create a child.\n// Copy our address space and page fault handler setup to the child.\n// Then mark the child as runnable and return.\n//\n// Returns: child's envid to the parent, 0 to the child, < 0 on error.\n// It is also OK to panic on error.\n//\n// Hint:\n//   Use uvpd, uvpt, and duppage.\n//   Remember to fix \"thisenv\" in the child process.\n//   Neither user exception stack should ever be marked copy-on-write,\n//   so you must allocate a new page for the child's user exception stack.\n//\nenvid_t\nfork(void)\n{\n\tint err;\n\t// 1. set pagefault handler\n\tset_pgfault_handler(pgfault);\n\t// 2. fork\n\tenvid_t cld_envid = sys_exofork();\n\t// err\n\tif(cld_envid < 0){\n\t\treturn cld_envid;\n\t}\n\t// cld environment\n\tif(cld_envid == 0){\n\t\tthisenv = envs + ENVX(sys_getenvid());\n\t\treturn 0;\n\t}\n\t// 3. parent duppage based on page\n\tuintptr_t vaddr;\n\tfor(vaddr = 0; vaddr < USTACKTOP; vaddr += PGSIZE){\n\t\tif(vaddr == (UXSTACKTOP - PGSIZE)) continue;\n\t\tif ((uvpd[PDX(vaddr)] & PTE_P) &&\n\t\t\t(uvpt[PGNUM(vaddr)] & PTE_P) &&\n\t\t\t(uvpt[PGNUM(vaddr)] & PTE_U)){\n\t\t\tduppage(cld_envid, vaddr / PGSIZE);\n\t\t}\n\t}\n\t// 4. alloc exception stack for cld\n\terr = sys_page_alloc(cld_envid, (void*)(UXSTACKTOP - PGSIZE), PTE_P | PTE_W | PTE_U);\n\tif(err < 0) return err;\n\t// 4. alloc page upcall for cld\n\textern void _pgfault_upcall();\n\terr = sys_env_set_pgfault_upcall(cld_envid, _pgfault_upcall);\n\tif(err < 0) return err;\n\t//4. runnable\n\terr = sys_env_set_status(cld_envid, ENV_RUNNABLE);\n\tif(err < 0) return err;\n\treturn cld_envid;\n}\n```\n\n* `duppage()`\n\n```c\n//\n// Map our virtual page pn (address pn*PGSIZE) into the target envid\n// at the same virtual address.  If the page is writable or copy-on-write,\n// the new mapping must be created copy-on-write, and then our mapping must be\n// marked copy-on-write as well.  (Exercise: Why do we need to mark ours\n// copy-on-write again if it was already copy-on-write at the beginning of\n// this function?)\n//\n// Returns: 0 on success, < 0 on error.\n// It is also OK to panic on error.\n//\nstatic int\nduppage(envid_t envid, unsigned pn)\n{\n\tint r;\n\n\t// LAB 4: Your code here.\n\tint perm = PTE_U | PTE_P;\n\t// page W or COW\n\tif(uvpt[pn] & (PTE_W | PTE_COW)){\n\t\tint new_perm = perm | PTE_COW;\n\t\t// parent -> child\n\t\tr = sys_page_map(0, (void*)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), new_perm);\n\t\tif(r < 0) panic(\"[duppage] failed to map parent(W|COW) -> child: %e\\n\", r);\n\t\t// remap -> parent\n\t\tr = sys_page_map(0, (void*)(pn * PGSIZE), 0, (void*)(pn * PGSIZE), new_perm);\n\t\tif(r < 0) panic(\"[duppage] failed to remap -> parent(COW): %e\\n\", r);\n\t}\n\t// other pages\n\telse{\n\t\tr = sys_page_map(0, (void*)(pn * PGSIZE), envid, (void*)(pn * PGSIZE), perm);\n\t\tif(r < 0) panic(\"[duppage] failed to map parent(P|U)-> child: %e\\n\", r);\n\t}\n\treturn 0;\n}\n```\n\n* `pgfault()`\n\n```c\n//\n// Custom page fault handler - if faulting page is copy-on-write,\n// map in our own private writable copy.\n//\nstatic void\npgfault(struct UTrapframe *utf)\n{\n\tvoid *addr = (void *) utf->utf_fault_va;\n\tuint32_t err = utf->utf_err;\n\tint r;\n\n\t// Check that the faulting access was (1) a write, and (2) to a\n\t// copy-on-write page.  If not, panic.\n\t// Hint:\n\t//   Use the read-only page table mappings at uvpt\n\t//   (see <inc/memlayout.h>).\n\n\t// LAB 4: Your code here.\n\tif (!(err & FEC_PR) || !(uvpt[PGNUM(addr)] & PTE_COW)){\n\t\tpanic(\"[pgfault] fault on no COW page\\n\");\n\t}\n\t// Allocate a new page, map it at a temporary location (PFTEMP),\n\t// copy the data from the old page to the new page, then move the new\n\t// page to the old page's address.\n\t// Hint:\n\t//   You should make three system calls.\n\n\t// LAB 4: Your code here.\n\tr = sys_page_alloc(0, (void*)PFTEMP, PTE_P | PTE_U | PTE_W);\n\tif(r < 0) panic(\"[pgfault] failed to alloc page: %e\\n\",r);\n\tuintptr_t fault_pg = ROUNDDOWN((uintptr_t)addr, PGSIZE);\n\t// copy to temp\n\tmemcpy((void*)PFTEMP, (void*)fault_pg, PGSIZE);\n\t// map new page\n\tr = sys_page_map(0, PFTEMP, 0, (void*)fault_pg, PTE_P | PTE_U | PTE_W);\n\tif(r < 0) panic(\"[pgfault] failed to map new alloced page: %e\\n\", r);\n}\n```\n\n至此，part B应该全部通过。\n\n\n\n## Part C: Preemptive Multitasking and Inter-Process communication(IPC)\n\n现在我们来到了最后一个部分，~~希望能够尽早结束痛苦~~。在这个部分中，我们需要修改内核，实现抢占式非协作环境(preemptive uncooperative environments)，以及环境之间的显式信息传递。\n\n\n\n### C.1 Clock Interrupts and Preemption\n\n运行`user/spin`这个测试程序。该程序会`fork()`一个子环境，然后生成的子环境将会在占用CPU以后陷入无限循环。这时无论是父亲环境还是内核都无法再次获得CPU使用权。\n\n这显然不是一个很好的系统保护机制，这种情况下用户环境bug或者恶意软件都会导致系统宕机（halt）。为了能够使内核抢占用户环境并且强制接管CPU使用权，我们需要拓展jos的内核以支持时钟硬件的外部硬件中断（external hardware interrupts）。\n\n\n\n#### >> Interrupt discipline\n\n外部中断（比如设备中断）被称为IRQs。一共有16种可能的IRQs，编号为0-15。IRQ的编号到IDT表项的映射并不是固定的。`picirq.c`种的`pic_init()`将会把0-15号IRQ映射到IDT表项中对应的`IRQ_OFFSET-IRQ_OFFSET+15`。\n\n`IRQ_OFFSET`被定义为32（在`inc/trap.h`中），那么IDT表项的32-47就对应了15种IRQ，时钟中断是IRQ 0。这样设置不会让处理器异常和IRQ重叠。\n\n在jos中，外部设备中断在内核中是永远被禁止的，而用户模式是允许的。外部中断是被`%eflags`寄存器的`FL_IF`位所控制。但该位被设置时，外部中断则被允许。我们在这个实验中将会在进入以及退出用户模式的时候通过保存和恢复`%eflags`寄存器来处理`FL_IF`位。\n\n我们需要确保用户环境中的`FL_IF`是被设置的状态，这样在中断信号到达时，将会传递到处理器中然后被中断处理程序接管。否则中断会被屏蔽（masked），直到中断再次被允许（设置中断位）。\n\n回顾一下，我们在lab1 bootloader加载的过程中就已经设置了屏蔽中断，到目前为止我们还没有开启。\n\n**exercise 13**\n\n修改`kern/trapentry.S`以及`kern/trap.c`，重新初始化IDT以支持IRQs 0-15的处理。然后修改`kern/env.c`中的`env_alloc()`来确保用户环境在运行时始终开启中断。\n\n取消`sched_halt()`中对`sti`指令的注释，以使空闲的CPU取消屏蔽中断。\n\n处理器永远不会在处理硬件中断时将error code压栈。对于这些知识可以重新阅读:[Intel 80386 Reference Programmer's Manual Table of Contents](https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm)的9.2节。\n\n* `trapentry.S`\n\n```assembly\nTRAPHANDLER_NOEC(irq_0_handler,  IRQ_OFFSET + 0);\nTRAPHANDLER_NOEC(irq_1_handler,  IRQ_OFFSET + 1);\nTRAPHANDLER_NOEC(irq_2_handler,  IRQ_OFFSET + 2);\nTRAPHANDLER_NOEC(irq_3_handler,  IRQ_OFFSET + 3);\nTRAPHANDLER_NOEC(irq_4_handler,  IRQ_OFFSET + 4);\nTRAPHANDLER_NOEC(irq_5_handler,  IRQ_OFFSET + 5);\nTRAPHANDLER_NOEC(irq_6_handler,  IRQ_OFFSET + 6);\nTRAPHANDLER_NOEC(irq_7_handler,  IRQ_OFFSET + 7);\nTRAPHANDLER_NOEC(irq_8_handler,  IRQ_OFFSET + 8);\nTRAPHANDLER_NOEC(irq_9_handler,  IRQ_OFFSET + 9);\nTRAPHANDLER_NOEC(irq_10_handler, IRQ_OFFSET + 10);\nTRAPHANDLER_NOEC(irq_11_handler, IRQ_OFFSET + 11);\nTRAPHANDLER_NOEC(irq_12_handler, IRQ_OFFSET + 12);\nTRAPHANDLER_NOEC(irq_13_handler, IRQ_OFFSET + 13);\nTRAPHANDLER_NOEC(irq_14_handler, IRQ_OFFSET + 14);\nTRAPHANDLER_NOEC(irq_15_handler, IRQ_OFFSET + 15);\n```\n\n* `trap.c`\n\n```c\nvoid irq_0_handler();\nvoid irq_1_handler();\nvoid irq_2_handler();\nvoid irq_3_handler();\nvoid irq_4_handler();\nvoid irq_5_handler();\nvoid irq_6_handler();\nvoid irq_7_handler();\nvoid irq_8_handler();\nvoid irq_9_handler();\nvoid irq_10_handler();\nvoid irq_11_handler();\nvoid irq_12_handler();\nvoid irq_13_handler();\nvoid irq_14_handler();\nvoid irq_15_handler();\n\nvoid\ntrap_init(void)\n{\n\textern struct Segdesc gdt[];\n\n\t// LAB 3: Your code here.\n\tSETGATE(idt[T_DIVIDE], 0, GD_KT, divide_handler, 0);\n\tSETGATE(idt[T_DEBUG], 0, GD_KT, debug_handler, 0);\n\tSETGATE(idt[T_NMI], 0, GD_KT, nmi_handler, 0);\n\tSETGATE(idt[T_BRKPT], 0, GD_KT, brkpt_handler, 3);\n\tSETGATE(idt[T_OFLOW], 0, GD_KT, oflow_handler, 0);\n\tSETGATE(idt[T_BOUND], 0, GD_KT, bound_handler, 0);\n\tSETGATE(idt[T_ILLOP], 0, GD_KT, illop_handler, 0);\n\tSETGATE(idt[T_DEVICE], 0, GD_KT, device_handler, 0);\n\tSETGATE(idt[T_DBLFLT], 0, GD_KT, dblflt_handler, 0);\n\tSETGATE(idt[T_TSS], 0, GD_KT, tss_handler, 0);\n\tSETGATE(idt[T_SEGNP], 0, GD_KT, segnp_handler, 0);\n\tSETGATE(idt[T_STACK], 0, GD_KT, stack_handler, 0);\n\tSETGATE(idt[13], 0, GD_KT, gpflt_handler, 0);\n\tSETGATE(idt[14], 0, GD_KT, pgflt_handler, 0);\n\tSETGATE(idt[16], 0, GD_KT, fperr_handler, 0);\n\tSETGATE(idt[17], 0, GD_KT, align_handler, 0);\n\tSETGATE(idt[18], 0, GD_KT, mchk_handler, 0);\n\tSETGATE(idt[19], 0, GD_KT, simderr_handler, 0);\n\tSETGATE(idt[48], 0, GD_KT, syscall_handler, 3);\n\n\t//\n\tSETGATE(idt[IRQ_OFFSET + 0], 0, GD_KT, irq_0_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 1], 0, GD_KT, irq_1_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 2], 0, GD_KT, irq_2_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 3], 0, GD_KT, irq_3_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 4], 0, GD_KT, irq_4_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 5], 0, GD_KT, irq_5_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 6], 0, GD_KT, irq_6_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 7], 0, GD_KT, irq_7_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 8], 0, GD_KT, irq_8_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 9], 0, GD_KT, irq_9_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 10], 0, GD_KT, irq_10_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 11], 0, GD_KT, irq_11_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 12], 0, GD_KT, irq_12_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 13], 0, GD_KT, irq_13_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 14], 0, GD_KT, irq_14_handler, 0);\n\tSETGATE(idt[IRQ_OFFSET + 15], 0, GD_KT, irq_15_handler, 0);\n\t// Per-CPU setup\n```\n\n* `env_alloc()`\n\n```c\n\t// Enable interrupts while in user mode.\n\t// LAB 4: Your code here.\n\te->env_tf.tf_eflags |= FL_IF;\n```\n\n* `sched_halt()`\n\n```assembly\n// Reset stack pointer, enable interrupts and then halt.\n\tasm volatile (\n\t\t\"movl $0, %%ebp\\n\"\n\t\t\"movl %0, %%esp\\n\"\n\t\t\"pushl $0\\n\"\n\t\t\"pushl $0\\n\"\n\t\t// Uncomment the following line after completing exercise 13\n\t\t\"sti\\n\"\n\t\t\"1:\\n\"\n\t\t\"hlt\\n\"\n\t\t\"jmp 1b\\n\"\n\t: : \"a\" (thiscpu->cpu_ts.ts_esp0));\n```\n\n完成之后，我们可以尝试`make run-spin`，我们会发现内核会打印一个硬件中断的frame。但是我们还没有实现中断的处理，因此我们这里仅仅会摧毁这个环境。\n\n\n\n#### >> Handling Clock Interrupts\n\n在`user/spin`程序中，当子环境开始运行的时候就会陷入死循环并一直占用CPU，使得内核永远得不到CPU的控制权。我们需要对硬件重新编程，使其周期性产生时钟中断，来强制将控制流交还给内核，然后把CPU资源调度给下一个用户环境。\n\n实验已经在`init.c`中的`i386_init()`中实现了对`lapic_init()`以及`pic_init()`的调用，它们负责设置产生中断的时钟信号。我们只需要写代码实现中断处理程序。\n\n**exercise 14**\n\n修改`trap_dispatch()`函数，使其在接收时钟中断信号的时候调用`sched_yield()`来调度另一个用户环境。\n\n```c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n\t// Handle processor exceptions.\n\t// LAB 3: Your code here.\n\tif (tf->tf_trapno == T_PGFLT)\n\t{\n\t\tpage_fault_handler(tf);\n\t}\n\tif (tf->tf_trapno == T_BRKPT)\n\t{\n\t\tmonitor(tf);\n\t}\n\tif (tf->tf_trapno == T_SYSCALL)\n\t{\n\t\tint32_t retval = syscall(tf->tf_regs.reg_eax,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_edx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_ecx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_ebx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_edi,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_esi);\n\t\tif (retval < 0)\n\t\t{\n\t\t\tpanic(\"[trap_dispatch] syscall : %e\\n\", retval);\n\t\t}\n\t\ttf->tf_regs.reg_eax = retval;\n\t\treturn;\n\t}\n\t// Handle spurious interrupts\n\t// The hardware sometimes raises these because of noise on the\n\t// IRQ line or other reasons. We don't care.\n\tif (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {\n\t\tcprintf(\"Spurious interrupt on irq 7\\n\");\n\t\tprint_trapframe(tf);\n\t\treturn;\n\t}\n\n\t// Handle clock interrupts. Don't forget to acknowledge the\n\t// interrupt using lapic_eoi() before calling the scheduler!\n\t// LAB 4: Your code here.\n\t// Unexpected trap: The user process or the kernel has a bug.\n\tif(tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER){\n\t\tlapic_eoi();\n\t\tsched_yield();\n\t}\n\tprint_trapframe(tf);\n\tif (tf->tf_cs == GD_KT)\n\t\tpanic(\"unhandled trap in kernel\");\n\telse {\n\t\tenv_destroy(curenv);\n\t\treturn;\n\t}\n}\n```\n\n说实话有手就行。完成之后我们`make grade`可以拿到65分。\n\n\n\n### C.2 Inter-Process communication(IPC)\n\n*(Technically in JOS this is \"inter-environment communication\" or \"IEC\", but everyone else calls it IPC, so we'll use the standard term.)*\n\n我们一直在关注操作系统的隔离与独立，它使用虚拟化提供了一种错觉，即每个程序都独占操作系统。操作系统的另一个重要功能是允许程序在需要的时候互相通信。让程序与其他程序交互是非常强大的。Unix管道模型就是一个典型的例子。\n\n我们将实现一种简单的进程通信模型。\n\n\n\n#### >> IPC in JOS\n\n我们将实现jos中的一些额外的系统功能调用，这些系统功能调用共同提供一个简单的进程通信机制。我们要实现的是`sys_ipc_recv()`和`sys_ipc_try_send()`。之后我们还会实现两个库来封装`ipc_recv()`和`ipc_send()`。\n\n用户环境可以通过jos系统的IPC机制向其他用户环境发送“消息”（message）。这个消息分为两部分：一个32-bit的值，以及一个可选的单页映射。允许用户环境传递页映射是一种比发送32-bit更有效的数据传递方式（很容易实现共享内存）。\n\n\n\n#### >> Sending and Receiving Messages\n\n**接受消息：**环境通过系统调用`sys_ipc_recv()`来接收消息。这个系统调用将会取消调度当前环境（de-schedule）直到其所需的消息被接受。当一个环境等待接收消息时，其它用户环境都可以向其发送消息-不限于特定的环境（比如父子环境之间）。换句话说，我们在Part A中实现的权限检查将不适用于IPC，因为IPC的系统调用经过精心设计确保安全：环境不会通过简单地向另一个环境发送消息而导致另一个环境发生故障（除非另一个环境有bug）。\n\n**发送消息：**环境通过系统调用`sys_ipc_try_send()`尝试发送一个值（value）（需要附带接受方的环境ID），如果指定的目标环境确实处于接受该值消息的状态（目标环境也调用了`sys_ipc_recv()`并且处于等待该值的阶段），这时发送方会成功传递该值给接受方然后系统调用返回0。否则返回`-E_IPC_NOT_RECV`来表示目标环境并不期望接受该值。\n\n用户空间的库函数`ipc_recv()`将会负责调用`sys_ipc_recv()`，然后在当前环境的`struct Env`中查找接收值的信息。相似地，库函数`ipc_send()`负责重复调用`sys_ipc_try_send()`直到发送成功。\n\n\n\n#### >> Transfering Pages\n\n**接受方：**如果`sys_ipc_recv()`的参数是一个`UTOP`以下的合法参数`dstva`，说明接收方期望接受一个页面映射。如果发送方发送了一个页面，那该页面将会被映射到接受方地址空间的`dstva`处。如果接受方此时在`dstva`已经有一个映射关系，则会取消原来的映射关系。\n\n**发送方：**如果`sys_ipc_try_send()`的参数是一个`UTOP`以下的合法参数`srcva`，说明发送方期望发送一个当前映射在`srcva`的页面，附带权限`perm`。当IPC成功进行之后，发送方会保持`srcva`处的映射关系，但是接受方同样也会在其地址`dstva`处映射这个页面。那此时这个页面就成了发送方到接受方的共享页面。\n\n注意，如果发送方和接收方之间的任意一方没有声明需要传输的是一个页面，那就不会有页面进行传输。\n\n在任何IPC结束之后，内核将会设置接受方的`struct Env`的`env_ipc_perm`成员。如果没有接受页面则设置为0，如果接受页面则设置为接收到的页面权限`perm`。\n\n\n\n#### >> Implementing IPC\n\n**exercise 15**\n\n实现`kern/syscall.c`中的`sys_ipc_recv()`和`sys_ipc_try_send()`。\n\n> 提示：务必仔细阅读注释\n\n当我们需要在这些有关IPC的例程中调用`envid2env()`时，需要将参数`checkperm`设置为0，这意味着任何环境都被允许与其他环境进行IPC。\n\n然后实现`lib/ipc.c`中的`ipc_recv()`和`ipc_send()`的封装。\n\n* `sys_ipc_recv()`\n\n```c\n// Block until a value is ready.  Record that you want to receive\n// using the env_ipc_recving and env_ipc_dstva fields of struct Env,\n// mark yourself not runnable, and then give up the CPU.\n//\n// If 'dstva' is < UTOP, then you are willing to receive a page of data.\n// 'dstva' is the virtual address at which the sent page should be mapped.\n//\n// This function only returns on error, but the system call will eventually\n// return 0 on success.\n// Return < 0 on error.  Errors are:\n//\t-E_INVAL if dstva < UTOP but dstva is not page-aligned.\nstatic int\nsys_ipc_recv(void *dstva)\n{\n\t// LAB 4: Your code here.\n\tif((uintptr_t)dstva < UTOP){\n\t\t// not page aligned\n\t\tif(PGOFF((uintptr_t)dstva)){\n\t\t\treturn -E_INVAL;\n\t\t}\n\t\tcurenv -> env_ipc_dstva = dstva;\n\t}\n\telse{\n\t\tcurenv -> env_ipc_dstva = (void*)~0;\n\t}\n\t// receving state\n\tcurenv -> env_status = ENV_NOT_RUNNABLE;\n\tcurenv -> env_ipc_recving = 1;\n\tsched_yield();\n\n\treturn 0;\n}\n```\n\n* `sys_ipc_try_send()`\n\n```c\n// Try to send 'value' to the target env 'envid'.\n// If srcva < UTOP, then also send page currently mapped at 'srcva',\n// so that receiver gets a duplicate mapping of the same page.\n//\n// The send fails with a return value of -E_IPC_NOT_RECV if the\n// target is not blocked, waiting for an IPC.\n//\n// The send also can fail for the other reasons listed below.\n//\n// Otherwise, the send succeeds, and the target's ipc fields are\n// updated as follows:\n//    env_ipc_recving is set to 0 to block future sends;\n//    env_ipc_from is set to the sending envid;\n//    env_ipc_value is set to the 'value' parameter;\n//    env_ipc_perm is set to 'perm' if a page was transferred, 0 otherwise.\n// The target environment is marked runnable again, returning 0\n// from the paused sys_ipc_recv system call.  (Hint: does the\n// sys_ipc_recv function ever actually return?)\n//\n// If the sender wants to send a page but the receiver isn't asking for one,\n// then no page mapping is transferred, but no error occurs.\n// The ipc only happens when no errors occur.\n//\n// Returns 0 on success, < 0 on error.\n// Errors are:\n//\t-E_BAD_ENV if environment envid doesn't currently exist.\n//\t\t(No need to check permissions.)\n//\t-E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,\n//\t\tor another environment managed to send first.\n//\t-E_INVAL if srcva < UTOP but srcva is not page-aligned.\n//\t-E_INVAL if srcva < UTOP and perm is inappropriate\n//\t\t(see sys_page_alloc).\n//\t-E_INVAL if srcva < UTOP but srcva is not mapped in the caller's\n//\t\taddress space.\n//\t-E_INVAL if (perm & PTE_W), but srcva is read-only in the\n//\t\tcurrent environment's address space.\n//\t-E_NO_MEM if there's not enough memory to map srcva in envid's\n//\t\taddress space.\nstatic int\nsys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)\n{\n\t// LAB 4: Your code here.\n\tstruct Env * tar_env;\n\t// check target env\n\tif(envid2env(envid, &tar_env, 0) < 0){\n\t\treturn -E_BAD_ENV;\n\t}\n\t// check recver status\n\tif(!tar_env->env_ipc_recving){\n\t\treturn -E_IPC_NOT_RECV;\n\t}\n\n\t// page send\n\tif((uintptr_t)srcva < UTOP){\n\t\t//page valid check\n\t\tif(PGOFF(srcva)){\n\t\t\treturn -E_INVAL;\n\t\t}\n\t\t// perm valid check\n\t\tif(perm & (~PTE_SYSCALL) || !(perm & PTE_U) || !(perm & PTE_P)){\n\t\t\treturn -E_INVAL;\n\t\t}\n\t\t// page check\n\t\tpte_t * pte;\n\t\tstruct PageInfo * pginfo;\n\t\tpginfo = page_lookup(curenv->env_pgdir, srcva, &pte);\n\t\tif(!pginfo){\n\t\t\treturn -E_INVAL;\n\t\t}\n\t\t// sender & receiver PTE_W\n\t\tif((perm & PTE_W) && !((*pte) & PTE_W)){\n\t\t\treturn -E_INVAL;\n\t\t}\n\t\t// dst check\n\t\tif((uintptr_t)(tar_env->env_ipc_dstva) < UTOP){\n\t\t\t// insert page map\n\t\t\tif(page_insert(tar_env->env_pgdir, pginfo, tar_env->env_ipc_dstva, perm) < 0){\n\t\t\t\treturn -E_NO_MEM;\n\t\t\t}\n\t\t\t// insert success\n\t\t\ttar_env->env_ipc_perm = perm;\n\t\t}\n\t}\n\ttar_env->env_ipc_perm = 0;\n\ttar_env->env_ipc_value = value;\n\t// tar status\n\ttar_env->env_ipc_from = curenv->env_id;\n\ttar_env->env_ipc_recving = 0;\n\ttar_env->env_status = ENV_RUNNABLE;\n\ttar_env->env_tf.tf_regs.reg_eax = 0;\n\treturn 0;\n}\n```\n\n* `ipc_recv()`\n\n```c\n// Receive a value via IPC and return it.\n// If 'pg' is nonnull, then any page sent by the sender will be mapped at\n//\tthat address.\n// If 'from_env_store' is nonnull, then store the IPC sender's envid in\n//\t*from_env_store.\n// If 'perm_store' is nonnull, then store the IPC sender's page permission\n//\tin *perm_store (this is nonzero iff a page was successfully\n//\ttransferred to 'pg').\n// If the system call fails, then store 0 in *fromenv and *perm (if\n//\tthey're nonnull) and return the error.\n// Otherwise, return the value sent by the sender\n//\n// Hint:\n//   Use 'thisenv' to discover the value and who sent it.\n//   If 'pg' is null, pass sys_ipc_recv a value that it will understand\n//   as meaning \"no page\".  (Zero is not the right value, since that's\n//   a perfectly valid place to map a page.)\nint32_t\nipc_recv(envid_t *from_env_store, void *pg, int *perm_store)\n{\n\t// LAB 4: Your code here.\n\tint errno;\n\tif(!pg){\n\t\tpg = (void*)UTOP;\n\t}\n\tif((errno = sys_ipc_recv(pg)) < 0){\n\t\tif(from_env_store){\n\t\t\t*from_env_store = 0;\n\t\t}\n\t\tif(perm_store){\n\t\t\t*perm_store = 0;\n\t\t}\n\t\treturn errno;\n\t}\n\tif(from_env_store){\n\t\t*from_env_store = thisenv->env_ipc_from;\n\t}\n\tif(perm_store){\n\t\t*perm_store = thisenv->env_ipc_perm;\n\t}\n\treturn thisenv->env_ipc_value;\n}\n```\n\n* `ipc_send()`\n\n```c\n// Send 'val' (and 'pg' with 'perm', if 'pg' is nonnull) to 'toenv'.\n// This function keeps trying until it succeeds.\n// It should panic() on any error other than -E_IPC_NOT_RECV.\n//\n// Hint:\n//   Use sys_yield() to be CPU-friendly.\n//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand\n//   as meaning \"no page\".  (Zero is not the right value.)\nvoid\nipc_send(envid_t to_env, uint32_t val, void *pg, int perm)\n{\n\t// LAB 4: Your code here.\n\tint errno;\n\tif(!pg){\n\t\tpg = (void*)UTOP;\n\t}\n\twhile(1){\n\t\terrno = sys_ipc_try_send(to_env, val, pg, perm);\n\t\t// send success\n\t\tif(!errno) return;\n\t\t// panic\n\t\tif(errno != -E_IPC_NOT_RECV){\n\t\t\tpanic(\"[ipc_send] failed to send message: %e\\n\", errno);\n\t\t}\n\t\tsys_yield();\n\t}\n}\n```\n\n完成后要在`kern/syscall.c`中加上两个新的系统调用哦。\n\n错误记录：\n\n需要注释掉此前`trap_dispatch()`对于`syscall`部分异常的panic。\n\n```c\nif (tf->tf_trapno == T_SYSCALL)\n\t{\n\t\tint32_t retval = syscall(tf->tf_regs.reg_eax,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_edx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_ecx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_ebx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_edi,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_esi);\n\t\t// if (retval < 0)\n\t\t// {\n\t\t// \tpanic(\"[trap_dispatch] syscall : %e\\n\", retval);\n\t\t// }\n\t\ttf->tf_regs.reg_eax = retval;\n\t\treturn;\n\t}\n```\n\n完结撒花，🎉","tags":["operating system","lab"],"categories":["operating system"]},{"title":"Hunting Malware in Process Memory","url":"/2020/03/10/memfor-8/","content":"\n## 8 Hunting Malware in Process Memory\n\nNow we will see some specific examples of how can detect malware that hides in process by unlinking dynamic linked ilbraries(DLL) or using one of four different methods of injecting code.\n\n\n\n### > Process Environment Block(PEB)\n\nEvery` _EPROCESS` structure contains a member called the Process Environment Block (PEB). \n\nThe PEB contains the full path to the process’ executable, the full command line that starts the process, the current working directory, pointers to the process’ heaps, standard handles, and three doubly linked lists that contain the full path to DLLs loaded by the process.\n\n\n\n#### >> Data Structures\n\nThe main PEB structure is appropriately named `_PEB`. \n\n> `_PEB` structure exists in process memory, so **a process can easily modify its own values** to falsely report information or thwart analysis.\n\n![image-20200310174936970](https://tva1.sinaimg.cn/large/00831rSTly1gcoz8u5pulj30ny0bp0ut.jpg)\n\nKey Points:\n\n* `BeingDebugged`: Tells you whether the process is currently being debugged. In the past, we’ve seen malware that attaches to itself (by calling `DebugActiveProcess`).\n\n  > Because only one debugger at a time can attach to a target process, it served as anti-debugging protection. Thus, **there is a red flag if this value is set to true, but there are no legitimate active debuggers running**.\n\n* `ImageBaseAddress` : **The address in process memory where the main executable (.exe) is loaded**. Before Volatility’s `procdump` plugin (described later in the chapter) carves an executable from memory, it reads this value so it knows where to look. \n\n* `Ldr`: Points to a `_PEB_LDR_DATA` structure, which **contains details about the DLLs loaded in a process**.\n\n* `ProcessParameters`: Points to a `_RTL_PROCESS_PARAMETERS` structure (described soon).\n\n* `ProcessHeap`: Primary heap for the process, which is created automatically when the process is initialized.\n\n* `NumberOfHeaps`: Number of heaps in a process. By default, a process has only one heap, but it can create others by calling `HeapCreate`.\n\n* `ProcessHeaps` : An array of pointers to process heaps. The first entry in this list always points to the same location as ProcessHeap because it is the primary.\n\n\n\nThen we look into the `_RTL_USER_PROCESS_PARAMETERS` structure:\n\n![image-20200310180558394](https://tva1.sinaimg.cn/large/00831rSTly1gcozpuoyqpj30nr04mgm8.jpg)\n\nand below:\n\n![image-20200310180640220](https://tva1.sinaimg.cn/large/00831rSTly1gcozqkx6gbj30nq04p3z2.jpg)\n\nKey Points:\n\n* `StandardInput`: The process’ standard input handle. \n\n* `StandardOutput`: The process’ standard output handle.\n\n* `StandardError`: The process’ standard error handle.\n\n* ` CurrentDirectory`: The current working directory for the application.\n\n* `ImagePathName`: The Unicode full path on disk to the process executable (.exe).\n\n  > You often need to consult this value because the `_EPROCESS.ImageFileName` (printed by the pslist plugin) contains only the first 16 characters and it does not include Unicode.\n\n* `CommandLine`: The full command line, including all arguments, used to invoke the process.\n\n* `Environment`: A pointer to the process’ environment variables.\n\n\n\nThe `_PEB_LDR_DATA` structure:\n\n![image-20200310181043016](https://tva1.sinaimg.cn/large/00831rSTly1gcozusn6ofj30n9053dgg.jpg)\n\nKey Points:\n\n* `InLoadOrderModuleList`: A linked list that organizes modules **in the order in which they are loaded into a process**. \n\n  > Because the **process executable is always first to load in the process address space**, its entry is first in this list. \n\n* `InMemoryOrderModuleList`: A linked list that organizes modules in the order in which they **appear in the process’ virtual memory layout**. \n\n  > For example, the last DLL to load may end up at a lower base address than the first (due to address space layout randomization [ASLR] and other factors). \n\n* `InInitializationOrderModuleList`: A linked list that organizes modules **in the order in which their `DllMain` function was executed**.\n\n  > This is different from the load order list because a module’s DllMain isn’t always called immediately when it loads. Sometimes it’s never called, for example when you load a DLL as a data file or image resource (see the `dwFlags` parameter to `LoadLibraryEx`).\n\n\n\nThe `_LDR_DATA_TABLE_ENTRY` structure:\n\n![image-20200310181813866](https://tva1.sinaimg.cn/large/00831rSTly1gcp02m453hj30np0980uc.jpg)\n\nKey Points:\n\n* `DllBase` : This is the base address of the module in process memory.\n\n* `EntryPoint`: The first instruction executed by the module. In most cases, it is taken from the PE file’s `AddressOfEntryPoint` value.\n\n* `SizeOfImage`: The size of the module, in bytes.\n\n* `FullDllName`: The full path to the module’s file on disk (for example, `C:\\Windows\\ System32\\kernel32.dll`).\n\n* `BaseDllName` : The base portion of the module’s filename (for example, `kernel32.dll`).\n\n* `LoadCount`: **The number of times** `LoadLibrary` was called for the module. **It is used as a reference count to know when it is safe to unload a DLL from process memory**. You’ll see this value later in the chapter to determine how a DLL was loaded (via the import address table [IAT] or an explicit call to LoadLibrary).\n\n\n\n#### >> Process Heap\n\nWhen you dump process memory via `memdump` or `vaddump`, you inevitably get the heap contents(at least the pages that are not swapped). However, you won't necessarily know which offsets in your dump file or signature results correspond to heap regions.\n\nBut in some cases you might want to analyze only heap memory.\n\n\n\n**Scenario:**\n\nSuppose we are investigating some suspects' notepad that is recorded something for crime as below:\n\n![image-20200310195417879](https://tva1.sinaimg.cn/large/00831rSTly1gcp2ukdyslj30og0ih11a.jpg)\n\nWe may obtain the memory dump from the suspects'system. Though we could use `vadinfo` or `vadtree` on the notepad process, we'll see 50+ VAD tress and its hard to analyze. The goal is to obtain the texts by pressing keyboard and we only need to analyze the heap.\n\nWe can use `heaps` plugin to layout the heap:\n\n```\npython vol.py -f Win2K3SP1x86.vmem --profile=Win2003SP1x86 heaps -p 3988\n```\n\n![image-20200310195057283](https://tva1.sinaimg.cn/large/00831rSTly1gcp2r38zxjj30o40jun0s.jpg)\n\n> As shown, two chunks stood out because the “`extra`” flag is displayed. In other words, the `HEAP_ENTRY_EXTRA_PRESENT` flag was set in the `_HEAP_ENTRY.Flags` member for these two chunks.\n\nRegardless of the actual meaning of the `extra` flag, we got two chunks at `0xa8028` and `0xac7b0`.\n\nWe could access the memory by `volshell` below.\n\n```\npython vol.py -f Win2K3SP1x86.vmem --profile=Win2003SP1x86 volshell -p 3988\n```\n\n![image-20200310195925790](https://tva1.sinaimg.cn/large/00831rSTly1gcp2zwsgpoj30nr081q4j.jpg)\n\n#### >> Environment Variables\n\nA process’ environment variables are pointed to by `_PEB.ProcessParameters.Environment`. The variables are organized as multiple NULL-terminated strings, similar to a `REG_MULTI_SZ` value in the registry.\n\n> If an attacker manipulates these variables, they can cause the target application to unexpectedly execute a malicious process. Additionally, some malware marks its presence by creating environment variables rather than mutexes.\n\nHere are some scopes of environment variables:\n\n![image-20200310200449010](https://tva1.sinaimg.cn/large/00831rSTly1gcp35ifgnuj30oj063q3u.jpg)\n\nThe System and User variables are both persistent in the registry. Thus, you can enumerate them by parsing registry hive files that were acquired from disk.\n\n> When a process is created, it usually inherits the environment block from its parent. The parent process can override this default behavior by specifying the `lpEnvironment` parameter when it calls `CreateProcess`.\n\nYou can find these types of data in environment variables:\n\n* Paths to executable programs (PATH) \n* Extensions assigned to executable programs (PATHEXT) \n* Paths to temporary directories \n* Paths to a user’s Documents, Internet History, and Application Data folders \n* User names, computer names, and domain names \n* The location of cmd.exe (ComSpec)\n\n\n\n#### >> Attacks on Environment variables\n\nThe two most common types of attacks on environment variables include changing the `PATH` and `PATHEXT` variables.\n\n```shell\nPATH=C:\\windows;C:\\windows\\system32 PATH=C:\\Users\\HR101\\.tmp;C:\\windows;C:\\windows\\system32\n```\n\nAn attacker could plant a file named calc.zzz in one of the searched directories, and it would be executed first:\n\n```shell\nPATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE\nPATHEXT=.ZZZ;.COM;.EXE;.BAT;.CMD;.VBS;.VBE\n```\n\n\n\n#### >> Coreflood Presence Marking\n\nMany malware samples mark their presence on a system by creating globally accessible mutexes. This helps prevent accidental re-infection. Mutexes also provide a strong forensic indicator. Coreflood used environment variables for a very similar purpose—to mark its presence within a process.\n\n**Example:**\n\nHow many of the following processes are infected with Coreflood’s DLL?\n\n```\npython vol.py -f coreflood.img --profile=WinXPSP3x86 envars\n```\n\n![image-20200310214200342](https://tva1.sinaimg.cn/large/00831rSTly1gcp5yo7ra2j30o80mojuz.jpg)\n\nAnswer : 2\n\nAt first glance, it appears as if all four processes are infected, because they all contain suspicious variable names. \n\nHowever, we previously mentioned that **child processes typically inherit their parent’s variables**. We also said **the variable name depends on the PID of the process**. **If all four processes were infected, you’d see four unique variable names**; but you see only two (VFTPXXPYVTAMF and QBYXKDAGXM). \n\nThe last three processes (IEXPLORE.EXE, notepad.exe, and firefox.exe) were spawned by PID 1144, which explains why they have a copy of the VFTPXXPYVTAMF variable.\n\n\n\n#### >> Standard Handles\n\nBy analyzing a process' standard handles, you can determine where it gets input and where it sends output and error messages.\n\nThis is especially useful when investigating potential breaches by **remote attackers**.\n\n> A fairly common way to create a backdoor command shell on a system involves **spawning an instance of `cmd.exe` and redirecting its standard handles over named pipes or network sockets**. Thus, the attackers can use `telnet` or `netcat` to connect to the target machine (provided that no firewall is blocking access), and type commands as if they were sitting at the console.\n\n\n\n#### >> Dynamic Link Libraries(DLLs)\n\nDLLs contain code and resources that can be shared between multiple processes. They’re popular among malware and threat actors because DLLs are designed to run inside a host process, thus giving them access to all of the process’ resources: its threads, handles, and full range of process memory.\n\n\n\n***How DLLs Are Loaded***\n\n* `Dynamic linking`: As part of the process initialization routines, any DLL in the executable (.exe) file’s IAT(import address table) automatically loads in the process’ address space.\n* ` Dependencies`: DLLs also have import tables, so when they’re loaded, all additional DLLs on which they rely load into the process’ address space. For more information, see Dependency Walker (http://www.dependencywalker.com/).\n\n* `Run-time dynamic linking (RTDL)`: A thread can explicitly call `LoadLibrary` (or the native `LdrLoadDll`) with the name of the DLL to load. This has the same end result as dynamic linking (a DLL loaded in the process), except there’s no trace of the DLL in the process’ IAT.\n\n* `Injections`: As you’ll learn later in the chapter, DLLs can also be forcefully injected into a target process.\n\n\n\n***Hiding DLLs***\n\nall three lists exist in process memory, any thread running in the process can unlink a metadata structure ( `_LDR_DATA_TABLE_ENTRY`) to hide it from the running system (and potentially memory forensics as well). For example, once loaded, the xyz.dll module can overwrite its own Flink and Blink pointers so that its entry is skipped during enumeration.\n\n![image-20200310224506418](https://tva1.sinaimg.cn/large/00831rSTly1gcp7samwu0j30p20gmdhb.jpg)\n\n\n\n***Listing DLLs in Memory***\n\nWe design `dlllist` plugin: enumerating DLLs by **walking the load order list.**  Thus The unlinking approach depicted in diagram above also affects Volatility’s dlllist plugin.\n\n```\npython vol.py –f mem.dmp --profile=WinXPSP3x86 dlllist –p 3108\n```\n\n![image-20200310225126658](https://tva1.sinaimg.cn/large/00831rSTly1gcp7yvtzq4j30ny0gigph.jpg)\n\n> The process executable (`notepad.exe`) is first to load in the process address space, thus it’s first in the load order list. Next, the `ntdll.dll` and `kernel32.dll` system libraries are loaded. The system then proceeds to load any DLLs in Notepad’s IAT and any dependency modules that those DLLs need.\n\nHowever, that the load count for the first batch of modules is 0xffff. Because this field is a short integer, **0xffff is actually -1**. A load **count of -1 means the DLL loaded because it was specified in an IAT**. (The others near the end, whose load counts are 0x3, 0x27, 0x4 and 0x1, were all loaded via explicit calls to `LoadLibrary`)\n\nAlthough there are plenty of legitimate reasons to call LoadLibrary, **its usage is also consistent with the techniques shellcode uses to set up the target process’ address space**. You may notice none of the explicitly loaded DLLs are suspicious per se—they’re all properly named and in the correct system32 path. \n\nHowever, when you consider their purpose (network related) and the host process context (notepad.exe), the situation begins to look quite abnormal. Most likely code needing access to networking DLLs has infected this process, and it loads them by calling `LoadLibrary`.\n\n\n\n***Detecting Unlinked DLLs***\n\nTwo methods can help you detect DLLs that are unlinked from all three lists:\n\n* `PE file scanning`: You can leverage techniques described in Chapter 7 to perform a brute force scan through process memory, **looking for all instances of PE files (based on their known MZ header signatures)**. \n\n  Remember, however, that the **PE headers are also in process memory**, so the same body of code that unlinks the DLL metadata structure can easily overwrite them.\n\n* `VAD cross-referencing`: This is the technique implemented by Volatility’s `ldrmodules` plugin. If you recall from Chapter 7, **VAD nodes contain full paths on disk to files mapped into the regions—including DLL files**. \n\n  The unique aspect of VADs is that **they exist in kernel memory** and attempts to manipulate the tree (i.e., unlink a VAD node) or overwrite their file pointers quickly result in system instability (blue screens).\n\n\n\nWe can use `ldrmodules` plugin\n\n* First enumerates all VAD nodes that contain mapped executable images. Specifically, **it looks for large nodes with `PAGE_EXECUTE_WRITECOPY` protections, a `VadImageMap` type, and the Image control flag set.**\n* It then compares **the starting addresses from the VAD nodes** with the **`DllBase` value from the `_LDR_DATA_TABLE_ENTRY` structures found in process memory**. \n* Entries identified through the VAD that aren’t represented in the DLL lists are potentially hidden.\n\n```\n$ python vol.py -f memory.dmp --profile=Win7SP1x64 ldrmodules -p 616\n```\n\n![image-20200310232557769](https://tva1.sinaimg.cn/large/00831rSTly1gcp8ysqshhj30o70djq6o.jpg)\n\n\n\n### > PE Files in Memory\n\n* Volatility can dump and rebuild PE files.\n\n* **Due to changes that occur during program execution, it's hard for you to get an exact copy of the original binary or even one that runs on another machine.**\n\nDumping an executable and compare its MD5 or SHA1 hash to the file on disk is also not likely possible.\n\nAnother reason why PE files dumped from memory often differ from the original file on disk is because of slack space:\n\n\n\n***PE File Slack Space***\n\nThe smallest page size on a typical x86 or x64 Windows system is 4,096 bytes. Most PE files have sections that are not exact multiples of the smallest page size.\n\n![image-20200311010829443](https://tva1.sinaimg.cn/large/00831rSTly1gcpbxhgloaj30h20ay3zi.jpg)\n\nAs the diagram above, the .text section, which is not an exact multiple of 4,096, must fully exist in memory marked as RX (read, execute), and the .data section must fully exist in memory marked as RW (read, write).\n\n> Because **protections are applied at the page level** (in other words, if a page is marked as executable, all bytes in the page are executable)---\n>\n> That the two sections must **be separated after being loaded into memory**. Otherwise, the beginning of the .data section ends up being RX instead of RW.\n\n\n\n#### >> Parsing PE Headers in Memory\n\nIt can be described as following steps:\n\n* using volatility to attach the certain process and launch volshell\n\n```\npython vol.py -f memory.dmp --profile=Win7SP1x64 volshell -p 516\n```\n\n* get the `process.peb` and `ImageBaseAddress`\n\nLet's take a review, `ImageBaseAddress` in PEB is **the address in process memory where the main executable (.exe) is loaded**. Take a look at `ImageBaseAddress` below:\n\n![image-20200311095415129](https://tva1.sinaimg.cn/large/00831rSTly1gcpr4j5amgj30nx02fmxb.jpg)\n\nWe can see `MZ(4d5a)` signature appears first.\n\n* get `NT` header\n\nWe could create an `_IMAGE_DOS_HEADER` at the base address we first got and use the `get_nt_header` function.\n\n![image-20200311100253259](https://tva1.sinaimg.cn/large/00831rSTly1gcprdirfx8j30o2083q46.jpg)\n\n* then print sections in PE\n\n![image-20200311100844130](https://tva1.sinaimg.cn/large/00831rSTly1gcprjm0fvvj30ny06jdgl.jpg)\n\n\n\n#### >> PE Extraction Plugins\n\nWe have shown in previous the whole process of extracting PE file to memory. Then there are some plugins that can automate the process:\n\n* `procdump`: Dump a process executable. You can identify the process by PID (`--pid`) or the physical offset of its `_EPROCESS` (`--offset`). \n\n  > The latter option enables you to dump processes hidden from the active process list.\n\n* `dlldump`: Dump a DLL. You can identify the host process by PID ( `--pid`) or the physical offset of its `_EPROCESS` (`--offset`). \n\n  > If the DLL(s) are in the load order list, you can identify them using a regular expression (`--regex/--ignore-case`) on their name. Otherwise, you can refer to them by their base address in process memory (`--base`). The latter option enables you to dump hidden or injected PE files. \n\n* `moddump`: **Dump a kernel module**. \n\nAll the plugins require an output directory (`--dump-dir`) to write the extracted files.\n\nThey also all accept an optional `--memory` parameter, which is how you request the slack space between sections to be included in the output file.\n\n\n\n**Examples:**\n\n* `procdump`\n\n```\n$ python vol.py -f memory.dmp --profile=Win7SP1x64 procdump --dump-dir=OUTDIR/\n```\n\n![image-20200311102633430](https://tva1.sinaimg.cn/large/00831rSTly1gcps251gtmj30nz07cmy9.jpg)\n\n> Notice the name of the output file is based on the PID of the process (`executable.PID.exe`).\n\nWe can extract a process that's not in the active process list based on the physical offset of its `_EPROCESS` **(which you can get with psscan or psxview)**:\n\n![image-20200311104526554](https://tva1.sinaimg.cn/large/00831rSTly1gcpslsm7c6j30o606a0ti.jpg)\n\n* `dlldump`\n\nextract any DLL from PID 1408 that has a name or path matching \"crypt\" string:\n\n![image-20200311105130051](https://tva1.sinaimg.cn/large/00831rSTly1gcpss3ljovj30o408k75u.jpg)\n\n> output files are named according to the PID and physical offset of the host process and the base virtual address of the DLL (module.PID. OFFSET.ADDRESS.dll)\n\n\n\nBut to dump DLLs hidden or injected we should use `--base` the base address where the DOS header exists:\n\n![image-20200311105642004](https://tva1.sinaimg.cn/large/00831rSTly1gcpsxijalsj30o706j3zd.jpg)\n\n\n\n***Caveats***\n\nOne thing to note about these plugins is that they’re susceptible to attacks that manipulate PE header values. For example, **if the MZ or PE signature isn’t found, they cannot properly locate the sections**. Furthermore, they also rely on the advertised section virtual addresses and sizes, which malicious code can easily overwrite.\n\nIf you encounter issues dumping PE files from process memory, whether it’s the process executable or a DLL, you can always fall back to just dumping the containing VAD region.\n\n\n\n### > Code Injection\n\nThe way to detect code injection depends on how the code was injected.\n\n* **Remote DLL injection**: A malicious process forces the target process to load a specified DLL from disk by calling LoadLibrary or the native LdrLoadDll. By definition, the DLL must exist on disk prior to being injected.\n\n* **Remote code injection**: A malicious process writes code into the memory space of a target process and forces it to execute. The code can be a block of shellcode (i.e., not a PE file) or it can be a PE file whose import table is preemptively configured for the target process.\n\n* **Reflective DLL injection**: A malicious process writes a DLL (as a sequence of bytes) into the memory space of a target process. The DLL handles its own initialization without the help of the Windows loader. The DLL does not need to exist on disk prior to being injected.\n\n* **Hollow process injection**: A malicious process starts a new instance of a legitimate process (such as lsass.exe) in suspended mode. Before resuming it, the executable section(s) are freed and reallocated with malicious code.\n\nIn the following descriptions, ***Process A is the malicious process and Process B is the target.***\n\n\n\n#### >> *Remote DLL Injection*\n\n1. ProcessA **enables debug privilege**(`SE_DEBUG_PRIVILEGE`) as if it were a debugger, so that it can read and write other process' memory.\n2. ProcessA calls `OpenProcess` and **opens a handle to ProcessB** (also request `PROCESS_CREATE_THREAD`, `PROCESS_VM_OPERATION`, and `PROCESS_VM_WRITE`)\n3. ProcessA calls `VirtualAllocEx` to **allocate memory in ProcessB**\n4. ProcessA **transfers a string(identifies the full path on disk to the malicious DLL)** to ProcessB's memory by calling `WriteProcessMemory`.(writing at the address allocated in previous step)\n5. ProcessA calls `CreateRemoteThread` to **start a new thread in ProcessB that executes the `LoadLibrary` function**.\n6. Now the injection is complete and processB has loaded the DLL. ProcessA calls `VirtualFree` to free the memory containing the DLL's path.\n7. ProcessA calls `CloseHandle` on ProcessB's process to clean up.\n\n\n\n***Detection***\n\n`LoadLibrary` was used to load the DLL, there is no good way to conclusively distinguish between the malicious DLL and other explicitly loaded DLLs in ProcessB.\n\n> The VAD and PEB lists look nearly identical from a metadata perspective for all modules loaded with the same API. \n>\n> **In other words, the injected DLL isn’t necessarily hidden at this point**; it is perfectly visible with `dlllist` or tools such as Process Explorer running on the live system. However, unless you know the specific name of the DLL, it can easily blend in with the legitimate modules.\n\nThere are still two factors can make detection possible:\n\n* If the injected DLL does attempt to hide from tools on the live system after it gets loaded (by unlinking its `_LDR_DATA_TABLE_ENTRY` from one or more of the ordered lists), you can use `ldrmodules` to detect it.\n* If the injected DLL is packed, and the unpacking procedure copies the decompressed code to a new memory region. In this case, you’ll detect it with `malfind` (described next).\n\n\n\n#### >> *Remote Code Injection*\n\nIt starts out with the same two steps as remote DLL injection above.\n\n3. ProcessA **allocates memory in ProcessB with `PAGE_EXECUTE_READWRITE` protection**.(It can alloc ProcessA to write and ProcessB to read and execute it).\n4. ProcessA **transfer a block of code to ProcessB** using `WriteProcessMemory`.\n5. ProcessA calls `CreateRemoteThread` and points the thread's starting address to a function within the code.\n\n\n\n***Detection***\n\nWe could use `malfind` plugin(it is designed to hunt down remote code injections).\n\nThe concept is:\n\n* There will be a readable, writeable, and executable private memory region (that is, no file mapping) with all pages committed (we use a few variations of these criteria for detection). \n* The region will **contain a PE header and/or valid CPU instructions**.\n\n**Examples:**\n\n```\n$ python vol.py –f stuxnet.mem --profile=WinXPSP3x86 malfind\n```\n\n\n\n*case1 - obvious injected code with MZ signature*\n\n\n\n![image-20200311122718332](https://tva1.sinaimg.cn/large/00831rSTly1gcpvjs26njj30nx0dnwg5.jpg)\n\n> In some cases, you’ll leverage the hex dump to determine whether the region is malicious (for example, **because you see an MZ signature**); \n\nIn other cases, you’ll need to rely on the disassembly(no `MZ` signature):\n\n\n\ncase2 - unconspicuous injected code without MZ signature*\n\n\n\n![image-20200311152041422](https://tva1.sinaimg.cn/large/00831rSTly1gcq0k6tf7sj30o40dtwh1.jpg)\n\n> This region at 0x9d0000 is worth further investigation because the disassembly contains CPU instructions that make sense. For example, the `JMP` destinations are valid, and the combination of `MOV EDI, EDI` followed by `PUSH EBP` indicates the start of a function prologue.\n\n\n\n*case3 - normal code similar to injected code*\n\n\n\nThe following region in `csrss.exe` was not injected by malware, it was picked up by the plugin due to its similarity to injection regions:\n\n![image-20200311154500763](https://tva1.sinaimg.cn/large/00831rSTly1gcq19hzu1jj30o20bkabo.jpg)\n\nKeep in mind that programs may allocate executable private memory for legitimate reasons.\n\n> For example, there’s an `ENTER` instruction, but no `LEAVE`. There’s conditional jump (`JNO`), but no condition. Furthermore, the destination of the jump leads to 0x7f6f0007, an address that does not contain an instruction according to the current alignment.\n>\n> It is just meaningless.\n\n\n\n*case4 - hidden injected code with coreflood*\n\n\n\n![image-20200311155332478](https://tva1.sinaimg.cn/large/00831rSTly1gcq1idd58pj30o00csabu.jpg)\n\nMost analysts assume that this range at 0x7ff80000 is a false positive. The hex dump and disassembly both consist of only zeros. (**In this case, Coreflood’s antidumping feature wiped out its PE header (which occupied the first page) by overwriting it with zeros)**.\n\n However, remember that this is only a preview of the data. **The CPU doesn’t necessarily start executing code at offset 0 in the injected region; it can easily point somewhere within the range.**\n\nUse `volshell` to disassemble code in the seconde page we could see the main function:\n\n![image-20200311155607867](https://tva1.sinaimg.cn/large/00831rSTly1gcq1l279lfj30o70bjgnn.jpg)\n\n\n\n#### >> *Reflective DLL Injection*\n\nThis method is a hybrid of the two approaches discussed previously. \n\nThe content transferred from Process A to Process B is a DLL (as opposed to a block of shellcode), but after it exists in Process B, it initializes itself instead of calling `LoadLibrary`.\n\nIt has several anti-forensics advantages:\n\n* `LoadLibrary` only loads libraries from disk. **Because this method doesn’t rely on the API, the injected DLL never needs to be written to more permanent storage**. It can be loaded into memory straight from the network (for example, when exploiting a remote buffer overflow).\n\n* Also as a result of avoiding `LoadLibrary`, **the `_LDR_DATA_TABLE_ENTRY` metadata structures are not created**. Thus the **three lists in the PEB do not have a record of this DLL** loading.\n\n\n\n***Detection***\n\nFirst take a look at an example(a snippet of code) of Reflection DLL Injection project's `LoadLibraryR.c` file:\n\n```\n// alloc memory (RWX) in the host process for the image... \nlpRemoteLibraryBuffer = VirtualAllocEx( hProcess, NULL, dwLength,\n                           MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); \nif(!lpRemoteLibraryBuffer) \n   break;\n```\n\nDue to the options chosen during allocation, the VAD in the host process that contains the DLL fits the criteria for `malfind`.\n\nSo we can use `malfind`.\n\n\n\n#### >> *Hollow Process Injection*\n\nThe malware starts a new instance of a legitimate process, such as lsass.exe. Before the process’ first thread begins, the malware frees the memory containing the lsass.exe code (it hollows it out) and replaces it with the body of the malware.\n\n![image-20200311161409689](https://tva1.sinaimg.cn/large/00831rSTly1gcq23twd95j30oj0d0wfr.jpg)\n\n> PEB and various other data structures identify the path to the legitimate lsass.exe binary.(unchanged)\n\n***Hollow a process***\n\n1. Start a new instance of a legitimate process (for example, C:\\windows\\system32\\lsass.exe), but with its first thread suspended. \n\n   > At this point, the `ImagePathName` in the PEB of the new process identifies the full path to the legitimate lsass.exe.\n\n2. **Acquire the contents for the malicious replacement code**. This content can come from a file on disk, an existing buffer in memory, or over the network.\n\n3. Determine the base address (ImageBase) of the lsass.exe process, and then **free or unmap the containing memory section**. \n\n   > At this point, the process is just an empty container (the DLLs, heaps, stacks, and open handles are still intact, but no process executable exists).\n\n4. Allocate a new memory segment in lsass.exe and make sure that the memory can be read, written, and executed. \n\n   > You can reuse the same `ImageBase` or a different one\n\n5. Copy the PE header for the malicious process into the newly allocated memory in lsass.exe\n\n6. Copy each PE section for the malicious process into the proper virtual address in lsass.exe\n\n7. Set the start address for the first thread (the one that has been in a suspended state) to point at the malicious process’ AddressOfEntryPoint value.\n\n8. Resume the thread.\n\n   > The malicious process begins executing within the container created for lsass.exe. The ImagePathName in the PEB still points to C:\\windows\\system32\\lsass.exe.\n\n\n\n***Detection***\n\n\n\nFirst we can list all processes using `pslist`:\n\n![image-20200311165645526](https://tva1.sinaimg.cn/large/00831rSTly1gcq3c5jf4vj30oc05b758.jpg)\n\n> There are three processes (PID 680, 868, and 1928), but only one is the “real” lsass.exe. Intuition may tell you that the one that **started first based on creation time (PID 680) is the legitimate one**, but we’ll show you how to confirm.\n\nNow we can see `ImageBase` by `dlllist` for the processes:\n\n![image-20200311165841601](https://tva1.sinaimg.cn/large/00831rSTly1gcq3e5shgaj30o40a1myy.jpg)\n\n> The advertised paths are all the same (despite two having an extra set of quotes around the path) because the data in the PEB, including the `ImageBase`, is initialized at process creation, and all processes started out the same.\n\n\n\nHowever, as a result of being hollowed, the VAD characteristics for the region that contains the ImageBase are drastically different:\n\n![image-20200311165948460](https://tva1.sinaimg.cn/large/00831rSTly1gcq3fb9za5j30o00hi77u.jpg)\n\n![image-20200311165956271](https://tva1.sinaimg.cn/large/00831rSTly1gcq3fgk8bej30nz0b2dhu.jpg)\n\n> Only the legitimate one (PID 680) still has a copy of the lsass.exe file mapped into the region\n\n","tags":["memory forensics","notes"],"categories":["memory forensics"]},{"title":"手把手带你MIT6.828 - Lab3","url":"/2020/03/10/joslab3/","content":"\n# Lab3 User Environments\n\n官方文档: [lectures](https://pdos.csail.mit.edu/6.828/2018/lec/)\n\n### > 实验介绍\n\n在本次实验中，我们将实现最基本的内核功能以使得一个受保护的用户模式环境（进程）可以正常运行。我们将增强jos的内核，设置一系列数据结构以追踪用户环境，创建一个单一用户环境，加载程序镜像然后执行。\n\n同时我们将让jos的内核能够处理用户环境的系统调用以及其他引发的异常。\n\n> 在本次实验中，*环境（environment）*和*进程（process）*这两个术语是可以交换的，他们都表示程序运行的抽象层面。我们使用术语*环境*而非*进程*，是为了强调我们的观念：jos的*环境*以及UNIX的*进程*提供了不同的interface，而非相同的语义。\n\n\n\n### > 实验准备\n\n使用git切换分支。\n\n```\ngit checkout -b lab3 origin/lab3\ngit merge lab2\n```\n\n在这个过程中出现了冲突，我们将`kern/monitor.c`的冲突进行编辑即可。\n\n实验三新增文件：\n\n* inc/\n  * inc/env.h 用户模式环境的公有定义\n  * inc/trap.h 陷阱处理的公有定义\n  * inc/syscall.h 用户环境对内核的系统调用的公有定义\n  * inc/lib.h 用户模式支持的库公有定义\n* kern/\n  * kern/env.h 用户模式环境的内核私有定义\n  * kern/env.c 用户模式环境的内核代码实现\n  * kern/trap.h 内核私有的陷阱处理定义\n  * kern/trap.c 陷阱处理代码\n  * kern/trapentry.S 汇编语言的陷阱处理程序入口\n  * kern/syscall.h 系统调用处理的内核私有定义\n  * kern/syscall.c 系统调用实现代码\n* lib/\n  * lib/Makefrag 用户模式库obj/lib/libjos.a的Makefile\n  * lib/entry.S 用户环境的汇编语言入口\n  * lib/libmain.c entry.S调用的用户模式库安装代码\n  * lib/syscall.c 用户模式系统调用的打桩函数\n  * lib/console.c 用户模式的putchar和getchar实现，提供了控制台IO\n  * lib/exit.c 用户模式的exit实现\n  * lib/panic.c 用户模式的panic实现\n* user/* 检验内核实验三代码的测试程序\n\n**内联汇编**\n\n在本实验中我们会频繁发现gcc的内联汇编的使用，我们必须要理解。\n\n[x86内联汇编](https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/index.html)中给出了详细教程。\n\n\n\n## Part A: User Environments and Exception Handling\n\n`inc/env.h`头文件包含了jos用户环境中的基本定义，我们需要进行阅读。kernel使用了`struct env`来追踪每一个用户环境。这个实验中我们只需要创建一个环境，尽管如此，我们将设计jos的内核以支持多用户环境。而在lab4中，我么将会用一个用户环境去`fork`其他用户环境，以利用多用户环境的特性。\n\n`kern/env.c`中，我们可以看到kernl维护了三个与环境有关的全局变量：\n\n```c\nstruct Env *envs = NULL;\t\t// All environments\nstruct Env *curenv = NULL;\t\t// The current env\nstatic struct Env *env_free_list;\t// Free environment list\n```\n\n一旦jos成功运行之后，`envs`指针将会指向一个`struct env`类型的数组用以表示系统中所有的环境。在我们的设计中，jos的内核将会允许最大数量`NENV`个环境同时激活（尽管实际上在一个特定时间里，运行的环境非常少）。`NENV`在`inc/env.h`中定义。\n\n同理，jos的kernel使用`env_free_list`来维护当前所有未激活的`struct env`，这样的设计简化了环境分配和释放的过程，它们仅仅需要从该链表上进行添加或者移除。\n\nkernel使用`curenv`去追踪任意时刻当前正在运行的环境。在boot启动过程中知道直到第一个环境运行的时间之前，`curenv`被设置为NULL。\n\n\n\n### A.1 Environment State\n\n`env`结构体在`inc.env`中有如下定义：\n\n```c\nstruct Env {\n\tstruct Trapframe env_tf;\t// Saved registers\n\tstruct Env *env_link;\t\t// Next free Env\n\tenvid_t env_id;\t\t\t// Unique environment identifier\n\tenvid_t env_parent_id;\t\t// env_id of this env's parent\n\tenum EnvType env_type;\t\t// Indicates special system environments\n\tunsigned env_status;\t\t// Status of the environment\n\tuint32_t env_runs;\t\t// Number of times environment has run\n\n\t// Address space\n\tpde_t *env_pgdir;\t\t// Kernel virtual address of page dir\n};\n```\n\n* `env_tf`：这是个结构体类型变量，其中`struct Trapframe`在`inc/trap.h`中定义，表示当环境不运行或者其他环境运行时，该环境被保存的寄存器值。kernel保存这些值主要用于上下文切换和现场保护。\n* `env_link`：指向`env_free_list`的下一个环境成员（`env_free_list`指向链表中的第一个空闲环境）。\n* `env_id`：kernel储存的用于标识该环境的唯一标识符。在用户的一个环境结束之后，kernel可能会将同样的`env`重新分配给另一个环境，但是`env_id`将是不同的。\n* `env_parent_id`：存储了创建该环境的环境的`env_id`（可以理解为父亲节点），通过这个方式我们可以形成环境的'family tree'（用于安全方面的决策）\n* `env_type`：用于标记特殊的环境类型。对于大部分环境，该值为`ENV_TYPE_USER`，后续的lab中将会有其他的值。\n* `env_status` - 环境状态，有以下几种取值：\n  * `ENV_FREE`：表明`struct env`处于空闲状态，应当在`env_free_list`上\n  * `ENV_RUNNABLE`：表明`struct env`代表的环境正在等待运行\n  * `ENV_RUNNING`：表明`struct env`代表的环境为正在运行的环境\n  * `ENV_NOT_RUNNABLE`：表明`struct env`代表的环境正在运行，但是没有准备好继续运行：比如等待另一个环境的IPC（进程间通信）\n  * `ENV_DYING`：表明`struct env`代表的环境是一个僵尸环境，僵尸环境将在下一次陷入内核的时候被释放\n* `env_pgdir`：保存了环境的页目录的内核虚拟地址。\n\n\n\n如同Unix的进程一样，jos的环境结合了线程（thread）和地址空间（address space）。线程是由`env_tf`域的被保存的寄存器值定义；地址空间是由`env_pgdir`域指向的页目录和页表定义。如果想让一个环境能够运行，kernel必须要使用保存的寄存器值和合适的地址空间来设置CPU。\n\njos的`struct env`结构和xv6的`struct proc`非常类似。两种结构都持有了用户模式的寄存器状态。然而在jos中，每一个独立的环境并不具有不同的内核栈（kernel stack），因为jos的内核中同时只能有一个运行的jos环境，也就是说jos只需要一个内核栈。\n\n\n\n### A.2 Allocating the Environment Array\n\n在lab2中，我们已经在`mem_init()`的过程中为`pages[]`数组分配了内存（kernel用于追踪哪些pages是空闲的，哪些不是）。我们现在需要修改`mem_init()`函数，类似地，进一步为`struct Env`结构体数组`Envs`分配空间。\n\n**exercise 1:**\n\n在`kern/pmap.c`中修改`mem_init()`函数为`envs`数组分配空间，这个数组包含了`NENV`个结构体实例成员。如同`pages`一样，`envs`所读经的内存空间需要映射到用户只读区域`UENVS`之上（详见lab2的内存结构分配图以或者`inc/memlayout.h`中内存分配的定义）。\n\n完成后我们可以运行`check_kern_pgdir()`来检查。\n\n```c\n  //////////////////////////////////////////////////////////////////////\n\t// Make 'envs' point to an array of size 'NENV' of 'struct Env'.\n\t// LAB 3: Your code here.\n\tuint32_t envs_size = sizeof(struct Env) * NENV;\n\tenvs = boot_alloc(envs_size);\n\tmemset(envs, 0, envs_size);\n\t//////////////////////////////////////////////////////////////////////\n\t// Map the 'envs' array read-only by the user at linear address UENVS\n\t// (ie. perm = PTE_U | PTE_P).\n\t// Permissions:\n\t//    - the new image at UENVS  -- kernel R, user R\n\t//    - envs itself -- kernel RW, user NONE\n\t// LAB 3: Your code here.\n\tboot_map_region(kern_pgdir, UENVS, envs_size, PADDR(envs), PTE_U | PTE_P);\n```\n\n顺利完成后，即可在qemu中看到`chech_kern_pgdir() succeeded!`\n\n\n\n### A.3 Creating and Running Environments\n\n我们现在将在`kern/env.c`中编写运行用户环境的必要代码。目前为止我们还没有文件系统，我们将只能配置内核以加载一个嵌入内核中的静态二进制映像。jos内核将这个二进制镜像以ELF可执行镜像格式进行嵌入。\n\nLab3的`GNUMakefile`在`obj/user`目录中生成了一些二进制映像（binary image）。观察`kern/Makefrag`我们会发现一些链接的魔法：链接器将这些二进制文件直接装载到kernel的可执行文件中，就如同这些文件是`.o`类型的文件。同时链接器的`-b binary`选项使得这些文件以原始未被翻译的raw binary file形式，而不是普通的编译器生成的`.o`文件形式进行链接（以`-b binary`选项进行链接，这些文件并不需要是真正的ELF文件，他们甚至可以是文本文件或者图片）。\n\n在建立kernel过程结束之后，我们观察`obj/kern/kernel.sym`，会注意到链接器有魔力地生成了一些有趣的符号，比如`_binary_obj_user_hello_start`，`_binary_obj_user_hello_end`以及`_binary_obj_user_hello_size`。链接器通过二进制文件的名字生成了这些符号的名字，这些符号使得内核代码能够通过某种方式引用对应的二进制文件。\n\n在`i386_init()`以及`kern/init.c`中，我们将会看到我们的代码运行了装载到环境中的二进制映像。然而，用于建立用户环境的一些关键函数还并没有完成，我们需要将其完成。\n\n**exercise 2:**\n\n在`env.c`中，完善如下代码：\n\n* `env_init()`\n\n初始化所有`envs`数组中的`struct env`类型的结构，然后将其添加到`env_free_list`中。同时调用`env_init_percpu`函数，该函数将配置硬件分段来将特权级不同的段分开：内核有特权级0，用户有特权级3。\n\n> 错误记录：`i`必须使用`int`类型，使用`size_t`会直接产生`Triple_Fault`\n\n```c\n// Mark all environments in 'envs' as free, set their env_ids to 0,\n// and insert them into the env_free_list.\n// Make sure the environments are in the free list in the same order\n// they are in the envs array (i.e., so that the first call to\n// env_alloc() returns envs[0]).\n//\nvoid\nenv_init(void)\n{\n\t// Set up envs array\n\t// LAB 3: Your code here.\n\tsize_t i;\n\tfor(i = NENV - 1; i >= 0; i--){\n\t\tenvs[i].env_status = ENV_FREE;\n\t\tenvs[i].env_id = 0;\n\t\tenvs[i].env_link = env_free_list;\n\t\tenv_free_list = &envs[i];\n\t}\n\t// Per-CPU part of the initialization\n\tenv_init_percpu();\n}\n```\n\n\n\n* `env_setup_vm()`\n\n为新的用户环境建立一个虚拟内存系统（为其分配页目录同时初始化新环境内核部分的地址空间）。这里由于用户环境在`UTOP`之上的虚拟空间其实都是内核空间在这个区域的副本，在`UTOP`之下的部分在初始化过程全部可以初始为0，即我们可以直接用`kern_pgdir`中的内容为模版建立用户环境的页目录。\n\n这里回顾一下lab2中`mem_init()`调用了几个`boot_map_regions()`将`kern_pgdir`内核区域的页表和地址管理全部建立起来，而并没有关心`UTOP`以下的用户区部分，所以我们这里使用`kern_pgdir`为模版，为每一个用户环境可以设置相同的内核虚拟地址空间，而用户区域的则先全部仅仅进行初始化。\n\n```c\n\n//\n// Initialize the kernel virtual memory layout for environment e.\n// Allocate a page directory, set e->env_pgdir accordingly,\n// and initialize the kernel portion of the new environment's address space.\n// Do NOT (yet) map anything into the user portion\n// of the environment's virtual address space.\n//\n// Returns 0 on success, < 0 on error.  Errors include:\n//\t-E_NO_MEM if page directory or table could not be allocated.\n//\nstatic int\nenv_setup_vm(struct Env *e)\n{\n\tint i;\n\tstruct PageInfo *p = NULL;\n\n\t// Allocate a page for the page directory\n\tif (!(p = page_alloc(ALLOC_ZERO)))\n\t\treturn -E_NO_MEM;\n\n\t// Now, set e->env_pgdir and initialize the page directory.\n\t//\n\t// Hint:\n\t//    - The VA space of all envs is identical above UTOP\n\t//\t(except at UVPT, which we've set below).\n  // 意思是 内核区域以上的页目录是统一的，而用户区域的页表管理则由对应的环境进行分配\n  \n\t//\tSee inc/memlayout.h for permissions and layout.\n\t//\tCan you use kern_pgdir as a template?  Hint: Yes.\n\t//\t(Make sure you got the permissions right in Lab 2.)\n\t//    - The initial VA below UTOP is empty.\n\t//    - You do not need to make any more calls to page_alloc.\n\t//    - Note: In general, pp_ref is not maintained for\n\t//\tphysical pages mapped only above UTOP, but env_pgdir\n\t//\tis an exception -- you need to increment env_pgdir's\n\t//\tpp_ref for env_free to work correctly.\n\t//    - The functions in kern/pmap.h are handy.\n\n\t// LAB 3: Your code here.\n\te -> env_pgdir = (pde_t *)page2kva(p);\n\tp -> pp_ref += 1;\n\tmemcpy(e->env_pgdir, kern_pgdir, PGSIZE);\n\t// UVPT maps the env's own page table read-only.\n\t// Permissions: kernel R, user R\n\te->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;\n\n\treturn 0;\n}\n\n```\n\n\n\n* `region_alloc()`\n\n这个函数用于为环境分配物理空间。\n\n> 错误记录：注意`ROUNDDOWN`以及`ROUNDUP`的类型转换。\n\n```c\n//\n// Allocate len bytes of physical memory for environment env,\n// and map it at virtual address va in the environment's address space.\n// Does not zero or otherwise initialize the mapped pages in any way.\n// Pages should be writable by user and kernel.\n// Panic if any allocation attempt fails.\n//\nstatic void\nregion_alloc(struct Env *e, void *va, size_t len)\n{\n\t// LAB 3: Your code here.\n\t// (But only if you need it for load_icode.)\n\t//\n\t// Hint: It is easier to use region_alloc if the caller can pass\n\t//   'va' and 'len' values that are not page-aligned.\n\t//   You should round va down, and round (va + len) up.\n\t//   (Watch out for corner-cases!)\n\tuintptr_t start_addr = (uintptr_t) ROUNDDOWN(va, PGSIZE);\n\tuintptr_t end_addr = (uintptr_t) ROUNDUP(va + len, PGSIZE);\n\twhile(start_addr < end_addr){\n\t\tstruct PageInfo * p;\n\t\tp = page_alloc(ALLOC_ZERO);\n\t\tif(!p){\n\t\t\tpanic(\"[region_alloc] page alloc error: %e\\n\", -E_NO_MEM);\n\t\t}\n\t\tpage_insert(e -> env_pgdir, p, (void *)start_addr, PTE_P | PTE_U | PTE_W);\n\t\tstart_addr += PGSIZE;\n\t}\n}\n```\n\n这个函数完成后，我们能够为环境以物理页为单位映射到用户虚拟空间中，并且配置该环境的页目录。\n\n\n\n* `load_icore`\n\n该函数的作用是解析ELF镜像文件，并将目标ELF镜像文件加载到环境的用户地址空间中。同时他还为这个加载进入用户空间的二进制文件创建一个程序栈。\n\n根据函数的注释，我们可以按照`boot/main.c`代码加载ELF的方式获取一些提示，同时我们仍然需要了解ELF头和文件结构（在lab1中进行了讲解）：\n\n<img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gcfndwkks1j30go0g9gna.jpg\" alt=\"image-20200302160913062\" style=\"zoom:67%;\" />\n\n同时在`inc/elf.h`中也有相应的结构定义：\n\n```c\nstruct Elf {                  //对应上图的ELF头部\n\tuint32_t e_magic;\t// must equal ELF_MAGIC\n\tuint8_t e_elf[12];\n\tuint16_t e_type;\n\tuint16_t e_machine;\n\tuint32_t e_version;\n\tuint32_t e_entry;\n\tuint32_t e_phoff;\n\tuint32_t e_shoff;\n\tuint32_t e_flags;\n\tuint16_t e_ehsize;\n\tuint16_t e_phentsize;\n\tuint16_t e_phnum;\n\tuint16_t e_shentsize;\n\tuint16_t e_shnum;\n\tuint16_t e_shstrndx;\n};\n\nstruct Proghdr {              //对应上图的ELF程序头部\n\tuint32_t p_type;\n\tuint32_t p_offset;\n\tuint32_t p_va;\n\tuint32_t p_pa;\n\tuint32_t p_filesz;\n\tuint32_t p_memsz;\n\tuint32_t p_flags;\n\tuint32_t p_align;\n};\n```\n\n对于ELF的详细知识仍然请移步CSAPP，有关本次实验我们只需要知道如下知识：\n\nELF头部在其二进制文件的开头部分，且通过解析ELF头部我们可以得到`e_phoff`即程序头表的位置，以及程序头表的大小`e_phnum`。\n\n程序头表`struct Proghdr`是专门用来描述段信息的（注意这个段不是内存中的段，程序头描述的段时磁盘上程序的一个段，如常见的代码段和数据段等）。我们可以通过遍历程序头表，通过每一个段的`p_type`来获取每一个段的信息（在这里我们只需要*可加载程序段*`ELF_PROG_LOAD`），然后将所需的段加载进入内存。（我们要理解注释中的`ph`正是`struct Proghdr *`类型的）\n\n同时我们还需要注意到`cr3`寄存器，在这个函数运行之前我们的运行环境是内核环境kernel，此时`cr3`中存放的是`kern_pgdir`。这里我们需要用户环境，因此我们需要使用`lcr3()`切换到用户环境的页目录，加载完镜像之后再切换回内核页目录。\n\n我们还需要为程序设置入口点，根据注释的提示我们观察`env_pop_tf()`函数，其作用是恢复保存在`env_tf`即结构体`struct Trapframe *`中的寄存器并返回。这里我们在结构体`struct Trapframe *`中很容易找到成员`tf_eip`，这就是环境中所保存的`IP`寄存器了。而让环境的`IP`寄存器指向二进制的可执行程序部分，也就是ELF头部中的`e_entry`成员。\n\n```c\n//\n// Set up the initial program binary, stack, and processor flags\n// for a user process.\n// This function is ONLY called during kernel initialization,\n// before running the first user-mode environment.\n//\n// This function loads all loadable segments from the ELF binary image\n// into the environment's user memory, starting at the appropriate\n// virtual addresses indicated in the ELF program header.\n// At the same time it clears to zero any portions of these segments\n// that are marked in the program header as being mapped\n// but not actually present in the ELF file - i.e., the program's bss section.\n//\n// All this is very similar to what our boot loader does, except the boot\n// loader also needs to read the code from disk.  Take a look at\n// boot/main.c to get ideas.\n//\n// Finally, this function maps one page for the program's initial stack.\n//\n// load_icode panics if it encounters problems.\n//  - How might load_icode fail?  What might be wrong with the given input?\n//\nstatic void\nload_icode(struct Env *e, uint8_t *binary)\n{\n\t// Hints:\n\t//  Load each program segment into virtual memory\n\t//  at the address specified in the ELF segment header.\n\t//  You should only load segments with ph->p_type == ELF_PROG_LOAD.\n\t//  Each segment's virtual address can be found in ph->p_va\n\t//  and its size in memory can be found in ph->p_memsz.\n\t//  The ph->p_filesz bytes from the ELF binary, starting at\n\t//  'binary + ph->p_offset', should be copied to virtual address\n\t//  ph->p_va.  Any remaining memory bytes should be cleared to zero.\n\t//  (The ELF header should have ph->p_filesz <= ph->p_memsz.)\n\t//  Use functions from the previous lab to allocate and map pages.\n\t//\n\t//  All page protection bits should be user read/write for now.\n\t//  ELF segments are not necessarily page-aligned, but you can\n\t//  assume for this function that no two segments will touch\n\t//  the same virtual page.\n\t//\n\t//  You may find a function like region_alloc useful.\n\t//\n\t//  Loading the segments is much simpler if you can move data\n\t//  directly into the virtual addresses stored in the ELF binary.\n\t//  So which page directory should be in force during\n\t//  this function?\n\t//\n\t//  You must also do something with the program's entry point,\n\t//  to make sure that the environment starts executing there.\n\t//  What?  (See env_run() and env_pop_tf() below.)\n\n\t// LAB 3: Your code here.\n\tlcr3(PADDR(e -> env_pgdir));\n\tstruct Elf * elf = (struct ELF *)binary;\n\t// 参考main.c解析ELF头\n\tstruct Proghdr * ph, * eph;\n\t// check magic\n\tif(elf->e_magic != ELF_MAGIC)\n\t\tpanic(\"[load_icode] Invalid ELF File\\n\");\n\t// segment iteration\n\tph = (struct Proghdr *)(binary + elf->e_phoff);\n\teph = ph + elf->e_phnum;\n\tfor(; ph < eph; ph++){\n\t\tif(ph -> p_type == ELF_PROG_LOAD){\n\t\t\t// 为该虚拟地址分配物理页\n\t\t\tregion_alloc(e, (void *)ph->p_va, ph->p_memsz);\n\t\t\t// 将ELF header拷贝到用户环境虚拟地址\n\t\t\tmemcpy((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz);\n\t\t}\n\t}\n\tlcr3(PADDR(kern_pgdir));\n\t(e->env_tf).tf_eip = elf->e_entry;\n\t// Now map one page for the program's initial stack\n\t// at virtual address USTACKTOP - PGSIZE.\n\t// LAB 3: Your code here.\n\tstruct PageInfo * stack = page_alloc(ALLOC_ZERO);\n\tif(!stack)\n\t\tpanic(\"[load_icode] Lack memory for allocing program stack\\n\");\n\tif(page_insert(e->env_pgdir, stack, (void *)USTACKTOP - PGSIZE, PTE_W | PTE_P | PTE_U) < 0){\n\t\tpanic(\"[load_icode] Error in setting program's stack\\n\");\n\t}\n}\n```\n\n\n\n* `env_create()`\n\n在内核初始化的过程中创建一个新的环境。\n\n```c\n//\n// Allocates a new env with env_alloc, loads the named elf\n// binary into it with load_icode, and sets its env_type.\n// This function is ONLY called during kernel initialization,\n// before running the first user-mode environment.\n// The new env's parent ID is set to 0.\n//\nvoid\nenv_create(uint8_t *binary, enum EnvType type)\n{\n\t// LAB 3: Your code here.\n\tstruct Env * env;\n\tint error = env_alloc(&env, 0);\n\tif(error){\n\t\tpanic(\"[env_create] error: %e\", error);\n\t}\n\tload_icode(env, binary);\n\tenv -> env_type = type;\n}\n```\n\n\n\n* `env_run`\n\n用户环境的上下文切换。\n\n```c\n//\n// Context switch from curenv to env e.\n// Note: if this is the first call to env_run, curenv is NULL.\n//\n// This function does not return.\n//\nvoid\nenv_run(struct Env *e)\n{\n\t// Step 1: If this is a context switch (a new environment is running):\n\t//\t   1. Set the current environment (if any) back to\n\t//\t      ENV_RUNNABLE if it is ENV_RUNNING (think about\n\t//\t      what other states it can be in),\n\t//\t   2. Set 'curenv' to the new environment,\n\t//\t   3. Set its status to ENV_RUNNING,\n\t//\t   4. Update its 'env_runs' counter,\n\t//\t   5. Use lcr3() to switch to its address space.\n\t// Step 2: Use env_pop_tf() to restore the environment's\n\t//\t   registers and drop into user mode in the\n\t//\t   environment.\n\n\t// Hint: This function loads the new environment's state from\n\t//\te->env_tf.  Go back through the code you wrote above\n\t//\tand make sure you have set the relevant parts of\n\t//\te->env_tf to sensible values.\n\n\t// LAB 3: Your code here.\n\tif (curenv)\n\t{\n\t\tif (curenv->env_status == ENV_RUNNING)\n\t\t{\n\t\t\tcurenv->env_status = ENV_RUNNABLE;\n\t\t}\n\t\tcurenv = e;\n\t\tcurenv->env_status = ENV_RUNNING;\n\t\tcurenv->env_runs += 1;\n\t\tlcr3(PADDR(e->env_pgdir));\n\t}\n\tenv_pop_tf(&curenv->env_tf);\n\tpanic(\"env_run not yet implemented\");\n}\n```\n\n当我们完成以上所有函数，在此给出函数调用关系图：\n\n- `start` (`kern/entry.S`)\n- `i386_init` (`kern/init.c`) \n  - `cons_init`\n  - `mem_init`\n  - `env_init`\n  - `trap_init` (still incomplete at this point)\n  - `env_create`\n  - `env_run`\n    - `env_pop_tf`\n\n在我们完成以上内容，我们的操作系统会进入用户环境并且执行`hello`这个二进制文件，直至执行到系统调用`int` 指令。此时由于jos还并没有设置任何从用户空间进入内核空间的方法，我们会遇到问题。\n\n而且当CPU发现我们无法处理系统中断调用之后，会产生一个通用保护错误（general protection exception），于是生成了一个二重错误（double fault exception）。最终还会因为无法处理这些错误而生成三重错误（triple fault）然后放弃进行系统重启。（为了方便调试，6.868修改了qemu使得此时出现三重错误时打印所有寄存器值以及内存状态）\n\n检验我们是否正确完成了工作非常简单，我们依旧使用gdb进行调试。首先我们在`env_pop_tf()`函数打断点`b kern/env.c:env_pop_tf`并且运行到该断点之后，使用`si`单步进行到`iret`，这是我们可以看到我们的操作系统成功将`0xf0000000`以上的指令转而执行`0x80000000`以上的指令，即进入了我们的用户地址空间：\n\n![image-20200315145606468](https://tva1.sinaimg.cn/large/00831rSTly1gcumbvzgk3j30f704pdgc.jpg)\n\n最终在`int`指令处，我们会遭遇triple fault，如同之前分析所得。\n\n![image-20200315145707316](https://tva1.sinaimg.cn/large/00831rSTly1gcumcwno7ej312v0bm43d.jpg)\n\n\n\n### A.4 Handling Interrupts and Exceptions\n\n按照我们上述的分析，此时在用户环境执行了系统调用会直接宕机：处理器进入用户环境以后，没有办法再次调用内核处理异常。这里我们就需要实现内核对基本异常以及系统调用的处理，首先我们需要熟悉x86下的中断和异常机制。\n\n**exercise 3**\n\n阅读[Chapter 9, Exceptions and Interrupts](https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm)，了解中断和异常处理部分。\n\n*中断是处理器以外的异步事件引发的，而异常是由当前正在执行的指令同步引发的。*\n\n\n\n### A.5 Basics of Protected Control Transfer\n\n异常（exceptions）以及中断（interrupts）都是**受保护控制转移**，引发处理器从用户模式切换到内核模式（CPL=0），避免用户模式代码干扰内核的环境。\n\n为了确保这些受保护的控制传递，在x86中主要有两种方式能够保证发生中断/异常时当前正在运行的代码不会随意选择进入内核的位置和方式（即只有在精心控制下才能进入内核），分别是中断描述符表（Interrupt Descriptor Table）和任务状态段（Task State Segment）。\n\n\n\n#### >> 中断描述符表IDT\n\n中断描述符表（IDT）将每个中断或异常标识符与服务于相关事件的指令的描述符相关联。像GDT和LDT一样，IDT是8字节描述符的数组。通过这种方式处理器保证了异常和中断仅能导致内核在若干具体的、明确定义的入口执行。\n\nIntel一共定义了256种异常，每一种异常都有一个独特的异常号（异常向量），CPU以异常号为索引去中断描述符表中寻找对应表项，然后对特定中断进行处理。而所有异常（exception）都使用0-31之间的32个异常号，剩余的则对应于软件或硬件中断（interrupt）。\n\n中断描述符表可以驻留在物理内存的任意位置？（应该是在内核的私有内存建立）\n\n处理器从该表中加载送入EIP寄存器的值（处理程序的入口），以及送入CS段寄存器的值（包括特权级，jos中所有异常都在内核模式之行，具有特权级0）\n\n![image-20200316201747268](https://tva1.sinaimg.cn/large/00831rSTgy1gcw1buarcxj30h70clwem.jpg)\n\n\n\n#### >> 任务状态段TSS\n\n处理器需要将中断/异常发生之前的寄存器值保存起来（比如EIP寄存器和CS段寄存器），以便执行完处理程序之后恢复现场，从中断/异常发生的地方继续执行。但是需要注意，保存旧寄存器状态的区域必须**对非特权用户模式代码处于被保护状态**。否则恶意代码或者错误代码会破坏内核。也就是说保存状态的区域是不能被用户特权级访问的。\n\n基于这个原因，x86处理器在处理特权级转变的时候，建立了一个独立于用户栈之外的栈。任务状态段指定了相应的段寄存器以及栈的地址。处理器需要将`SS`，`EFLAGS`，`CS`，`EIP`以及一个可选的错误码压入新栈中。然后从中断描述符中读取相应的`CS`和`EIP`。同时设置`ESP`和`SS`指向新的栈。\n\n\n\n**Example：**\n\n现在假设用户环境在执行一条代码的时候试图进行除零运算：\n\n* 处理器根据TSS所定义的`SS0`和`ESP0`来切换程序栈，在jos中他们分别对应`GD_KD`以及`KSTACKTOP`。\n* 处理器将需要保护所有现场压入栈中\n\n![image-20200317111041701](https://tva1.sinaimg.cn/large/00831rSTly1gcwr1xd96fj30a70373yi.jpg)\n\n* 处理器根据我们正在处理的除零错误找到异常号（0），进一步找到中断向量表索引IDT[0]。然后根据内容设置新的CS:EIP。\n* 异常处理程序接管控制流，然后进行异常处理。\n\n\n\n#### >> Nested Exception and Interrupts\n\n处理器既可以在用户模式下接受中断/异常，也可以在内核模式下。但是只有从用户模式进入内核的时候，x86处理器才会自动切换堆栈，然后将旧的寄存器状态压栈并且通过IDT调用适当的处理程序。如果发生中断/异常的时候处理器已经处于内核模式（CS寄存器的低2位为0），那么CPU会将更多的值压入同一内核堆栈（这时不再需要压入`SS`和`ESP`）。这样，内核可以优雅地处理由内核本身内的代码引起的嵌套异常。\n\n\n\n### A.6 Setting Up the IDT\n\n此时我们需要建立jos中能够处理异常和系统调用的IDT。到现在为止，我们需要设置IDT使内核能够处理异常号为0-31的异常（处理器异常）。\n\n头文件`inc/trap.h`和`kern/trap.h`包含了一些关于中断和异常的定义。`kern/trap.h`包含了一些内核严格私有的定义，而`inc/trap.h`中的定义对用户级程序和库有用。\n\n（注意：0-31异常号中有一些可能已经被intel所保留，这些异常号永远不会被处理器引发，所以实际上不必担心如何处理这些异常号）\n\n我们需要实现如下表所示的IDT。\n\n```\n      IDT                   trapentry.S         trap.c\n   \n+----------------+                        \n|   &handler1    |---------> handler1:          trap (struct Trapframe *tf)\n|                |             // do stuff      {\n|                |             call trap          // handle the exception/interrupt\n|                |             // ...           }\n+----------------+\n|   &handler2    |--------> handler2:\n|                |            // do stuff\n|                |            call trap\n|                |            // ...\n+----------------+\n       .\n       .\n       .\n+----------------+\n|   &handlerX    |--------> handlerX:\n|                |             // do stuff\n|                |             call trap\n|                |             // ...\n+----------------+\n```\n\n在`trapentry.S`文件中已经定义了每个中断和异常的处理程序，`trap_init()`函数应当使用这些处理程序的入口地址来初始化IDT。每一个处理程序都应该在栈上建立一个`struct Trapframe`用于保护现场，并且以这个结构的指针为参数调用在`trap.c`中的`trap()`。\n\n**Exercise 4**\n\n修改`trapentry.S`以及`trap.c`来实现上述功能。一些宏定义可能会帮助我们：\n\n* `inc/trap.c`中的`T_*`宏定义\n* `trapentry.S`中的`TRAPHANDLER`以及`TRAPHANDLER_NOEC`\n\n我们需要使用这些宏为`inc/trap.h`中定义的每一个trap增加入口点（entry point），每个异常处理函数都会跳转到`_alltraps`（在`TRAPHANDLER`中规定）。同时我们还需要修改`trap_init()`函数来初始化IDT使得其能够指向入口点（可以使用`inc/mmu.h`的`SETGATE`宏）。你的`_alltraps`需要完成如下工作：\n\n* 数据压栈，使得栈的结构看上去像`struct Trapframe`，在这里使用`pushal`\n* 将`GD_KD`加载到`%ds`和`%es`\n* `pushl %esp`作为`trap()`函数的参数\n* `call trap()`调用函数\n\n首先我们观察`trapentry.S`中的两个宏：\n\n```assembly\n/* TRAPHANDLER defines a globally-visible function for handling a trap.\n * It pushes a trap number onto the stack, then jumps to _alltraps.\n * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.\n *\n * You shouldn't call a TRAPHANDLER function from C, but you may\n * need to _declare_ one in C (for instance, to get a function pointer\n * during IDT setup).  You can declare the function with\n *   void NAME();\n * where NAME is the argument passed to TRAPHANDLER.\n */\n ; 注意：我们所有中断服务例程的函数的名称，都是通过这两个宏定义的\n \n#define TRAPHANDLER(name, num)\t\t\t\t\t\t\\\n\t.globl name;\t\t/* define global symbol for 'name' */\t\\\n\t.type name, @function;\t/* symbol type is function */\t\t\\\n\t.align 2;\t\t/* align function definition */\t\t\\\n\tname:\t\t\t/* function starts here */\t\t\\\n\tpushl $(num);\t\t\t\t\t\t\t\\\n\tjmp _alltraps\n\n/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.\n * It pushes a 0 in place of the error code, so the trap frame has the same\n * format in either case.\n */\n#define TRAPHANDLER_NOEC(name, num)\t\t\t\t\t\\\n\t.globl name;\t\t\t\t\t\t\t\\\n\t.type name, @function;\t\t\t\t\t\t\\\n\t.align 2;\t\t\t\t\t\t\t\\\n\tname:\t\t\t\t\t\t\t\t\\\n\tpushl $0;\t\t\t\t\t\t\t\\\n\tpushl $(num);\t\t\t\t\t\t\t\\\n\tjmp _alltraps\n```\n\n两个宏都接受参数`name`（**定义一个名称为name的全局处理函数**）和`num`（异常号）。但是`TRAPHANDLER_NOEC`在将num压入**内核栈**之前多压了一个`0`，其注释是用来代替`error code`？\n\n再次，我们需要重申中断处理时压入程序栈的流程：\n\n```c\nstruct Trapframe {\n\tstruct PushRegs tf_regs;\n\tuint16_t tf_es;\n\tuint16_t tf_padding1;\n\tuint16_t tf_ds;\n\tuint16_t tf_padding2;\n\tuint32_t tf_trapno;\n\t/* below here defined by x86 hardware */\n\tuint32_t tf_err;\n\tuintptr_t tf_eip;\n\tuint16_t tf_cs;\n\tuint16_t tf_padding3;\n\tuint32_t tf_eflags;\n\t/* below here only when crossing rings, such as from user to kernel */\n\tuintptr_t tf_esp;\n\tuint16_t tf_ss;\n\tuint16_t tf_padding4;\n} __attribute__((packed));\n\n\n+--------------------+ KSTACKTOP             \n| 0x00000 | old SS   |     \" - 4\n|      old ESP       |     \" - 8\n|     old EFLAGS     |     \" - 12  //直至下面箭头所指的-24，都是由处理器负责压栈\n| 0x00000 | old CS   |     \" - 16  //用户不需要处理（有些中断没有error code） \n|      old EIP       |     \" - 20  //对于没有error code的中断 需要用户手动填空\n|     error code     |     \" - 24 // <---- \n+--------------------+             \n|    trap number     |    //这部分在_alltrap()进行压栈\n| 0x00000 | old DS   | \n| 0x00000 | old ES   |\n|  old registers     |\n+--------------------+\n```\n\n所以对于有些不需要压入`error code`的异常，我们需要补齐而使得栈结构和`struct Trapframe`保持一致。\n\n[Error code summary](https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_10.htm)告诉我们哪些异常需要压入错误码。\n\n首先我们填充`trapentry.S`的`_alltrap()`压栈部分：\n\n```assembly\n/*\n * Lab 3: Your code here for _alltraps\n */\n_alltraps:\n\t;ds es\n\tpush %ds\n\tpush %es\n\tpushal   ;其余寄存器\n\n\t;load DS and ES with GD_KD (不能用立即数设置段寄存器)\n\tmov $GD_KD, %ax\n\tmov %ax, %ds\n\tmov %ax, %es\n\tpushl %esp\n\tcall trap\n```\n\n然后我们实现并初始化IDT，此时需要首先了解`SETGATE`宏：\n\n```c\n// Set up a normal interrupt/trap gate descriptor.\n// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.\n    //   see section 9.6.1.3 of the i386 reference: \"The difference between\n    //   an interrupt gate and a trap gate is in the effect on IF (the\n    //   interrupt-enable flag). An interrupt that vectors through an\n    //   interrupt gate resets IF, thereby preventing other interrupts from\n    //   interfering with the current interrupt handler. A subsequent IRET\n    //   instruction restores IF to the value in the EFLAGS image on the\n    //   stack. An interrupt through a trap gate does not change IF.\"\n// - sel: Code segment selector for interrupt/trap handler\n// - off: Offset in code segment for interrupt/trap handler\n// - dpl: Descriptor Privilege Level -\n//\t  the privilege level required for software to invoke\n//\t  this interrupt/trap gate explicitly using an int instruction.\n#define SETGATE(gate, istrap, sel, off, dpl)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t(gate).gd_off_15_0 = (uint32_t) (off) & 0xffff;\t\t\\\n\t(gate).gd_sel = (sel);\t\t\t\t\t\\\n\t(gate).gd_args = 0;\t\t\t\t\t\\\n\t(gate).gd_rsv1 = 0;\t\t\t\t\t\\\n\t(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;\t\\\n\t(gate).gd_s = 0;\t\t\t\t\t\\\n\t(gate).gd_dpl = (dpl);\t\t\t\t\t\\\n\t(gate).gd_p = 1;\t\t\t\t\t\\\n\t(gate).gd_off_31_16 = (uint32_t) (off) >> 16;\t\t\\\n}\n```\n\n* `gate`：异常在IDT中的描述符\n* `istrap`：用于区分异常和中断，异常则为1，中断为0\n* `sel`：处理异常函数的数据段\n  * `inc/memlayout.h`中有各种段选择符的详细说明（此处选择内核代码段`GD_KT`）\n* `off`：异常处理函数的入口偏移（可以使用对应的函数指针）\n* `dpl`：这个描述符的优先级（能够被什么特权级的程序显式调用）\n\n这里我们明白了，这个宏的作用就是设置中断描述符的函数入口地址，然后在`trap_init()`过程中初始化IDT，让其每个表项都指向`trapentry.S`中我们使用两个宏定义的相应函数入口点。\n\n所以我们接下来首先参照`inc/trap.h`中的所有异常号，在`trapentry.S`中定义相应的异常处理函数：\n\n```assembly\n/*\n * Lab 3: Your code here for generating entry points for the different traps.\n */\n\nTRAPHANDLER_NOEC(divide_handler, T_DIVIDE)\nTRAPHANDLER_NOEC(debug_handler, T_DEBUG)\nTRAPHANDLER_NOEC(nmi_handler, T_NMI)\nTRAPHANDLER_NOEC(brkpt_handler, T_BRKPT)\nTRAPHANDLER_NOEC(oflow_handler, T_OFLOW)\nTRAPHANDLER_NOEC(bound_handler, T_BOUND)\nTRAPHANDLER_NOEC(illop_handler, T_ILLOP)\nTRAPHANDLER_NOEC(device_handler, T_DEVICE)\nTRAPHANDLER_NOEC(dblflt_handler, T_DBLFLT)\nTRAPHANDLER(tss_handler, T_TSS)\nTRAPHANDLER(segnp_handler, T_SEGNP)\nTRAPHANDLER(stack_handler, T_STACK)\nTRAPHANDLER(gpflt_handler, T_GPFLT)\nTRAPHANDLER(pgflt_handler, T_PGFLT)\nTRAPHANDLER_NOEC(fperr_handler, T_FPERR)\nTRAPHANDLER_NOEC(align_handler, T_ALIGN)\nTRAPHANDLER_NOEC(mchk_handler, T_MCHK)\nTRAPHANDLER_NOEC(simderr_handler, T_SIMDERR)\nTRAPHANDLER_NOEC(syscall_handler, T_SYSCALL)\n```\n\n然后在`kern/trap.c`中实现`trap_init()`函数：\n\n```c\n//首先声明我们在trapentry.S中定义的函数\nvoid divide_handler();\nvoid debug_handler();\nvoid nmi_handler();\nvoid brkpt_handler();\nvoid oflow_handler();\nvoid bound_handler();\nvoid illop_handler();\nvoid device_handler();\nvoid dblflt_handler();\nvoid tss_handler();\nvoid segnp_handler();\nvoid stack_handler();\nvoid gpflt_handler();\nvoid pgflt_handler();\nvoid fperr_handler();\nvoid align_handler();\nvoid mchk_handler();\nvoid simderr_handler();\nvoid syscall_handler();\n\nvoid\ntrap_init(void)\n{\n\textern struct Segdesc gdt[];\n\n\t// LAB 3: Your code here.\n\tSETGATE(idt[0], 1, GD_KT, divide_handler, 0);\n\tSETGATE(idt[1], 1, GD_KT, debug_handler, 0);\n\tSETGATE(idt[2], 1, GD_KT, nmi_handler, 0);\n\tSETGATE(idt[3], 1, GD_KT, brkpt_handler, 3);\n\tSETGATE(idt[4], 1, GD_KT, oflow_handler, 0);\n\tSETGATE(idt[5], 1, GD_KT, bound_handler, 0);\n\tSETGATE(idt[6], 1, GD_KT, illop_handler, 0);\n\tSETGATE(idt[7], 1, GD_KT, device_handler, 0);\n\tSETGATE(idt[8], 1, GD_KT, dblflt_handler, 0);\n\tSETGATE(idt[10], 1, GD_KT, tss_handler, 0);\n\tSETGATE(idt[11], 1, GD_KT, segnp_handler, 0);\n\tSETGATE(idt[12], 1, GD_KT, stack_handler, 0);\n\tSETGATE(idt[13], 1, GD_KT, gpflt_handler, 0);\n\tSETGATE(idt[14], 1, GD_KT, pgflt_handler, 0);\n\tSETGATE(idt[16], 1, GD_KT, fperr_handler, 0);\n\tSETGATE(idt[17], 1, GD_KT, align_handler, 0);\n\tSETGATE(idt[18], 1, GD_KT, mchk_handler, 0);\n\tSETGATE(idt[19], 1, GD_KT, simderr_handler, 0);\n\tSETGATE(idt[48], 1, GD_KT, syscall_handler, 3);\n\t// Per-CPU setup\n\ttrap_init_percpu();\n}\n```\n\n至此我们就配置好了IDT和每个异常服务程序的定义。\n\n\n\n**Questions**\n\nQ：为什么对于每一个中断/异常，我们都需要使用一个单独的函数(handler function)，而不能让所有中断/异常都用一个函数处理？\n\nA：由于CPU对于不同的异常码，对应的栈处理时是否处理错误码`error_code`是不同的且用户不可见。所以我们不能使用一个函数。\n\nQ：是否有任何办法让`user/softint`程序行为正确？我们的评测系统期望能够产生一个`int $13`一般保护异常，但是在其汇编代码中生成的是`int $14`缺页异常信号，但是为什么我们的处理器依然会产生13号异常？假设内核允许这个指令能产生14号异常，那么会发生什么？\n\nA：虽然`softint`在汇编代码中强行生成了`int $14`异常号，但是我们可以查看缺页中断的`dpl`为0，即不可以在用户态显式触发。也就是说`softint`触发该异常是非法操作，此时内核的保护机制生成了一个一般保护异常（13号）来处理这个非法操作。\n\n而假如用户可以真正使内核产生14号缺页异常，那么操作系统会根据触发异常的指令去判断其访问的内存位置，但这个缺页中断并非访存指令引起（是由用户显式调用的） ，因而操作系统没办法处理这个异常。\n\n\n\n在我们完成了exercise 4之后进行评分`make grade`，应该有`Part A 30/30`。\n\n\n\n##  Part B: Page Faults, Breakpoints Exceptions, and System Calls\n\n此时kernel已经具有了基本的异常处理能力，我们将会继续对其进行优化，以提供依赖于异常处理的重要操作系统原语。\n\n\n\n### B.1 Handling Page Faults\n\n缺页异常是非常重要的，具有中断向量14。当缺页异常被触发的时候，处理器会将触发异常的线性地址存放在一个特殊的处理器控制寄存器`cr2`中。在`trap.c`中我们已经提供了`page_fault_handler()`来处理缺页错误。\n\n**exercise 5**\n\n修改`trap_dispatch()`使得其在发生缺页时能够调度`page_fault_handler()`函数来处理异常。实现之后我们能在`make grade`通过`faultread`, `faultreadkernel`, `faultwrite`, `faultwritekernel`且总评分为50。如果实现有问题，我们可以通过`make run-x`来运行一个具体用户程序进行调试（如`make run-hello`）。\n\n```c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n\t// Handle processor exceptions.\n\t// LAB 3: Your code here.\n\tif(tf -> tf_trapno == T_PGFLT){\n\t\tpage_fault_handler(tf);\n\t}\n\t// Unexpected trap: The user process or the kernel has a bug.\n\tprint_trapframe(tf);\n\tif (tf->tf_cs == GD_KT)\n\t\tpanic(\"unhandled trap in kernel\");\n\telse {\n\t\tenv_destroy(curenv);\n\t\treturn;\n\t}\n}\n```\n\n我们之后会实现缺页异常的具体处理逻辑。\n\n\n\n### B.2 The Breakpoint Exception\n\n断点异常（具有中断向量3）通常用于允许调试器在程序代码中插入断点，即在相关的代码位置暂时使用`int $3`来代替原本应该执行的指令。在jos中我们将会大量使用这个异常来实现一个原始的伪系统调用，使得用户环境可以使用它来调用jos内核监视器（如果我们将jos内核监视器视为原始调试器，这种做法是适当的）。比如说`lib/panic.c`中user mode下的`panic()`函数，实际上就是在显示了panic信息之后使用了`int $3`。\n\n**exercise 6**\n\n修改`trap_dispatch()`来实现内核监视器中的断点异常。\n\n```c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n\t// Handle processor exceptions.\n\t// LAB 3: Your code here.\n\tif(tf -> tf_trapno == T_PGFLT){\n\t\tpage_fault_handler(tf);\n\t}\n\tif(tf -> tf_trapno == T_BRKPT){\n\t\tmonitor(tf);\n\t}\n\t// Unexpected trap: The user process or the kernel has a bug.\n\tprint_trapframe(tf);\n\tif (tf->tf_cs == GD_KT)\n\t\tpanic(\"unhandled trap in kernel\");\n\telse {\n\t\tenv_destroy(curenv);\n\t\treturn;\n\t}\n}\n```\n\n此时我们可以通过`breakpoint`测试案例。\n\n\n\n**Questions**\n\nQ：根据你在part A中实现IDT的方式，断点测试情况下可能会生成断点异常（break point exception）或者一般保护异常（general protection fault），这是为什么？我们需要如何设置才能够使IDT触发断点异常？且何种错误的设置方式会触发一般保护异常？\n\nA：跟上一个练习的问题类似，解释是我们在`SETGATE`过程中设置`dpl`，决定了用户能否显式触发中断。测试文件是在用户环境下的，如果我们设置只有内核能够触发`int $3`断点异常，则用户测试时显然会触发一般保护异常。所以我们需要将`dpl`设置为3，使得用户能够显式触发异常。\n\nQ：你认为这些机制的意义是什么？`user/softint`测试程序做了什么？\n\nA：显然是为了使得用户环境和内核环境能够相互独立，用户环境仅能够在特定环境下（异常）能够执行某些内核代码进行处理，保证了恶意程序不会破坏内核，同时用户环境能够得到内核指令支持。`softint`通过内联汇编显式调用`int`指令。\n\n\n\n### B.3 System Calls\n\n用户进程通过系统调用来请求内核为其工作。当用户环境唤起系统调用时，处理器进入内核模式，处理器和内核协作来保存用户进程状态，内核执行适当的代码来完成系统调用，然后恢复至用户进程。对于用户环境如何唤起内核注意以及系统调用的具体实现是因系统而异的。\n\njos内核中我们使用`int $0x30`作为系统调用中断（中断向量48号），我们需要建立相关的种段描述符。注意到`0x30`中断向量是不可能通过硬件产生的，毫无疑问是由用户环境下的代码产生的。\n\n应用程序将会通过寄存器传递系统调用号以及相应的系统调用参数。这种方式下内核就不会访问用户环境栈或者指令流。系统调用号存放在`%eax`寄存器中，其余参数（最多五个）相应地存放在 `%edx`, `%ecx`, `%ebx`, `%edi`, `%esi`中。内核将返回值存放在寄存器`%eax`中。用于唤醒系统调用的汇编代码已经实现在`lib/syscall.c`中的`syscall()`。我们需要阅读这个函数以确保理解了如何唤醒系统调用。\n\n**exercise 7**\n\n为内核增加系统调用处理函数。我们需要修改`kern/trapentry.S`以及`kern/trap.c`中的`trap_init()`函数。我们还需要修改`trap_dispatch()`，使其能够以正确参数调用`syscall()`（这个是`kern/syscall.c`下的而非之前`lib`中的）并将返回结果存放在`%eax`中返回给用户（调用者）。\n\n我们还需要实现`kern/syscall.c`下的`syscall()`，使得调用号无效的时候返回`-E_INVAL`。通过系统调用函数处理`inc/syscall.h`中的所有系统调用。\n\n* `trap_dispatch()`\n\n```c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n\t// Handle processor exceptions.\n\t// LAB 3: Your code here.\n\tif(tf -> tf_trapno == T_PGFLT){\n\t\tpage_fault_handler(tf);\n\t}\n\tif(tf -> tf_trapno == T_BRKPT){\n\t\tmonitor(tf);\n\t}\n\tif(tf -> tf_trapno == T_SYSCALL){\n\t\tint32_t retval = syscall(tf->tf_regs.reg_eax,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_edx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_ecx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_ebx,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_edi,\n\t\t\t\t\t\t\t\t tf->tf_regs.reg_esi);\n\t\tif(retval < 0){\n\t\t\tpanic(\"[trap_dispatch] syscall : %e\\n\", retval);\n\t\t}\n\t\ttf->tf_regs.reg_eax = retval;\n\t\treturn;\n\t}\n\t// Unexpected trap: The user process or the kernel has a bug.\n\tprint_trapframe(tf);\n\tif (tf->tf_cs == GD_KT)\n\t\tpanic(\"unhandled trap in kernel\");\n\telse {\n\t\tenv_destroy(curenv);\n\t\treturn;\n\t}\n}\n```\n\n* `syscall()`\n\n```c\n// Dispatches to the correct kernel function, passing the arguments.\nint32_t\nsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)\n{\n\t// Call the function corresponding to the 'syscallno' parameter.\n\t// Return any appropriate return value.\n\t// LAB 3: Your code here.\n\tswitch (syscallno) {\n\tcase SYS_cputs:\n\t\tsys_cputs((const char *)a1, a2);\n\t\treturn 0;\n\tcase SYS_cgetc:\n\t\treturn sys_cgetc();\n\tcase SYS_getenvid:\n\t\treturn sys_getenvid();\n\tcase SYS_env_destroy:\n\t\treturn sys_env_destroy((envid_t)a1);\n\t\tbreak;\n\tdefault:\n\t\treturn -E_INVAL;\n\t}\n}\n```\n\n实现以后，我们可以通过` make run-hello`观察`hello`的输出。应该会首先答应\"hello world\"在控制台中，然后在用户模式下造成缺页错误：\n\n```\nhello, world\n env_tf :  f01f7000\n trap called\nIncoming TRAP frame at 0xefffffbc\n[00001000] user fault va 00000048 ip 00800048\nTRAP frame at 0xf01f7000\n  edi  0x00000000\n  esi  0x00000000\n  ebp  0xeebfdfd0\n  oesp 0xefffffdc\n  ebx  0x00000000\n  edx  0xeebfde88\n  ecx  0x0000000d\n  eax  0x00000000\n  es   0x----0023\n  ds   0x----0023\n  trap 0x0000000e Page Fault\n  cr2  0x00000048\n  err  0x00000004 [user, read, not-present]\n  eip  0x00800048\n  cs   0x----001b\n  flag 0x00000092\n  esp  0xeebfdfb8\n  ss   0x----0023\n[00001000] free env 00001000\nDestroyed the only environment - nothing more to do!\n```\n\n同时`make grade`应该可以通过`testbss`案例。\n\n\n\n### B.4 User-mode startup\n\n用户程序在`lib/entry.S`的顶部开始运行（所有的用户程序均是如此），经过一些设置之后，代码会调用`lib/libmain.c`中的`libmain()`。我们需要修改`libmain()`以初始化指向当前环境`struct Env`（在`envs[]`数组中）的全局指针`thisenv`（注意`lib/entry.S`已经定义了我们在part A中指向`UENVS`的映射`envs`）。\n\n> 提示：我们可以查看`inc/env.h`以及使用`sys_getenvid()`。\n\n随后`libmain`调用`umain`，对于`hello`程序而言，打印出\"hello world\"之后，其试图访问`thisenv->env_id`，这就是为什么hello程序会出现fault（我们还没有初始化`thisenv`）。\n\n**exercise 8**\n对用户库添加相应的代码然后重启内核，使得`hello`程序能够正常运行。\n\n实际上我们需要修改`libmain()`函数使其初始化`thisenv`，指向`envs`中代表当前用户环境的`Env`结构体。\n\n```c\nvoid\nlibmain(int argc, char **argv)\n{\n\t// set thisenv to point at our Env structure in envs[].\n\t// LAB 3: Your code here.\n\tthisenv = 0;\n\tthisenv = envs + ENVX(sys_getenvid());\n\t// save the name of the program so that panic() can use it\n\tif (argc > 0)\n\t\tbinaryname = argv[0];\n\n\t// call user main routine\n\tumain(argc, argv);\n\n\t// exit gracefully\n\texit();\n}\n```\n\n实现之后我们就可以通过`hello`测试案例了。\n\n\n\n### B.5 Page faults and memory protection\n\n内存保护是操作系统的一个重要功能，它能够确保一个有bug的程序不会破坏其他程序甚至操作系统内核。\n\n操作系统通常依赖硬件支持以实现内存保护。操作系统告知硬件哪些虚拟地址是有效的，哪些是无效的。当程序试图访问一个无效的虚拟地址或者一个无权限的虚拟地址时，处理器在引起错误的位置停止程序并且带着相应的错误信息陷入内核。如果这个错误是可修复的，内核修复该错误并且让程序继续运行；如果错误是不可修复的，则程序将无法继续运行。\n\n现在给出一个可修复错误的例子（**栈扩充机制**）：考虑一个可以自动拓展的堆栈。在许多系统中，内核最初分配一个**堆栈页面**，然后如果程序无法访问堆栈中更远的页面（esp指针减小到这一个页面的下限），内核将自动分配页面作为栈空间使得程序能够继续。这样内核仅分配程序需要的堆栈内存，使得用户程序可以认为其拥有任意大小的栈。\n\n考虑系统调用，很多系统调用允许用户程序向内核传递指针，内核在处理系统调用的时候将指针解引用并执行系统调用。这带来了如下两个问题：\n\n1. 内核的缺页错误潜在地比用户程序的缺页错误更加严重。如果内核在操作其私有数据结构的时候发生了缺页错误，那么内核产生bug，错误处理程序应该panic内核。但是当内核解引用由用户程序传递的指针时，**需要某种方式来标记由解引用导致的缺页实际上代表的是用户程序引发的**。\n2. 内核比用户程序具有更多的地址权限。在这种情况下用户程序可能会传递一个指针，这个指针指向的地址只能由内核读写而不能通过用户程序读写。在这种情况下内核不能对这个指针进行解引用（这样做显然会暴露内核的私有信息）。\n\n因此我们需要解决这两个问题，通过检查传递从用户空间传递到内核的指针是否应该被解引用。\n\n**exercise 9**\n\n1. 修改`kern/trap.c`，使得内核在内核代码触发缺页错误的时候panic。\n\n> 提示：为了确认引发异常的代码是用户代码还是内核代码，可以检查`tf_cs`的寄存器值的低位。\n\n2. 阅读`kern/pmap.c`中的`user_mem_assert`然后在相同的的文件中实现`user_mem_check`。\n\n3. 修改`kern/syscall.c`来仔细检查系统调用的参数。\n\n4. 修改`kern/kedebug.c`中的`debuginfo_eip`函数，使其在`usd`, `stabs`, `stabstr`调用`user_mem_check`。\n\n* 修改`kern/trap.c`中的`page_fault_handler()`\n\n```c\n\nvoid\npage_fault_handler(struct Trapframe *tf)\n{\n\tuint32_t fault_va;\n\n\t// Read processor's CR2 register to find the faulting address\n\tfault_va = rcr2();\n\n\t// Handle kernel-mode page faults.\n\n\t// LAB 3: Your code here.\n\tif((tf->tf_cs & 3) == 0){\n\t\tpanic(\"[page_fault_handler] Page fault in kernel.\\n\");\n\t}\n\t// We've already handled kernel-mode exceptions, so if we get here,\n\t// the page fault happened in user mode.\n\n\t// Destroy the environment that caused the fault.\n\tcprintf(\"[%08x] user fault va %08x ip %08x\\n\",\n\t\tcurenv->env_id, fault_va, tf->tf_eip);\n\tprint_trapframe(tf);\n\tenv_destroy(curenv);\n}\n\n```\n\n这样我们就可以通过段寄存器的权限位分辨缺页错误是内核导致的还是用户导致的。\n\n* `user_mem_check`\n\n仔细阅读注释，查看我们通过何种方式进行检查\n\n```c\n//\n// Check that an environment is allowed to access the range of memory\n// [va, va+len) with permissions 'perm | PTE_P'.\n// Normally 'perm' will contain PTE_U at least, but this is not required.\n// 'va' and 'len' need not be page-aligned; you must test every page that\n// contains any of that range.  You will test either 'len/PGSIZE',\n// 'len/PGSIZE + 1', or 'len/PGSIZE + 2' pages.\n//\n// A user program can access a virtual address if (1) the address is below\n// ULIM, and (2) the page table gives it permission.  These are exactly\n// the tests you should implement here.\n//\n// If there is an error, set the 'user_mem_check_addr' variable to the first\n// erroneous virtual address.\n//\n// Returns 0 if the user program can access this range of addresses,\n// and -E_FAULT otherwise.\n//\nint\nuser_mem_check(struct Env *env, const void *va, size_t len, int perm)\n{\n\t// LAB 3: Your code here.\n\t// ! (1) the address is below ULIM\n\tif((uintptr_t)va >= ULIM){\n\t\tuser_mem_check_addr = (uintptr_t)va;\n\t\treturn -E_FAULT;\n\t}\n\tuintptr_t start = (uintptr_t)ROUNDDOWN(va, PGSIZE);\n\tuintptr_t end = (uintptr_t)ROUNDUP(va+len, PGSIZE);\n\tfor(;start < end; start += PGSIZE){\n\t\t//get pte\n\t\tpte_t * pte = pgdir_walk(env->env_pgdir, (void *)start, 0);\n\t\tif((*pte & (perm | PTE_P)) != (perm | PTE_P)){\n\t\t\t// ! (2) the page table gives it permission\n\t\t\tif(start <= (uintptr_t)va){\n\t\t\t\tuser_mem_check_addr = (uintptr_t)va;\n\t\t\t}\n\t\t\telse if(start >= (uintptr_t)va + len){\n\t\t\t\tuser_mem_check_addr = (uintptr_t)va + len;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tuser_mem_check_addr = start;\n\t\t\t}\n\t\t\treturn -E_FAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n* 修改`kern/syscall.c`中的`sys_cputs`相关部分\n\n```c\n// Dispatches to the correct kernel function, passing the arguments.\nint32_t\nsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)\n{\n\t// Call the function corresponding to the 'syscallno' parameter.\n\t// Return any appropriate return value.\n\t// LAB 3: Your code here.\n\tswitch (syscallno) {\n\tcase SYS_cputs:\n\t\t//check memory before dereference\n\t\tuser_mem_assert(curenv, (void *)a1, (size_t)a2, PTE_U);\n\t\tsys_cputs((const char *)a1, a2);\n\t\treturn 0;\n\tcase SYS_cgetc:\n\t\treturn sys_cgetc();\n\tcase SYS_getenvid:\n\t\treturn sys_getenvid();\n\tcase SYS_env_destroy:\n\t\treturn sys_env_destroy((envid_t)a1);\n\t\tbreak;\n\tdefault:\n\t\treturn -E_INVAL;\n\t}\n}\n\n// Print a string to the system console.\n// The string is exactly 'len' characters long.\n// Destroys the environment on memory errors.\nstatic void\nsys_cputs(const char *s, size_t len)\n{\n\t// Check that the user has permission to read memory [s, s+len).\n\t// Destroy the environment if not.\n\n\t// LAB 3: Your code here.\n\tuser_mem_check(curenv, (void *)s, len, PTE_U);\n\t// Print the string supplied by the user.\n\tcprintf(\"%.*s\", len, s);\n}\n```\n\n* `debuginfo_eip()`\n\n```c\n// debuginfo_eip(addr, info)\n//\n//\tFill in the 'info' structure with information about the specified\n//\tinstruction address, 'addr'.  Returns 0 if information was found, and\n//\tnegative if not.  But even if it returns negative it has stored some\n//\tinformation into '*info'.\n//\nint\ndebuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)\n{\n\tconst struct Stab *stabs, *stab_end;\n\tconst char *stabstr, *stabstr_end;\n\tint lfile, rfile, lfun, rfun, lline, rline;\n\n\t// Initialize *info\n\tinfo->eip_file = \"<unknown>\";\n\tinfo->eip_line = 0;\n\tinfo->eip_fn_name = \"<unknown>\";\n\tinfo->eip_fn_namelen = 9;\n\tinfo->eip_fn_addr = addr;\n\tinfo->eip_fn_narg = 0;\n\n\t// Find the relevant set of stabs\n\tif (addr >= ULIM) {\n\t\tstabs = __STAB_BEGIN__;\n\t\tstab_end = __STAB_END__;\n\t\tstabstr = __STABSTR_BEGIN__;\n\t\tstabstr_end = __STABSTR_END__;\n\t} else {\n\t\t// The user-application linker script, user/user.ld,\n\t\t// puts information about the application's stabs (equivalent\n\t\t// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and\n\t\t// __STABSTR_END__) in a structure located at virtual address\n\t\t// USTABDATA.\n\t\tconst struct UserStabData *usd = (const struct UserStabData *) USTABDATA;\n\n\t\t// Make sure this memory is valid.\n\t\t// Return -1 if it is not.  Hint: Call user_mem_check.\n\t\t// LAB 3: Your code here.\n\t\tif(user_mem_check(curenv, usd, sizeof(struct UserStabData), PTE_U) < 0){\n\t\t\treturn -1;\n\t\t}\n\t\tstabs = usd->stabs;\n\t\tstab_end = usd->stab_end;\n\t\tstabstr = usd->stabstr;\n\t\tstabstr_end = usd->stabstr_end;\n\n\t\t// Make sure the STABS and string table memory is valid.\n\t\t// LAB 3: Your code here.\n\t\tif(user_mem_check(curenv, stabs, stab_end - stabs, PTE_U) < 0){\n\t\t\treturn -1;\n\t\t}\n\t\tif(user_mem_check(curenv, stabstr, stabstr_end - stabstr, PTE_U) < 0){\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t// String table validity checks\n\tif (stabstr_end <= stabstr || stabstr_end[-1] != 0)\n\t\treturn -1;\n\n\t// Now we find the right stabs that define the function containing\n\t// 'eip'.  First, we find the basic source file containing 'eip'.\n\t// Then, we look in that source file for the function.  Then we look\n\t// for the line number.\n\n\t// Search the entire set of stabs for the source file (type N_SO).\n\tlfile = 0;\n\trfile = (stab_end - stabs) - 1;\n\tstab_binsearch(stabs, &lfile, &rfile, N_SO, addr);\n\tif (lfile == 0)\n\t\treturn -1;\n\n\t// Search within that file's stabs for the function definition\n\t// (N_FUN).\n\tlfun = lfile;\n\trfun = rfile;\n\tstab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);\n\n\tif (lfun <= rfun) {\n\t\t// stabs[lfun] points to the function name\n\t\t// in the string table, but check bounds just in case.\n\t\tif (stabs[lfun].n_strx < stabstr_end - stabstr)\n\t\t\tinfo->eip_fn_name = stabstr + stabs[lfun].n_strx;\n\t\tinfo->eip_fn_addr = stabs[lfun].n_value;\n\t\taddr -= info->eip_fn_addr;\n\t\t// Search within the function definition for the line number.\n\t\tlline = lfun;\n\t\trline = rfun;\n\t} else {\n\t\t// Couldn't find function stab!  Maybe we're in an assembly\n\t\t// file.  Search the whole file for the line number.\n\t\tinfo->eip_fn_addr = addr;\n\t\tlline = lfile;\n\t\trline = rfile;\n\t}\n\t// Ignore stuff after the colon.\n\tinfo->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;\n\n\n\t// Search within [lline, rline] for the line number stab.\n\t// If found, set info->eip_line to the right line number.\n\t// If not found, return -1.\n\t//\n\t// Hint:\n\t//\tThere's a particular stabs type used for line numbers.\n\t//\tLook at the STABS documentation and <inc/stab.h> to find\n\t//\twhich one.\n\t// Your code here.\n\tstab_binsearch(stabs, &lline, &rline, N_SLINE, addr);\n\tif (lline <= rline)\n\t{\n\t\tinfo->eip_line = stabs[lline].n_desc;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n\n\t// Search backwards from the line number for the relevant filename\n\t// stab.\n\t// We can't just use the \"lfile\" stab because inlined functions\n\t// can interpolate code from a different file!\n\t// Such included source files use the N_SOL stab type.\n\twhile (lline >= lfile\n\t       && stabs[lline].n_type != N_SOL\n\t       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))\n\t\tlline--;\n\tif (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)\n\t\tinfo->eip_file = stabstr + stabs[lline].n_strx;\n\n\n\t// Set eip_fn_narg to the number of arguments taken by the function,\n\t// or 0 if there was no containing function.\n\tif (lfun < rfun)\n\t\tfor (lline = lfun + 1;\n\t\t     lline < rfun && stabs[lline].n_type == N_PSYM;\n\t\t     lline++)\n\t\t\tinfo->eip_fn_narg++;\n\n\treturn 0;\n}\n\n```\n\n完成后`make run-buggyhello`应该有如下输出：\n\n```\n[00001000] user_mem_check assertion failure for va 00000001\n[00001000] free env 00001000\nDestroyed the only environment - nothing more to do!\n```\n\n同时运行`backtrace`命令:\n\n```\nK> backtrace\nStack backtrace:\n  ebp effffea0  eip f01008a6  args 00000001 effffeb8 00000000 f01f7000 f01b5120\n      kern/monitor.c:137: monitor+317\n  ebp efffff10  eip f01030b5  args 00000000 efffff3c 00000000 f01f7000 f01f7000\n      kern/env.c:459: env_destroy+39\n  ebp efffff30  eip f0102a93  args f01f7000 00001000 00000001 00000004 f0103182\n      kern/pmap.c:619: user_mem_assert+71\n  ebp efffff50  eip f0103a93  args f01f7000 00000001 00000001 00000004 f011af98\n      kern/syscall.c:24: syscall+144\n  ebp efffff80  eip f0103943  args 00000000 00000001 00000001 00000000 00000000\n      kern/trap.c:197: trap+319\n  ebp efffffb0  eip f0103a03  args efffffbc 00000000 00000000 eebfdfb0 efffffdc\n      kern/syscall.c:68: syscall+0\ntrap called\nIncoming TRAP frame at 0xeffffe2c\nkernel panic at kern/trap.c:265: [page_fault_handler] Page fault in kernel.\n```\n\n为什么最终会发生页错误呢？我们发现我们访问了`0xeffffe2c`，观察`memlayout.h`我们得知在`USTACKTOP`上方从`0xeebfd000`开始有一块empty memory没有映射到任何物理爷。而`backtrace`最后访问这个虚拟地址就会发生一个无法处理的页错误。\n\n**exercise 10**\n\n运行`make run-evilhello`，我们的环境应该被销毁，但内核不应该发生panic，我们应该看到以下内容：\n\n```c++\n[00000000] new env 00001000\n env_tf :  f01f7000\n trap called\nIncoming TRAP frame at 0xefffffbc\n env_tf :  f01f7000\n trap called\nIncoming TRAP frame at 0xefffffbc\n[00001000] user_mem_check assertion failure for va f010000c\n[00001000] free env 00001000\nDestroyed the only environment - nothing more to do!\n```\n\n至此我们完成了实验内容。🎉\n\n```c\ndivzero: OK (1.6s)\nsoftint: OK (1.5s)\nbadsegment: OK (2.5s)\nPart A score: 30/30\n\nfaultread: OK (1.6s)\nfaultreadkernel: OK (2.4s)\nfaultwrite: OK (1.7s)\nfaultwritekernel: OK (2.1s)\nbreakpoint: OK (2.2s)\ntestbss: OK (2.0s)\nhello: OK (1.5s)\nbuggyhello: OK (2.3s)\n    (Old jos.out.buggyhello failure log removed)\nbuggyhello2: OK (1.8s)\n    (Old jos.out.buggyhello2 failure log removed)\nevilhello: OK (1.9s)\n    (Old jos.out.evilhello failure log removed)\nPart B score: 50/50\n\nScore: 80/80\n```\n\n","tags":["operating system","lab"],"categories":["operating system"]},{"title":"Process Memory Internals","url":"/2020/03/09/memfor-7/","content":"\n## 7 Process Memory Internals\n\nThis chapter analyzes the various application programming interfaces (APIs) used for allocating the different data types and examines how to enumerate process memory regions via memory forensics.\n\n\n\n### > What's in Process Memory?\n\nAs you know, each process has its owen private view of memory in this range(upper bounds of the range can be vary between of operating systems).\n\nWe simply represented the highest value as `MmHighestUserAddress`.\n\n> This is a symbol in the NT module that you can query with a debugger or inside Volatility’s `volshell` plugin.\n\n![image-20200309151913862](https://tva1.sinaimg.cn/large/00831rSTly1gcnpa1y6n7j30e10dgdgk.jpg)\n\nIt's important to know that **the positions of the ranges are not constant, especially on systems that levergae address spase layout randomization(ASLR)**.\n\n> the thread stacks can exist below or above the process executable, or the ranges containing mapped files can be interspersed throughout the entire process space, not gathered contiguously as the diagram above shows.\n\n* `Dynamic linked libraries (DLLs)`: This area represents **shared libraries (DLLs) that were loaded into the address space**, either intentionally by the process or forcefully through library injection.\n\n* `Environment variables`: This range of memory **stores the process’ environment variables, such as its executable paths, temporary directories, home folders**, and so on.\n\n* `Process Environment Block (PEB)`: An extremely useful structure that **tells you where to find several of the other items in this list**, including the DLLs, heaps, and environment variables. It also contains the process’ command line arguments, its current working directory, and its standard handles.\n\n* `Process heaps`: Where you can find a majority of the dynamic input that the process receives. \n\n  > For example, variable-length text that you type into e-mail or documents is often placed on the heap, as is data sent or received over network sockets.\n\n* `Thread stacks`: **Each thread has a dedicated range of process memory set aside for its runtime stack**. This is where you can find function arguments, return addresses (allowing you to reconstruct call history), and local variables.\n\n* `Mapped files and application data`: This item is left intentionally vague because the content really depends on the process. **Mapped files represent content from files on disk, which could be configuration data, documents, and so on**. **Application data is anything the process needs to perform its intended duties**.\n\n* `Executable`: The process executable contains **the primary body of code and read/ write variables for the application**. This data may be compressed or encrypted on disk, **but once loaded into memory, it unpacks, enabling you to dump plain-text code back to disk**.\n\n\n\n### Memory Allocation APIs\n\n![image-20200309152939761](https://tva1.sinaimg.cn/large/00831rSTly1gcnpkwg0pvj30ox0f9q5l.jpg)\n\n\n\nQUESTION❓\n\nThese two virtual allocation functions are also the only ones that allow the caller to reserve memory (that is, set it aside) before committing it. This allows applications to “save” a large region of virtually contiguous memory for later use, without tying up the underlying physical pages in the meantime.\n\nWHY？\n\n\n\n### > Enumerating Process Memory\n\n\n\n#### >> Process Page Tables\n\nWe can use `memmap` and `memdump` plugins to list and extract all pages accessible to a process.\n\n> In this case, accessible includes kernel mode addresses because even threads that start in user memory transition into kernel memory when system APIs are called.\n\n![image-20200309154721770](https://tva1.sinaimg.cn/large/00831rSTly1gcnq3brf4gj30fw0e0my0.jpg)\n\n```\n$ python vol.py -f memory.dmp --profile=Win7SP0x64 memmap –p 864\n```\n\n![image-20200309154752063](https://tva1.sinaimg.cn/large/00831rSTly1gcnq3ugu07j30mb0aidh4.jpg)\n\nand below:\n\n![image-20200309154806825](https://tva1.sinaimg.cn/large/00831rSTly1gcnq43wktzj30md08pwfp.jpg)\n\nAlthough the system’s default page size is 4KB (`0x1000` bytes hex), you can see a few pages of size `0x200000`, which is 2MB. These are Page Size Entry (PSE) pages.\n\n* `DumpFileOffset`: This value specifies the offset of the corresponding page in the file produced by the `memdump` plugin. \n\n  > Because process address spaces are sparse—holes or gaps exist between available pages—the output file is also sparse. For example, the data at virtual address `0xff4c1000` maps to physical offset `0x151b77000` (5.2GB), but your output file for this process will be nowhere near that large. Thus, the `DumpFileOffset` column tells you where to find the contents of `0xff4c1000` in your output file (`0x2a3000`). \n\n`memdump`:\n\n```\n$ python vol.py -f memory.dmp --profile=Win7SP1x64 memdump -p 864 -D OUTDIR\n$ ls -alh OUTDIR/864.dmp \n---------------------------------------------------------------------\n-rw-r--r-- 1 michael staff           434M Mar 14 14:51 864.dmp\n```\n\n![image-20200309160654094](https://tva1.sinaimg.cn/large/00831rSTly1gcnqnnldlhj30lo0frgov.jpg)\n\n\n\n### > Virtual Address Descriptors\n\nA process’ VAD tree describes the layout of its memory segments at a slightly higher level than the page tables. \n\n*The operating system, not the CPU, defines and maintains these data structures.*\n\n> VADs contain the names of memory-mapped files, the total number of pages in the region, the initial protection (read, write, execute), and several other flags that can tell you a lot about what type of data the regions contain.\n\nEach node in the tree **represents one range in process virtual memory**. A node that describes a memory range lower than its parent appears on the left, and a node that describes a higher range appears on the right：\n\n![image-20200309161110171](https://tva1.sinaimg.cn/large/00831rSTly1gcnqs3f7mtj30on0c43zo.jpg)\n\n\n\n#### >> VAD Structures\n\nFor each process, `_EPROCESS.VadRoot` points to the root of the VAD tree.\n\n> the type of the member has frequently changed, as have the names of the VAD nodes. The differences are shown in Table below. For example, on Windows XP and 2003 Server, VadRoot pointed to an` _MMVAD_SHORT`, `_MMVAD`, or `_MMVAD_LONG`.\n\n![image-20200309161744038](https://tva1.sinaimg.cn/large/00831rSTly1gcnqyx67iqj30ol08uwft.jpg)\n\n\n\n`_MM_AVL_TABLE`:\n\n![image-20200309164359492](https://tva1.sinaimg.cn/large/00831rSTly1gcnrq8u3rnj30nz08a0uc.jpg)\n\n* You can see the `_MM_AVL_TABLE` has a BalancedRoot member, which is an `_MMADDRESS_NODE`.\n* ***Each node* has a set of pointers to its child nodes and a `StartingVpn` and `EndingVpn`.** From these **virtual page numbers (VPNs)**, you can derive the addresses of the first and last pages in the target process’ virtual memory.\n* VPNs are page numbers, not addresses.(To get the address, you have to multiply the page number by the size of a page.)\n\n\n\n`_MMADDRESS_NODE(40 bytes)`:\n\nIt is an alias and it is really one of the `_MMVAD*`(short, regular, long)\n\n![image-20200309164742768](https://tva1.sinaimg.cn/large/00831rSTly1gcnru4bhuqj30nu059757.jpg)\n\n`_MMVAD_SHORT`:\n\n![image-20200309165155887](https://tva1.sinaimg.cn/large/00831rSTly1gcnryihkurj30o507r0u3.jpg)\n\n`_MMVAD`:\n\n![image-20200309165226422](https://tva1.sinaimg.cn/large/00831rSTly1gcnrz1cz78j30ny0cpgo8.jpg)\n\n`_MMVAD_LONG`:\n\n![image-20200309165303141](https://tva1.sinaimg.cn/large/00831rSTly1gcnrzoc1uzj30ne037jrn.jpg)\n\nand below:\n\n![image-20200309165317383](https://tva1.sinaimg.cn/large/00831rSTly1gcnrzx8k6ij30ny0aptav.jpg)\n\na short node does not have a `Subsection`, thus it cannot possibly store a mapped file. \n\nOn the other hand, shell code that gets injected into a process never needs to exist on disk. \n\nThus, it won’t be backed by a file. As a result, **if you’re hunting for code injection, you can probably ignore the regular and long nodes**.\n\n\n\n#### >> VAD Tags\n\nAfter reading the structures above, you may wonder how Volatility determines which of the three `_MMVAD*` structures is aliased by an `_MMADDRESS_NODE`.\n\nThe answer is `Tag` member.(The offset of this member is -`0xc`)\n\n> Indeed, this is a convenient hack allowed when defining structures with Volatility. Essentially what we’re doing is accessing the `PoolTag` member of the `_POOL_HEADER`, which exists in memory directly before the node.\n\nA mapping of VAD-Related Pool Tags to Strucrute type:\n\n![image-20200309171826693](https://tva1.sinaimg.cn/large/00831rSTly1gcnsq3c6zzj30of06ft94.jpg)\n\n**Memory regions that contain injected shell code won’t be backed by a file. Thus, you would be looking for nodes with a VadS or VadF tag.**\n\n\n\n#### >> VAD Flags\n\nEach node has one or more sets of flags that contain characteristics about the memory range.(These flags are located in embedded unions named u, u1, u2, u3, and so on).\n\nThis name is based on `unnamed-tag` because unions don't have associated types.\n\n![image-20200309174815086](https://tva1.sinaimg.cn/large/00831rSTly1gcntl3y1nrj30li0bitb9.jpg)\n\nBits 0 to 51 of the 8-byte value are for CommitCharge, and bits 56 to 61 are the Protection.\n\n\n\n#### >> CommitCharge\n\n`CommitCharge` specifies the number of pages committed in the region described by the VAD node.\n\nQUESTION:❓\n\nThe reason we care about this field is because historically when code injecting malware sets up the target process’ address space to receive the malicious code, it commits all pages up front—it doesn’t reserve them and then go back and commit them later (although it very well could). Thus, you can use these additional characteristics to help identify injected memory regions.\n\n\n\n#### >> Protection\n\nThis field indicates what type of access should be allowed to the memory region.\n\n* `PAGE_EXECUTE`: The memory can be executed, but not written. This protection cannot be used for mapped files.\n\n* `PAGE_EXECUTE_READ`: The memory can be executed or read, but not written.\n* `PAGE_EXECUTE_READWRITE`: The memory can be executed, read, or written. Injected code regions almost always have this protection.\n\n* `PAGE_EXECUTE_WRITECOPY`: Enables execute, read-only, or copy-on-write access to a mapped view of a file. It cannot be set by calling `VirtualAlloc` or `VirtualAllocEx`. DLLs almost always have this protection.\n\n* `PAGE_NOACCESS`: Disables all access to the memory. This protection cannot be used for mapped files. Applications can prevent accidental reads/writes to data by setting this protection.\n\n* `PAGE_READONLY`: The memory can be read, but not executed or written. \n* `PAGE_READWRITE`: The memory can be read or written, but not executed.\n* `PAGE_WRITECOPY`: Enables read-only or copy-on-write access to a mapped view of a file. It cannot be set by calling VirtualAlloc or VirtualAllocEx.\n\nNote:\n\nProtection field from the VAD `flags` is that it’s only the **initial protection** specified for all pages in the range when they were first reserved or committed. Thus, the current protection can be drastically different.\n\n\n\n#### >> Private Memory\n\nPrivate memory, in this context, refers to committed regions that **cannot typically be shared with or inherited by other processes**.\n\n* Mapped files, named shared memory, and copy-onwrite DLLs can be shared with other processes (although they may not be). **Thus, if the `PrivateMemory` bit is set for a memory region, it does not contain one of the aforementioned types of data**. \n* A process’ heaps, stacks, and ranges allocated with `VirtualAlloc` or `VirtualAllocEx` are usually marked as private.\n\n\n\n#### >> Volatility VAD Plugins\n\n* `vadinfo` : Displays the most verbose output, including the starting and ending addresses, the protection level, flags, and full paths to mapped files or DLLs. \n\n![image-20200310011133726](https://tva1.sinaimg.cn/large/00831rSTly1gco6eevfzsj30pb07a75c.jpg)\n\n* `vadtree`: In text mode, this plugin prints a tree-view of the nodes, so you can see the parent and child relationships on your console. \n\n* `vaddump` : **Extracts the range of process memory each VAD node describes to a separate file on disk**. Unlike memmap (discussed earlier), the output from this plugin is padded with zeros if any pages in the range are swapped to disk to maintain spatial integrity (offsets).","tags":["memory forensics","notes"],"categories":["memory forensics"]},{"title":"Processes, Handles, and Tokens","url":"/2020/03/08/memfor-6/","content":"\n## 6 Processes, Handles, and Tokens\n\nThis Chapter combines three of the most common initial steps in an investigation: determining what applications are running, what they're doing(in terms of access to files, registry keys, and so on), and what security context(or privilege level) they have obtained.\n\n\n\n###  > Processes\n\nThere are several of the basic resources that belong to a **process**:\n\n![image-20200308151829635](https://tva1.sinaimg.cn/large/00831rSTly1gcmjn074wej30mj0gstao.jpg)\n\n* `_EPROCESS`: the name of the structure that Windows uses to represent a process.\n\n  > all operating systems share the same concepts that are described in this high-level diagram.\n\n* each process has its own private memory space that's isolated from other processes.\n\nInside this memory space, you can find the process executable; its list of loaded modules (DLLs or shared libraries); and its stacks, heaps, and allocated memory regions containing everything from user input to application-specific data structures.\n\n* SIDs(security identifiers) and privilege data: a **Security Identifier** (commonly abbreviated **SID**) is a unique, immutable identifier of a user, user group, or other security principal.\n\n\n\n#### >> Data Structures\n\nWindows tracks processes by assigning them a unique `_EPROCESS` structure that resides in a **non-paged pool** of kernel memory.\n\n![image-20200308153340454](https://tva1.sinaimg.cn/large/00831rSTly1gcmk2sm8tjj30lj0prwjk.jpg)\n\nand below:\n\n![image-20200308153352023](https://tva1.sinaimg.cn/large/00831rSTly1gcmk2zufiwj30lq08u75q.jpg)\n\n* `Pcb`: The **kernel’s process control block** (`_KPROCESS`). This structure is found at the base of `_EPROCESS` and contains several critical fields, including the DirectoryTableBase for address translation and the amount of time the process has spent in kernel mode and user mode.\n\n* `CreateTime`: A UTC timestamp indicating when the process first started.\n\n* ` ExitTime`: A UTC timestamp indicating the time the process exited. **This value is zero for still-running processes**.\n\n* `UniqueProcessId`: An integer that uniquely identifies the process (also known as the **PID**).\n\n* `ActiveProcessLinks`: The **doubly linked list that chains together active processes on the machine**. Most APIs on a running system rely on walking this list. \n\n  > we can access all the process using `ActiveProcessLinks`\n\n* `SessionProcessLinks`: Another doubly linked list that chains together processes in the same session.\n\n* `InheritedFromUniqueProcessId `: An integer that specifies the **PID of the parent process**. After a process is running, this member is not modified, even if its parent terminates.\n\n* `Session`: This member points to the `_MM_SESSION_SPACE` structure (see Chapter 14) that **stores information on a user’s logon session and graphical user interface (GUI) objects.**\n\n* `ImageFileName`: **The filename portion of the process’ executable**. This field stores the first 16 ASCII characters, so longer filenames will appear truncated. To get the full path to the executable, or to see the Unicode name, you can access the corresponding VAD node or members in the PEB (see Chapter 7).\n\n* `ThreadListHead`: A doubly linked list that **chains together all the process’ threads** (each list element is an `_ETHREAD`).\n\n* `ActiveThreads`: **An integer indicating the number of active threads running in the process context**. Seeing a process with zero active threads is a good sign that the process has exited.\n\n* `Peb`: A pointer to the **Process Environment Block (PEB)**. Although this member (`_EPROCESS.Peb`) exists in kernel mode, it points to an address in user mode. **The PEB contains pointers to the process’ DLL lists, current working directory, command line arguments, environment variables, heaps, and standard handles**. \n\n* `VadRoot`: The **root node of the VAD tree**. It contains detailed information **about a process’ allocated memory segments, including the original access permissions** (read, write, execute) and whether a file is mapped into the region.\n\n\n\n#### >> Process Organization\n\nThe `_EPROCESS` structure contains a `_LIST_ENTRY` structure called `ActiveProcessLinks`.\n\n The `_LIST_ENTRY` structure contains two members:\n\n* Flink (forward link) that points to the `_LIST_ENTRY` of the next `_EPROCESS` structure\n* Blink (backward link) that points to the `_LIST_ENTRY` of the previous `_EPROCESS` structure.\n\n`_LIST_ENTRY` structures:\n\n![image-20200308154619201](https://tva1.sinaimg.cn/large/00831rSTly1gcmkfyh7iwj30nu0crdgn.jpg)\n\n\n\nReview:\n\nTo list processes, Volatility first locates the kernel debugger data block ( `_KDDEBUGGER_DATA64`). From there, it accesses the `PsActiveProcessHead` member, which points to the head of the doubly linked list of `_EPROCESS` structures. \n\nWe also discussed the pool-scanning approach in Chapter 5.\n\n> In this chapter, we present many other ways to find processes in a memory dump. It is important to implement alternative methods because the debugger data block, the linked-list pointers, and the pool tags are all nonessential to OS stability—which means they can be manipulated (accidentally or intentionally) to defeat forensic tools without disrupting the system or its processes.\n\n\n\n#### >> Critical System Processes\n\n> if you know what’s normal, you can detect what’s abnormal more quickly\n\nSo for now we’ll just focus on the theoretical concepts of how things should appear on clean systems.\n\n* `Idle` and `System`: These are not real processes (in the sense that they have no corresponding executable on disk). Idle is just a container that the kernel uses to charge CPU time for idle threads. Similarly, System serves as the default home for threads that run in kernel mode. Thus, the System process (PID 4) appears to own any sockets or handles to files that kernel modules open.\n* `csrss.exe`: **The client/server runtime subsystem plays a role in creating and deleting processes and threads**. It maintains a private list of the objects that you can use to cross-reference with other data sources. \n* `services.exe`: The Service Control Manager (SCM) in short, **it manages Windows services and maintains a list of such services in its private memory space.** This process should be the parent for any svchost.exe (service host) instances that you see, in addition to processes such as spoolsv.exe and SearchIndexer.exe that implement services. There should be only one copy of services.exe on a system, and it should be running from the system32 directory.\n* `svchost.ex`e: A clean system has multiple shared host processes running concurrently, each providing a container for DLLs that implement services. As previously mentioned, their parent should be services.exe, and the path to their executable should point to the system32 directory. In his blog, Patrick identifies a few of the common names (such as scvhost.exe and svch0st.exe) used by malware to blend in with these processes.\n* `lsass.exe`: The local security authority subsystem process is responsible for enforcing the security policy, verifying passwords, and creating access tokens. As such, it’s often the target of code injection because the plaintext password hashes can be found in its private memory space. There should be only one instance of lsass.exe running from the system32 directory, and its parent is winlogon.exe on pre-Vista machines, and wininit.exe on Vista and later systems. Stuxnet created two fake copies of lsass.exe, which caused them to stick out like a sore thumb.\n* `winlogon`.exe : This process presents the interactive logon prompt, initiates the screen saver when necessary, helps load user profiles, and responds to Secure Attention Sequence (SAS) keyboard operations such as CTRL+ALT+DEL. Also, this process monitors files and directories for changes on systems that implement Windows File Protection (WFP). As with most other critical processes, its executable is located in the system32 directory.\n* `explorer.exe`: You’ll see one Windows Explorer process for each logged-on user. It is responsible for handling a variety of user interactions such as GUI-based folder navigation, presenting the start menu, and so on. It also has access to sensitive material such as the documents you open and credentials you use to log in to FTP sites via Windows Explorer.\n* `smss.exe`: The session manager is the first real user-mode process that starts during the boot sequence. It is responsible for creating the sessions (see Chapter 14) that isolate OS services from the various users who may log on via the console or Remote Desktop Protocol (RDP).\n\n\n\n#### >> Analyzing Process Activity*\n\n* `pslist` **finds and walks the doubly linked list of processes and prints a summary of the data.** This method typically **cannot show you terminated or hidden processes**. \n* `pstree` takes the output from pslist and formats it in a tree view, so you can easily see parent and child relationships.\n* `psscan` **scans for ` _EPROCESS` objects instead of relying on the linked list**. This plugin **can also find terminated and unlinked (hidden) processes**.\n* `psxview` locates processes using alternate process listings, so you can then cross-reference different sources of information and reveal malicious discrepancies.\n\n\n\n#### >> Process Tree Visualizations\n\n```\npython vol.py psscan –f simple007.mem --profile=Win7SP1x64\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    --output=dot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    --output-file=processes.dot\n\n⚙ chuqiz@Narny-6 => ~/Downloads/graphviz-2.40.1 => dot -Tsvg -o ~/tree.svg ~/Desktop/processes.dot\n```\n\nTree likes below：\n\n![image-20200308170307920](https://tva1.sinaimg.cn/large/00831rSTly1gcmmnur1tmj31y60g0tbn.jpg)\n\n#### >> Detecting DKOM Attacks\n\nMany attacks are possible with Direct Kernel Object Manipulation (DKOM), but one of the most common is hiding a process by **unlinking its entry from the doubly linked list**. To accomplish this, overwrite the Flink and Blink pointers of surrounding objects so that they point around the `_EPROCESS` structure of the process to hide. Tools that execute on a running system and Volatility’s `pslist` command are susceptible to this attack, because they rely on the linked list. However, the `psscan` plugin uses the pool-scanning approach.\n\n\n\n**Process Cross-View Plugin**\n\nThe `psxview` plugin enumerates processes in seven different ways: the active process linked list and the six methods previously identified. Thus, it’s unlikely that a rootkit can successfully hide from `psxview`.\n\n![image-20200308163252517](https://tva1.sinaimg.cn/large/00831rSTly1gcmlsdh8aqj30y40k240f.jpg)\n\n\n\n### > Process Tokens\n\nA process’ token describes its security context. This context includes security identifiers (SIDs) of users or groups that the process is running as and the various privileges (specific tasks) that it is allowed to perform.\n\nWhen the kernel needs to decide whether a process can access an object or call a particular API, it consults data in the process’ token.\n\n\n\n#### >> Data Structures\n\nThe `_TOKEN` structure is large, so we won’t display all the members.\n\n![image-20200308164700337](https://tva1.sinaimg.cn/large/00831rSTly1gcmm72qyj8j30lm0judj3.jpg)\n\nand below:\n\n![image-20200308164716818](https://tva1.sinaimg.cn/large/00831rSTly1gcmm7czsqbj30n30pi42j.jpg)\n\n* `UserAndGroupCount`: This integer stores the size of the `UserAndGroups` array.\n\n* `UserAndGroups`: An array of `_SID_AND_ATTRIBUTES` structures associated with the token. Each element in the array describes a different user or group that the process is a member of. The `Sid` member of `_SID_AND_ATTRIBUTES` points to a `_SID` structure, which has `IdentifierAuthority` and `SubAuthority` members that you can combine to form the S-1-5-[snip] SID strings.\n\n* `PrivilegeCount` (Windows XP and 2003 only): This integer stores the size of the `Privileges` array.\n\n* `Privileges` (Windows XP and 2003): An array of `_LUID_AND_ATTRIBUTES` structures\n\n  that each describe a different privilege and its attributes (that is, present, enabled, enabled by default).\n\n* `Privileges` (Windows Vista and later): This is an instance of `_SEP_TOKEN_PRIVILEGES`, which has three parallel 64-bit values (Present, Enabled, EnabledByDefault). The bit positions correspond to particular privileges, and the values of the bit (on or off) describe the privilege’s status.\n\n\n\n#### >> Accessing Tokens\n\nOn a live machine, a process can access its own token through the `OpenProcessToken` API. To enumerate the SIDs or privileges, it can then use `GetTokenInformation` with the desired parameters. \n\nWith administrator access, it can also query (or set) the tokens of other users’ processes, including the system-critical ones. Of course, existing tools already provide this type of functionality for you, such as **Sysinternals Process Explorer**.\n\n![image-20200308171420415](https://tva1.sinaimg.cn/large/00831rSTly1gcmmziqholj30df0g7juz.jpg)\n\nThis instance of explorer.exe belongs to a user named Jimmy, whose SID string is `S-1-5-21-[snip]-1000`. By analyzing the other SIDs in this process’ token, you can see it’s also in the `Everyone`, `LOCAL`, and `NT AUTHORITY\\Authenticated Users` groups.\n\n\n\n#### >> Extracting and Translating SIDs in Memory\n\nthere are User SIDs such as S-1-5-21-4010035002-774237572-2085959976-1000. These SIDs break down into the following components:\n\n* S: Prefix indicating that the string is a SID \n* 1: The revision level (version of the SID specification) from `_SID.Revision` \n* 5: The identifier authority value from `_SID.IdentifierAuthority.Value` \n* 21-4010035002-774237572-2085959976: The local computer or domain identifier from the `_SID.SubAuthority` values \n* 1000: A relative identifier that represents any user or group that doesn’t exist by default\n\nYou can map the SID string to a username by querying the registry:\n\n```\npython vol.py -f memory.img --profile=Win7SP0x86 printkey -K \"Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\S-1-5-21-4010035002-774237572-2085959976-1000\"\n```\n\n![image-20200308173111605](https://tva1.sinaimg.cn/large/00831rSTly1gcmnh1ueklj30n80alta3.jpg)\n\n\n\n#### >> Detecting Lateral Movement\n\nIf you need to associate a process with a user account or investigate potential lateral movement attempts, use the getsids plugin.\n\n```\n$ python vol.py –f grrcon.img --profile=WinXPSP3x86 getsids –p 1096\n\nexplorer.exe: S-1-5-21-2682149276-1333600406-3352121115-500 (administrator) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-513 (Domain Users) explorer.exe: S-1-1-0 (Everyone) explorer.exe: S-1-5-32-545 (Users)\nexplorer.exe: S-1-5-32-544 (Administrators) explorer.exe: S-1-5-4 (Interactive) explorer.exe: S-1-5-11 (Authenticated Users) explorer.exe: S-1-5-5-0-206541 (Logon Session) \nexplorer.exe: S-1-2-0 (Local (Users with the ability to log in locally)) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-519 (Enterprise Admins) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-1115 \nexplorer.exe: S-1-5-21-2682149276-1333600406-3352121115-518 (Schema Admins) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-512 (Domain Admins)\n```\n\nThis command shows the SIDs associated with explorer.exe for the current logged-on user.\n\n\n\n### > Privileges\n\nPrivileges are another critical component involved in security and access control. A privilege is the permission to perform a specific task, such as debugging a process, shutting down the computer, changing the time zone, or loading a kernel driver.\n\nBefore a process can enable a privilege, the privilege must be present in the process’ token. Administrators decide which privileges are present by configuring them in the Local Security Policy (LSP),\n\nYou can access the LSP by going to Start ➪ Run and typing SecPol.msc:\n\n![image-20200308174427394](https://tva1.sinaimg.cn/large/00831rSTly1gcmnuuh2ldj30gi0iadg7.jpg)\n\n![image-20200308174509331](https://tva1.sinaimg.cn/large/00831rSTly1gcmnvkq70mj30q60gmjva.jpg)\n\nIn English:\n\n![image-20200308174533487](https://tva1.sinaimg.cn/large/00831rSTly1gcmnvzwow0j30k80ak0ye.jpg)\n\n\n\nFrom a forensic perspective, you should be most concerned with the following privileges when they’ve been explicitly enabled:\n\n* `SeBackupPrivilege`: This grants read **access to any file on the file system**, regardless of its specified access control list (ACL). Attackers can leverage this privilege to copy locked files.\n* `SeDebugPrivilege`: This **grants the ability to read from or write to another process’ private memory space**. It **allows malware to bypass the security boundaries that typically isolate processes**. Practically all malware that performs code injection from user mode relies on enabling this privilege.\n\n* `SeLoadDriverPrivilege`: This **grants the ability to load or unload kernel drivers**.\n* `SeChangeNotifyPrivilege`: This **allows the caller to register a callback function that gets executed when specific files and directories change.** Attackers can use this to determine immediately when one of their configuration or executable files are removed by antivirus or administrators.\n* `SeShutdownPrivilege`: This **allows the caller to reboot or shut down the system**. Some infections, such as those that modify the Master Boot Record (MBR) don’t activate until the next time the system boots. Thus, you’ll often see malware trying to manually speed up the procedure by invoking a reboot.\n\n\n\n#### >> Analyzing Explicit Privileges\n\nHere’s the output of the Volatility `privs` plugin. You’ll see the privilege name along with its attributes (present, enabled, and/or enabled by default):\n\n```\npython vol.py -f grrcon.img privs -p 1096\n```\n\n![image-20200308175020273](https://tva1.sinaimg.cn/large/00831rSTly1gcmo0z63yvj30mv07swg1.jpg)\n\nand below:\n\n![image-20200308175027708](https://tva1.sinaimg.cn/large/00831rSTly1gcmo13rnf6j30mm08qmza.jpg)\n\nYou can see several privileges present in the output. Only six of them are enabled, but three are enabled by default.\n\n\n\n### > Process Handles\n\nA handle is a reference to an open instance of a kernel object, such as a file, registry key, mutex, process, or thread.\n\n> By enumerating and analyzing the specific objects a process was accessing at the time of a memory capture, it is possible to arrive at a number of forensically relevant conclusions—such as what process was reading or writing a particular file, what process accessed one of the registry run keys, and which process mapped remote file systems.\n\n\n\n#### >> Lifetime of a Handle\n\nBefore a process can access an object, it first opens a handle to the object by calling an API such as `CreateFile`, `RegOpenKeyEx`, or `CreateMutex`. These APIs return a special Windows data type called `HANDLE`, which is simply an index into a process-specific handle table.\n\nFor example, when you call `CreateFile`,\n\n a pointer to the corresponding `_FILE_OBJECT` in kernel memory is placed in the first available slot in the calling process’ handle table, and the respective index (such as 0x40) is returned. Additionally, **the handle count for the object is incremented**. The calling process then passes the `HANDLE` value to functions that perform operations on the object, such as reading, writing, waiting, or deleting. Thus, APIs such as ReadFile and WriteFile work in the following manner:\n\n1. Find the base address of the calling process’ handle table.\n2. Seek to index 0x40.\n3. Retrieve the _FILE_OBJECT pointer.\n4. Carry out the requested operation.\n\nWhen a process is finished using an object, it should close the handle by calling the appropriate function (`CloseHandle`, `RegCloseHandle`, and so on). These APIs **decrement the object’s handle count** and **remove the pointer to the object from the process’ handle table**.\n\n\n\n**❓WHY USE HANDLE TABLE MODEL❓**\n\nThe handle table model was designed for both convenience and security.\n\n*  It’s convenient because [you don’t have to pass the full name or path of an objec]()t each time you perform an operation—only when you initially open or create the object. \n*  For security purposes, it also helps to **conceal the addresses of objects in kernel memory**. Because processes in user mode should never directly access kernel objects, there’s no reason why they would need the pointers. \n*  Furthermore, the model **provides a centralized way for the kernel to monitor access to kernel objects**, thus giving it the chance to enforce security based on SIDs and privileges.\n\n\n\n#### >> Reference Counts and Kernel Handles\n\nSo far in this section, we’ve been referring to processes as the entities that interact with objects **via handles**.\n\nHowever, kernel modules, or threads in kernel mode, can call the equivalent kernel APIs (i.e., `NtCreateFile`, `NtReadFile`, `NtCreateMutex`) in a similar manner. In this case, the handles are **allocated from the System (PID 4) process’ handle table.** \n\n> Thus, when you dump the handles of the System process, you’re **actually seeing all the currently open resources requested by kernel modules.**\n\n* Even if handles are closed, and references are released, there’s still a chance that you can find the objects by scanning the physical address space (as described in Chapter 5).\n\n* Of course, they wouldn’t be associated with a process’ handle table at that point, but their **presence in RAM can still lend clues to your investigations**. \n\n  > Likewise, after a process terminates, its handle table is destroyed, but that doesn’t mean all objects created by the process are destroyed at the same time.\n\n\n\n#### >> Handle Table Internals\n\nEach process’ `_EPROCESS.ObjectTable` member **points to a handle table** ( `_HANDLE_TABLE`). This structure has a `TableCode` that serves two critical purposes: \n\n* It **specifies the number of levels in the table.**\n* It **points to the base address of the first level.** \n\nAll processes start out with a single-level table, which is shown in Figure 6-12. The table size is one page (4096 bytes), and this scheme allows for up to 512 handles on a 32-bit system or 256 on a 64-bit system. Indexes in the table contain `_HANDLE_TABLE_ENTRY` structures if they’re in use; otherwise, they’re zeroed out.\n\n![image-20200308194859560](https://tva1.sinaimg.cn/large/00831rSTly1gcmrgfjz3cj30o20dsabx.jpg)\n\nAlso, there are two-level even three-level table.\n\n> You can image it as Page Directory and Page Table Entry and so on.\n\n\n\n#### >> Data Structures\n\n![image-20200308195404675](https://tva1.sinaimg.cn/large/00831rSTly1gcmrlq7r02j30m609bq4r.jpg)\n\nand below:\n\n![image-20200308195419291](https://tva1.sinaimg.cn/large/00831rSTly1gcmrlytjh8j30mc0bjjtm.jpg)\n\nSome key points for `_HANDLE_TABLE`:\n\n* `TableCode`: This value **tells you the number of levels in the table and points to the address of the top-level table**. The dual purpose is achieved using a bit mask of seven (7). For example, to obtain the number of tables, you can compute TableCode & 7; and to obtain the address, you can compute TableCode & ~7. \n* `QuotaProcess` : **A pointer to the process to which the handle table belongs**. It can come in handy if you find handle tables using the pool-scanning approach described in Chapter 5 rather than enumerating processes and following their ObjectTable pointer.\n* `HandleTableList`: **A linked list of process handle tables in kernel memory**. You can use it to locate other handle tables—potentially even those for processes that have been unlinked from the process list.\n* `HandleCount`: The **total number of handle table entries** that are currently in use by the process. This field was removed starting in Windows 8 and Server 2012.\n\nSome key points for `_HANDLE_TABLE_ENTRY`:\n\n* `Object`: This member points to the `_OBJECT_HEADER` of the corresponding object. The `_EX_FAST_REF` is a special data type that combines reference count information into the least significant bits of the pointer.\n\n* `GrantedAccess`: A bit mask that specifies the granted access rights (read, write, delete, synchronize, etc.) that the owning process has obtained for the object.\n\n\n\n### > Enumerating Handles in Memory*\n\nThe Volatility `handles` plugin generates output by walking the handle table data structures. There are a few filtering options:\n\n* Filter by process ID: You can pass one or more (comma-separated) process IDs to the `-p/--pid` option.\n\n* Filter by process offset: You can supply the physical offset of an `_EPROCESS` structure to the `-o/--offset` option.\n\n* Filter by object type: If you’re interested in only a particular type of object, such as files or registry keys, you can specify the appropriate name(s) to the `-t/--object-type` option. See Chapter 5 or enter `!object \\ObjectTypes` into Windbg to see the full list of object types.\n\n* Filter by name: Not all objects have names. Unnamed objects are obviously useless when searching for indicators by name, so one way to reduce noise is to use the `--silent` option, which suppresses handles to unnamed objects.\n\n\n\n```\npython vol.py -f zeus.vmem --profile=WinXPSP3x86 -p 632 handles\n```\n\n![image-20200308200304795](https://tva1.sinaimg.cn/large/00831rSTly1gcmrv336bfj30o2036gly.jpg)\n\nand below:\n\n![image-20200308200316769](https://tva1.sinaimg.cn/large/00831rSTly1gcmrvan7y9j30nw06iq44.jpg)\n\nAs shown in the next example, you can limit your search to files and mutexes opened by PID 632 and ignore unnamed objects:\n\n```\npython vol.py -f zeus.vmem --profile=WinXPSP3x86 -p 632 handles\n\t\t-t File,Mutant\n\t\t--silent\n```\n\n![image-20200308200423716](https://tva1.sinaimg.cn/large/00831rSTly1gcmrwge5e3j30o50df0vi.jpg)\n\nYou see the user.ds and local.ds files, which contain the configuration and stolen data. The sdra64.exe file in the system32 directory is the initial Zeus installer.\n\n> ou also may notice several open handles to `\\Device\\Tcp` and `\\Device\\Ip`. These are obviously different from the handles to files prefixed with `\\Device\\HarddiskVolume1`.\n>\n> Specifically, Tcp and Ip are not files on the machine’s hard drive. This is described in Chapter 11, but what you’re essentially seeing are artifacts of network sockets that the process creates. Although sockets aren’t files, they support similar operations such as opening, reading, writing, and deleting. As a result, the same handle/descriptor subsystem can service both files and network sockets.\n\n> Along the same lines, **named pipes are also represented as file objects**. Thus, if malware creates a named pipe for interprocess communication or to redirect output of a backdoor command shell into a file, you can determine which processes are involved in that activity, provided that you **know the name of the pipe it creates. In this case, it’s easy to identify because the name of the pipe that Zeus uses is the same as the standard mutex it creates to mark its presence on systems ( _AVIRA_)**.\n\n\n\n#### >> Detecting Registry Persistence\n\nMalware often leverages the registry for persistence. To write the pertinent values, the malicious process must first open a handle to the desired registry key.\n\n> you’ll see how obvious it is when malware chooses a well-known location (such as the Run key) and also suffers from a handle leak. You should not only recognize the registry key name but also the fact that you have numerous open handles to the same key.\n\n```\npython vol.py -f laqma.mem --profile=WinXPSP3x86 handles\n\t\t--object-type=Key\n\t\t--pid=1700\n```\n\n![image-20200308202015902](https://tva1.sinaimg.cn/large/00831rSTly1gcmsd08hraj30o60j3win.jpg)\n\n> The process has nearly 20 open handles to the RUN key (not all are shown). This is indicative of a bug in the code that fails to close its handles after opening them.\n\nOf course, the artifacts won’t always be this obvious, and just because a handle to a key is open, that doesn’t mean the process added values. \n\nHowever, you can always confirm your suspicions by using the `printkey` plugin (see Chapter 10) to look at the actual data that the key contains:\n\n```\npython vol.py -f laqma.mem printkey -K \"MICROSOFT\\WINDOWS\\CURRENTVERSION\\RUN\"\n```\n\n![image-20200308202735782](https://tva1.sinaimg.cn/large/00831rSTly1gcmsklhwp0j30nw0deac5.jpg)\n\nBased on their names, the final two entries seem suspicious—they cause `lanmanwrk.exe` and `KernelDrv.exe` to start automatically at each boot.\n\n\n\n#### >> Identifying Remote Mapped Drives\n\nMany adversaries rely on commands such as `net view` and `net use` to explore the surrounding network and map remote drives. \n\nObtaining read access to a company’s Server Message Block (SMB) file server or write access to various other workstations or servers in an enterprise can lead to successful lateral movement.\n\n* The following example shows **how an attacker navigates the network to mount two remote drives**. The Users directory of a system named WIN-464MMR8O7GF is mounted on P, and the C$ share of a system named LH-7J277PJ9J85I is mounted at Q:\n\n![image-20200308203556523](https://tva1.sinaimg.cn/large/00831rSTly1gcmsta2ujuj30m70ic0v9.jpg)\n\n\n\n* **The trick to finding evidence of remote mapped drives in memory** is to look for file handles prefixed with `\\Device\\Mup` and `\\Device\\LanmanRedirector`:\n\n  > MUP, which stands for Multiple Universal Naming Convention (UNC) Provider, is a kernel-mode component that channels requests to access remote files using UNC names to the appropriate network redirector. In this case, `LanmanRedirector` handles the SMB protocol.\n\n```\npython vol.py -f hop.mem --profile=VistaSP2x64 handles -t File | grep Mup\n```\n\n![image-20200308204050322](https://tva1.sinaimg.cn/large/00831rSTly1gcmsydpfuej30o10a9aby.jpg)\n\nYou have several plain handles to `\\Device\\Mup` (they are normal). The few in bold are the ones you should find interesting because they actually display the local drive letter, the remote NetBIOS name, and the share or file system path name. \n\n> There are also two different process IDs shown: 752 and 1544. In this case, 752 is the instance of svchost.exe that runs the LanmanWorkstation service; it creates and maintains client network connections to remote servers using the SMB protocol. PID 1544 is the cmd.exe shell, and it has a handle to `C$\\Users\\Jimmy\\Documents` as a result of the attacker changing into that directory.\n\n\n\n\n\n### ","tags":["memory forensics","notes"],"categories":["memory forensics"]},{"url":"/2020/03/07/memfor/","content":"\n# Memory Forensics\n\n## Basic Knowledge\n\n* PAE: physical adress extension\n* AS: Address spaces is an interface that provides flexible and consistent accsee to data in RAM.\n* `_KDDEBUGGER_DATA64`: characteristics of the kernel debugger data block .\n\n```c\ntypedef struct _DBGKD_DEBUG_DATA_HEADER64 { \n\t\tLIST_ENTRY64 List; \n\t\tULONG OwnerTag; \n\t\tULONG Size; \n}\n```\n\nWindows keeps a store of some useful global variables in a structure called **`_KDDEBUGGER_DATA64`**. This information is used by the microsoft kernel debugger in order to bootstap the analysis of a crash dump.\n\n## Volatility\n\n### selecting a profile\n\nIn some cases that you don't know the profile ahead of time, volatility includes two plugins that can help you determine the proper profile.(Windows only)\n\n1. `imageinfo`\n\ninstruction: `python vol.py -f [filename] imageinfo`\n\n![image-20200306172125272](https://tva1.sinaimg.cn/large/00831rSTly1gckby9o9q2j30ng0c23z7.jpg)\n\n> it also shows you the date and time when the memory sample was collected, the number of CPUS, some characteristics of the AS, such as whether PAE is enabled; and the directory table base (DTB) value used for address translation.\n\n2. kdbgscan\n\ninstruction: `python vol.py -f [filename] kdbgscan`\n\nThe name of the plugin gives you an idea of how the potential profiles are guessed: It finds and analyzes characteristics of the kernel debugger data block (_KDDEBUGGER_DATA64).\n\n![image-20200306173632863](https://tva1.sinaimg.cn/large/00831rSTly1gckcdzzmjhj30mc0j0myc.jpg)\n\n------\n\nNow, you may supply `--profile=WinXPSP3x86` when running other plugins.\n\n### shell\n\n`python vol.py -f memory.dmp --profile=XXXX volshell`\n\n## Memory Dump Formats\n\nThe volatility franeworks also provides several plugins, for exploring the metadara associated with many of the common file formats:\n\n![image-20200306195815213](https://tva1.sinaimg.cn/large/00831rSTly1gckghgcb5rj30q509q75x.jpg)\n\n\n\n### > Raw Memory Dump\n\n* The most widely supported format among analysis tools. \n* Does not contain any headers, metadata, or magic values for file type identification.\n* typically includes padding for any memory ranges that were intentionally skipped (i.e., device memory) or that could not be read by the acquisition tool, which helps maintain spatial integrity (relative offsets among data).\n\n### > Windows Crash Dump\n\nThis file format was designed for debugging purposes. It begins with a `_DMP_HEADER` structure. 》 \n\n> The header identifies the major and minor OS version, the kernel DTB(Directory  Table Base), the address of the active process and loaded kernel module list heads, and information on the physical memory runs.\n\n![image-20200306200642283](https://tva1.sinaimg.cn/large/00831rSTly1gckgq8q2mkj30o90d3goe.jpg)\n\n### > Windows Hibernation File\n\nA hibernation file (hiberfil.sys) contains a compressed copy of memory that the system dumps to disk during the hibernation process.\n\n> Hibernation files consist of a standard header (PO_MEMORY_IMAGE), a set of kernel contexts and registers such as CR3, and several arrays of compressed data blocks.\n\nAn example of the hibernation file header:\n\n![image-20200306202051606](https://tva1.sinaimg.cn/large/00831rSTly1gckh508ml5j30lg08mdh7.jpg)\n\n### > Virtual Machine Memory\n\nTo acquire memory from a VM, you can run one of the aforementioned software tools within the guest OS (VM) or you can perform the acquisition from the hypervisor. \n\n\n\n## 5 Windows Objects and Pool Allocations\n\n### > Windows Executive Objects\n\n\n\nWindows is written in C and makes heavy use of C structures to organize related data and attributes. Several of these structures are called executive objects because they are managed (created, protected, deleted, etc.) by the Windows Object Manager—a component of the kernel implemented by the NT module.\n\n> **All executive objects are structures**, but not all structures are executive objects.\n\nThe most forensically relevant executive **objects types** are described below:\n\n![image-20200306205927113](https://tva1.sinaimg.cn/large/00831rSTly1gcki94tb52j30mr0mbdji.jpg)\n\n![image-20200306205941411](https://tva1.sinaimg.cn/large/00831rSTly1gcki9dg2blj30mr0700ts.jpg)\n\n#### >> Object Headers\n\n* One of the common traits(特性) shared between all executive object types is the presence of an object header (` _OBJECT_HEADER`)\n* The **object header immediately precedes the executive object structure in memory**.\n\nFinding the structure (i.e.,`_FILE_OBJECT` in the figure) given the address of its `_OBJECT_HEADER`, or vice versa, is simple because the two are always directly adjacent; and the size of `_OBJECT_HEADER` is consistent per operating system.\n\n![image-20200306210659152](https://tva1.sinaimg.cn/large/00831rSTly1gckigz0i1sj30lr0ggjte.jpg)\n\n![image-20200306210737514](https://tva1.sinaimg.cn/large/00831rSTly1gckihmt5gnj30j40bhgmy.jpg)\n\n* `PointerCount`: Contains the **total number of pointers to the object**, including kernelmode references.\n* `HandleCount`: Contains the number of **open handles to the object**.\n* `TypeIndex`: This value tells you **what type of object you’re dealing with** (e.g., process, thread, file).\n* `InfoMask`: This value **tells you which of the optional headers**, if any, are present.\n* `SecurityDescriptor`: Stores information on the security restrictions for the object, such as which users can access it for reading, writing, deleting, and so on.\n* `Body`: This member is just a placeholder that represents the start of the structure contained within the object.\n\n#### >> Optional Headers\n\nAn object's optional headers contain various types of metadata that help describe the object.\n\n![image-20200306211042526](https://tva1.sinaimg.cn/large/00831rSTly1gckiktybbxj30n50a3tac.jpg)\n\n#### >> Object Type Objects\n\nFirstly, we take a look at `_OBJECT_HEADER` and find a member `TypeIndex`:\n\n```\n0x18     : TypeIndex               ['unsigned char']\n```\n\nThis member is an index into `nt!ObTypeIndexTable`.\n\n*  `nt!ObTypeIndexTable` is an array of type objects(`_OBJECT_TYPE`), which we have shown above at the begin of this chapter.\n\n> This data is critical to memory forensics because you can use it to determine the type of object that follows an _OBJECT_HEADER.\n\n**Data Structures:**\n\n![image-20200307170307117](https://tva1.sinaimg.cn/large/00831rSTly1gclh1j8t7nj30hx09d75y.jpg)\n\n* `Name`: This is a **Unicode string name of the object type** (Process, File, Key, etc.). \n* `TotalNumberOfObjects`: The total number of objects of this particular object type that exist on the system.\n\n* `TotalNumberOfHandles`: The total number of open handles to objects of this particular type.\n\n* `TypeInfo`: An _OBJECT_TYPE_INITIALIZER structure that tells you the **type of memory** used to allocate instances of these objects (for example, paged or nonpaged memory).\n* `Key`: A four-byte tag that is **used to uniquely mark memory allocations** that contain objects of this particular type.\n\n> The `TypeInfo` and `Key` members provide two clues that will prove to be invaluable to memory forensics—**they essentially tell you where to look (in paged or nonpaged memory) and what to look for** (a specific four-byte tag) to find all instances of a particular object type (for example, all processes or all files).\n\n**demo:**\n\n```powershell\npython vol.py –f memory.dmp --profile=Win7SP1x64 volshell \nVolatile Systems Volatility Framework 2.4 \nCurrent context: process System, pid=4, ppid=0 DTB=0x187000 \nTo get help, type 'hh()'\n\n>>> kernel_space = addrspace()\n>>> ObTypeIndexTable = 0xFFFFF80002870300\n>>> ptrs = obj.Object(\"Array\", \n... \t\t\t\t\t\t\t\t\ttargetType = \"Pointer\",\n... \t\t\t\t\t\t\t\t\toffset = ObTypeIndexTable,\n... \t\t\t\t\t\t\t\t\tcount = 100,\n...\t\t\t\t\t \t\t\t\t\tvm = kernel_space)\n\n>>> ptrs[0] \n<NoneObject pointer to [0x00000000]>\n>>> ptrs[1] \n<NoneObject pointer to [0xBAD0B0B0]>\n>>> for i, ptr in enumerate(ptrs):\n... \t\tobjtype = ptr.dereference_as(\"_OBJECT_TYPE\") \n... \t\tif objtype.is_valid():\n... \t\t\t\tprint i, str(objtype.Name), \"in\",\n... \t\t\t\t\tstr(objtype.TypeInfo.PoolType),\n... \t\t\t\t\t\"with key\", \n...\t\t\t\t\t\tstr(objtype.Key)\n...\n\n2 Type in NonPagedPool with key ObjT \n3 Directory in PagedPool with key Dire \n4 SymbolicLink in PagedPool with key Symb \n5 Token in PagedPool with key Toke \n6 Job in NonPagedPool with key Job \n7 Process in NonPagedPool with key Proc \n8 Thread in NonPagedPool with key Thre \n9 UserApcReserve in NonPagedPool with key User \n10 IoCompletionReserve in NonPagedPool with key IoCo \n11 DebugObject in NonPagedPool with key Debu \n12 Event in NonPagedPool with key Even\n```\n\nNote: We treated the data at kernel address 0xFFFFF80002870300 as an array of pointers to `_OBJECT_TYPE` structures.\n\n* To get the address of 0xFFFFF80002870300 for the previous example, we typed\n\n  `x nt!ObTypeIndexTable` into `Windbg`.\n\n* If don't have Windbg, you can generate similar results by this: `python vol.py -f win7x64cmd.dd --profile=Win7SP0x64 objtypescan`\n\n\n\n### > Kernel Pool Allocations\n\nA kernel pool is **a range of memory that can be divided up into smaller blocks for storing any type of data that a kernel-mode component** (the NT module, third-party device driver, etc.) requests.\n\n* Similar to a heap, **each allocated block has a header** (` _POOL_HEADER`) that contains accounting and debugging information.\n\n![image-20200307174538675](https://tva1.sinaimg.cn/large/00831rSTly1gcli9rw2c5j30iw0e8dho.jpg)\n\n**Data Structures of Pool Header:**\n\n![image-20200307175557004](https://tva1.sinaimg.cn/large/00831rSTly1gcliki40ydj30kw09tq4o.jpg)\n\n* `BlockSize`: The **total size of the allocation**, including the pool header, object header, and any optional headers.\n\n* `PoolType`: The **type of system memory** (paged, nonpaged, etc.) for which this pool header describes.\n\n* `PoolTag`: A four-byte value, typically composed of ASCII characters that should uniquely identify the code path taken to produce the allocation (so troublesome blocks can be traced back to their source). \n\n\n\n#### >> Allocation APIs\n\n```c\nPVOID ExAllocatePoolWithTag( \n\t_In_ POOL_TYPE PoolType,\n\t_In_ SIZE_T NumberOfBytes, \n\t_In_ ULONG Tag\n);\n```\n\n* The `PoolType` argument specifies the type of system memory to use for the allocation. `NonPagedPool (0)` and `PagedPool (1)` are the enumeration values for nonpageable and pageable memory, respectively. (As previously shown, most, but not all, executive object types are allocated using nonpageable memory)\n\n* The `NumberOfBytes` argument contains the number of bytes to allocate. Drivers that call `ExAllocatePoolWithTag()` directly can set this to the size of data they need to store in the memory block. \n\n  > Executive objects are different, as you have already learned, because they require extra space to store the object headers and optional headers. A function in the kernel named `ObCreateObject` is the central point from which all executive objects are created. It determines the size of the requested structure (i.e., 1232 bytes for an `_EPROCESS` on 64-bit Windows 7) and adds the size of `_OBJECT_HEADER` and any optional headers that need to be present before calling `ExAllocatePoolWithTag()`.\n\n* The `Tag` argument specifies a four-byte value, typically composed of ASCII characters that should uniquely identify the code path taken to produce the allocation (so troublesome blocks can be traced back to their source).\n\n**The steps of Allocation using Windows API:**\n\n1. The process calls `CreateFileA `(ASCII) or `CreateFileW` (Unicode)—both are exported by `kernel32.dll`.\n2. The create file APIs lead into `ntdll.dll`, which subsequently calls into the kernel and reaches the native `NtCreateFile` function.\n3. `NtCreateFile` will call `ObCreateObject` to request a new File object type.\n4. `ObCreateObject` calculates the size of `_FILE_OBJECT` , including the extra space needed for its optional headers.\n5. `ObCreateObject` finds the `_OBJECT_TYPE` structure for File objects and determines whether to allocate paged or nonpaged memory, as well as the four-byte tag to use.\n6. `ExAllocatePoolWithTag` is called with the appropriate size, memory type, and tag.\n\nAfter the steps, a new `_FILE_OBJECT` exists in memory.\n\nA pointer to the object header is added to the **calling process’ handle table**, **a system-wide pool** tag tracking database is updated accordingly, and the individual members of the `_FILE_OBJECT` are initialized with the path to the file being created and the requested access permissions (e.g., read, write, delete).\n\n\n\n#### >> De-allocation and Reuse\n\n*When blocks of pool memory are released, they are simply marked as free, not immediately overwritten.*\n\nThe single most important factor is how soon the process indicates (by calling `CloseHandle`) that it is finished reading or writing the new file.\n\n* At this time, if no other processes are using the file object, the block of memory will be released back to the pool’s “**free list**,” where it **can be reallocated** for a different purpose.\n\n  > While waiting to be reallocated, or at any time before new data is written to the memory block, much of the original `_FILE_OBJECT` will remain intact.\n\n\n\n### > Pool-Tag Scanning\n\nPool-tag scanning, or simply pool scanning, refers to finding allocations based on the aforementioned four-byte tags.\n\nPool scanning, involves **searching the entire memory dump file for Proc (the four-byte tag associated with `_EPROCESS`)**. The advantage to the latter method is that you can find historical entries (processes that are no longer running) as well as defeat some rootkit hiding techniques.\n\nNotes: Four-byte tag is only the start. For scanning a certain process, we also need additional information.\n\n> Volatility builds a more robust “signature” of what memory around the desired allocations looks like, and it’s based on the information described earlier in the chapter. \n>\n> For example, **the size of the allocation** and **type of memory** (paged, nonpaged) play a large role in eliminating false positives. If you’re looking for a 100-byte `_EPROCESS` and find `Proc` inside a 30-byte allocation, it cannot possibly be a real process because the memory block is too small.\n\n\n\n#### >> Pool Tag Sources\n\nThe initial criteria thar Volatility uses to find the listed executive objects via pool scanning:\n\n![image-20200307192732037](https://tva1.sinaimg.cn/large/00831rSTly1gcll7splzej30or0bgwgc.jpg)\n\nAlso, notice the Tag(Protected) column in Table above. \n\nOne of the most infrequently documented intricacies **regarding pool tags is the protected bit**. When you free a pool with `ExFreePoolWithTag`, you must supply the same tag supplied to `ExAllocatePoolWithTag`.\n\n> This is a technique the operating system uses to prevent drivers from freeing memory by accident. If the tag passed to the free function doesn’t match, the system will raise an exception.\n\n\n\n#### >> Pooltag file\n\nAs previously mentioned, Microsoft created pool tags for debugging and auditing purposes. Thus, some installations of the Windows Driver Development Kit (DDK) and Debugging Tools for Windows include a `pooltag.txt` file that you can use to perform lookups. \n\n\n\n#### >> PoolMon Utility\n\nA memory pool monitor. It reports live updates about the pool tags that are in use on a system:\n\n* The memory type (Paged or Nonpaged)\n\n* Number of allocations \n\n* Number of frees \n\n* Total number of bytes occupied by allocations\n\n* Average bytes per allocation\n\n```\nC:\\WinDDK\\7600.16385.1\\tools\\Other\\i386> poolmon.exe -b\n```\n\n![image-20200307194403599](https://tva1.sinaimg.cn/large/00831rSTly1gcllozni70j30pv06ajso.jpg)\n\n\n\n**PoolMon is intended to provide real-time updates of changes in pool tag usage**, it must be run on a live system. **But what if you only have a memory dump?** \n\nLuckily, memory actually contains the statistics that PoolMon reads. They are accessible from the same kernel debugger data block (` _KDDEBUGGER_DATA64`) that stores the active process and loaded module lists.\n\n\n\n#### >> Pool Tracker Tables\n\nThe PoolTrackTable member points to an array of `_POOL_TRACKER_TABLE` structures—**one for each unique pool tag in use**.\n\n![image-20200307194840141](https://tva1.sinaimg.cn/large/00831rSTly1gclltsk52aj30mf076ab7.jpg)\n\nAs you can see, each tracker table has a Key, which is the four-byte tag. The remaining members tell you how many allocations, frees, and total bytes are consumed for both nonpaged and paged memory.\n\n**Although the information isn’t updated in real time** (which makes sense because the system isn’t running anymore), you can at least **determine its state at the time when the memory dump was acquired**.\n\n```python\npython vol.py -f win7x64.dd pooltracker\n\t\t\t\t\t\t\t\t  --profile=Win7SP0x64\n\t\t\t\t\t\t\t\t\t--tags=Proc,File,Driv,Thre\n```\n\nThe column names start with “**Np**” for nonpaged or “**Pg**” for paged:\n\n![image-20200307195317976](https://tva1.sinaimg.cn/large/00831rSTly1gcllylo7cuj30kb05yt9d.jpg)\n\n#### >> Pool Scanner Algorighm\n\n![image-20200307203454870](https://tva1.sinaimg.cn/large/00831rSTly1gcln5xu1unj30ev0jxq4u.jpg)\n\nIf you scan using a physical address space, the code starts looking for the four-byte pool tag at offset 0 of the memory dump file and continues until it reaches the end of the file. Otherwise, if a virtual address space is selected, it enumerates and scans all pages in the kernel’s page table.\n\n#### >> Finding Terminated Processes\n\n```python\npython vol.py -f win7x64.dd --profile=Win7SP0x64 psscan\n```\n\n![image-20200307204659972](https://tva1.sinaimg.cn/large/00831rSTly1gclnih5cwcj30oa0fegok.jpg)\n\n\n\n#### >> Limitations of Pool Scanning\n\n**Non-malicious Limitations**\n\n* **Untagged pool memory**: `ExAllocatePoolWithTag` is Microsoft’s recommended way for drivers and kernel-mode components to allocate memory, but it’s not the only option. A driver can also use `ExAllocatePool`, which is in the process of being deprecated, but is still available on many versions of Windows. **This API allocates memory, but without a tag**—leaving you no easy way to track or scan for the allocations.\n\n* **False positives**: Because the pool-scanning technique is essentially based on pattern matching and heuristics, **false positives are a possibility**. This is especially true when scanning the physical address space because it includes data that the operating system discarded. To resolve false positives, you typically need to consider the context of the object (where it was found), if the member values make sense (this can vary per object), and if you found the object by other means such as alternate lists.\n* **Large allocations**: The **pool tag scanning technique does not work for allocations larger than 4096 bytes** (see the upcoming section, “Big Page Pool”). Fortunately, all executive objects are less than this size.\n\n\n\n**Malicious Limitations (Anti-Forensics)**\n\n* **Arbitrary tags**: A driver can allocate memory **using a generic, or default, tag** such as \"Ddk\" (the last character is a space). This tag is used throughout the operating system and also third-party code when a tag is not specified. **In other words, if malicious drivers use \"Ddk\" as their tag, the memory block will blend in with other allocations.**\n\n* **Decoy tags**: As stated by Walters and Petroni (https://www.blackhat.com/presentations/bh-dc-07/Walters/Paper/bh-dc-07-Walters-WP.pdf) a driver **can create fake (or decoy) objects that appear “life-like” to mislead investigators**, effectively increasing the signal-to-noise ratio.\n\n* **Manipulated tags**: Because tags are intended for debugging purposes, they aren’t critical for the stability of the operating system. **Rootkits running in the kernel can modify pool tags** (or any other value in the` _POOL_HEADER`, such as the block size and memory type) without any noticeable difference on the live machine, but the manipulation prevents Volatility’s pool scanner from working properly.\n\n\n\n### > Big Page Pool\n\nWindows kernel will try to group similarly sized allocations together. However, if the requested size exceeds one page (4096 bytes), the block of memory is allocated from a special pool (the big page pool) that is reserved for large allocations.\n\n> In this case, the `_POOL_HEADER`, which contains the four-byte tag and exists at the base address for smaller allocations, is not used at all.\n\n![image-20200307205528268](https://tva1.sinaimg.cn/large/00831rSTly1gclnrammqkj30ny0g9wfq.jpg)\n\n\n\n### > Big Page Track Tables\n\n* The pool track tables ( `_POOL_TRACKER_TABLE`) for small memory blocks store statistics regarding the number of allocations and byte usage; but they don’t tell you the addresses of all the allocations (thus the need to scan). \n\n* Big page track tables, on the other hand, don’t store statistics, but they include the addresses of the allocations.\n\nthe kernel symbol `nt!PoolBigPageTable`, which points to the array of `_POOL_TRACKER_BIG_PAGES` structures, (one for each large allocation), **is neither exported nor copied to the kernel debugger data block**.\n\n However, **this symbol can always be found at a predictable location relative to `nt!PoolTrackTable` (which is copied to the debugger data block).** Thus, if you can find the pool track tables, you can find the big page track tables easily.\n\n![image-20200307205919311](https://tva1.sinaimg.cn/large/00831rSTly1gclnvay4ejj30k504pq3l.jpg)\n\n#### >> Exploring Big Page Pools\n\n```\npython vol.py -f win7x64cmd.dd --profile=Win7SP0x64 bigpools > bigpools.txt\n```\n\n\n\n## 6 Processes, Handles, and Tokens\n\nThis Chapter combines three of the most common initial steps in an investigation: determining what applications are running, what they're doing(in terms of access to files, registry keys, and so on), and what security context(or privilege level) they have obtained.\n\n\n\n###  > Processes\n\nThere are several of the basic resources that belong to a **process**:\n\n![image-20200308151829635](https://tva1.sinaimg.cn/large/00831rSTly1gcmjn074wej30mj0gstao.jpg)\n\n* `_EPROCESS`: the name of the structure that Windows uses to represent a process.\n\n  > all operating systems share the same concepts that are described in this high-level diagram.\n\n* each process has its own private memory space that's isolated from other processes.\n\nInside this memory space, you can find the process executable; its list of loaded modules (DLLs or shared libraries); and its stacks, heaps, and allocated memory regions containing everything from user input to application-specific data structures.\n\n* SIDs(security identifiers) and privilege data: a **Security Identifier** (commonly abbreviated **SID**) is a unique, immutable identifier of a user, user group, or other security principal.\n\n\n\n#### >> Data Structures\n\nWindows tracks processes by assigning them a unique `_EPROCESS` structure that resides in a **non-paged pool** of kernel memory.\n\n![image-20200308153340454](https://tva1.sinaimg.cn/large/00831rSTly1gcmk2sm8tjj30lj0prwjk.jpg)\n\nand below:\n\n![image-20200308153352023](https://tva1.sinaimg.cn/large/00831rSTly1gcmk2zufiwj30lq08u75q.jpg)\n\n* `Pcb`: The **kernel’s process control block** (`_KPROCESS`). This structure is found at the base of `_EPROCESS` and contains several critical fields, including the DirectoryTableBase for address translation and the amount of time the process has spent in kernel mode and user mode.\n\n* `CreateTime`: A UTC timestamp indicating when the process first started.\n* ` ExitTime`: A UTC timestamp indicating the time the process exited. **This value is zero for still-running processes**.\n\n* `UniqueProcessId`: An integer that uniquely identifies the process (also known as the **PID**).\n\n* `ActiveProcessLinks`: The **doubly linked list that chains together active processes on the machine**. Most APIs on a running system rely on walking this list. \n\n  > we can access all the process using `ActiveProcessLinks`\n\n* `SessionProcessLinks`: Another doubly linked list that chains together processes in the same session.\n\n* `InheritedFromUniqueProcessId `: An integer that specifies the **PID of the parent process**. After a process is running, this member is not modified, even if its parent terminates.\n\n* `Session`: This member points to the `_MM_SESSION_SPACE` structure (see Chapter 14) that **stores information on a user’s logon session and graphical user interface (GUI) objects.**\n\n* `ImageFileName`: **The filename portion of the process’ executable**. This field stores the first 16 ASCII characters, so longer filenames will appear truncated. To get the full path to the executable, or to see the Unicode name, you can access the corresponding VAD node or members in the PEB (see Chapter 7).\n\n* `ThreadListHead`: A doubly linked list that **chains together all the process’ threads** (each list element is an `_ETHREAD`).\n\n* `ActiveThreads`: **An integer indicating the number of active threads running in the process context**. Seeing a process with zero active threads is a good sign that the process has exited.\n\n* `Peb`: A pointer to the **Process Environment Block (PEB)**. Although this member (`_EPROCESS.Peb`) exists in kernel mode, it points to an address in user mode. **The PEB contains pointers to the process’ DLL lists, current working directory, command line arguments, environment variables, heaps, and standard handles**. \n* `VadRoot`: The **root node of the VAD tree**. It contains detailed information **about a process’ allocated memory segments, including the original access permissions** (read, write, execute) and whether a file is mapped into the region.\n\n\n\n#### >> Process Organization\n\nThe `_EPROCESS` structure contains a `_LIST_ENTRY` structure called `ActiveProcessLinks`.\n\n The `_LIST_ENTRY` structure contains two members:\n\n* Flink (forward link) that points to the `_LIST_ENTRY` of the next `_EPROCESS` structure\n* Blink (backward link) that points to the `_LIST_ENTRY` of the previous `_EPROCESS` structure.\n\n`_LIST_ENTRY` structures:\n\n![image-20200308154619201](https://tva1.sinaimg.cn/large/00831rSTly1gcmkfyh7iwj30nu0crdgn.jpg)\n\n\n\nReview:\n\nTo list processes, Volatility first locates the kernel debugger data block ( `_KDDEBUGGER_DATA64`). From there, it accesses the `PsActiveProcessHead` member, which points to the head of the doubly linked list of `_EPROCESS` structures. \n\nWe also discussed the pool-scanning approach in Chapter 5.\n\n> In this chapter, we present many other ways to find processes in a memory dump. It is important to implement alternative methods because the debugger data block, the linked-list pointers, and the pool tags are all nonessential to OS stability—which means they can be manipulated (accidentally or intentionally) to defeat forensic tools without disrupting the system or its processes.\n\n\n\n#### >> Critical System Processes\n\n> if you know what’s normal, you can detect what’s abnormal more quickly\n\nSo for now we’ll just focus on the theoretical concepts of how things should appear on clean systems.\n\n* `Idle` and `System`: These are not real processes (in the sense that they have no corresponding executable on disk). Idle is just a container that the kernel uses to charge CPU time for idle threads. Similarly, System serves as the default home for threads that run in kernel mode. Thus, the System process (PID 4) appears to own any sockets or handles to files that kernel modules open.\n* `csrss.exe`: **The client/server runtime subsystem plays a role in creating and deleting processes and threads**. It maintains a private list of the objects that you can use to cross-reference with other data sources. \n* `services.exe`: The Service Control Manager (SCM) in short, **it manages Windows services and maintains a list of such services in its private memory space.** This process should be the parent for any svchost.exe (service host) instances that you see, in addition to processes such as spoolsv.exe and SearchIndexer.exe that implement services. There should be only one copy of services.exe on a system, and it should be running from the system32 directory.\n* `svchost.ex`e: A clean system has multiple shared host processes running concurrently, each providing a container for DLLs that implement services. As previously mentioned, their parent should be services.exe, and the path to their executable should point to the system32 directory. In his blog, Patrick identifies a few of the common names (such as scvhost.exe and svch0st.exe) used by malware to blend in with these processes.\n* `lsass.exe`: The local security authority subsystem process is responsible for enforcing the security policy, verifying passwords, and creating access tokens. As such, it’s often the target of code injection because the plaintext password hashes can be found in its private memory space. There should be only one instance of lsass.exe running from the system32 directory, and its parent is winlogon.exe on pre-Vista machines, and wininit.exe on Vista and later systems. Stuxnet created two fake copies of lsass.exe, which caused them to stick out like a sore thumb.\n* `winlogon`.exe : This process presents the interactive logon prompt, initiates the screen saver when necessary, helps load user profiles, and responds to Secure Attention Sequence (SAS) keyboard operations such as CTRL+ALT+DEL. Also, this process monitors files and directories for changes on systems that implement Windows File Protection (WFP). As with most other critical processes, its executable is located in the system32 directory.\n* `explorer.exe`: You’ll see one Windows Explorer process for each logged-on user. It is responsible for handling a variety of user interactions such as GUI-based folder navigation, presenting the start menu, and so on. It also has access to sensitive material such as the documents you open and credentials you use to log in to FTP sites via Windows Explorer.\n* `smss.exe`: The session manager is the first real user-mode process that starts during the boot sequence. It is responsible for creating the sessions (see Chapter 14) that isolate OS services from the various users who may log on via the console or Remote Desktop Protocol (RDP).\n\n\n\n#### >> Analyzing Process Activity*\n\n* `pslist` **finds and walks the doubly linked list of processes and prints a summary of the data.** This method typically **cannot show you terminated or hidden processes**. \n* `pstree` takes the output from pslist and formats it in a tree view, so you can easily see parent and child relationships.\n* `psscan` **scans for ` _EPROCESS` objects instead of relying on the linked list**. This plugin **can also find terminated and unlinked (hidden) processes**.\n* `psxview` locates processes using alternate process listings, so you can then cross-reference different sources of information and reveal malicious discrepancies.\n\n\n\n#### >> Process Tree Visualizations\n\n```\npython vol.py psscan –f simple007.mem --profile=Win7SP1x64\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    --output=dot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    --output-file=processes.dot\n\n⚙ chuqiz@Narny-6 => ~/Downloads/graphviz-2.40.1 => dot -Tsvg -o ~/tree.svg ~/Desktop/processes.dot\n```\n\nTree likes below：\n\n![image-20200308170307920](https://tva1.sinaimg.cn/large/00831rSTly1gcmmnur1tmj31y60g0tbn.jpg)\n\n#### >> Detecting DKOM Attacks\n\nMany attacks are possible with Direct Kernel Object Manipulation (DKOM), but one of the most common is hiding a process by **unlinking its entry from the doubly linked list**. To accomplish this, overwrite the Flink and Blink pointers of surrounding objects so that they point around the `_EPROCESS` structure of the process to hide. Tools that execute on a running system and Volatility’s `pslist` command are susceptible to this attack, because they rely on the linked list. However, the `psscan` plugin uses the pool-scanning approach.\n\n\n\n**Process Cross-View Plugin**\n\nThe `psxview` plugin enumerates processes in seven different ways: the active process linked list and the six methods previously identified. Thus, it’s unlikely that a rootkit can successfully hide from `psxview`.\n\n![image-20200308163252517](https://tva1.sinaimg.cn/large/00831rSTly1gcmlsdh8aqj30y40k240f.jpg)\n\n\n\n### > Process Tokens\n\nA process’ token describes its security context. This context includes security identifiers (SIDs) of users or groups that the process is running as and the various privileges (specific tasks) that it is allowed to perform.\n\nWhen the kernel needs to decide whether a process can access an object or call a particular API, it consults data in the process’ token.\n\n\n\n#### >> Data Structures\n\nThe `_TOKEN` structure is large, so we won’t display all the members.\n\n![image-20200308164700337](https://tva1.sinaimg.cn/large/00831rSTly1gcmm72qyj8j30lm0judj3.jpg)\n\nand below:\n\n![image-20200308164716818](https://tva1.sinaimg.cn/large/00831rSTly1gcmm7czsqbj30n30pi42j.jpg)\n\n* `UserAndGroupCount`: This integer stores the size of the `UserAndGroups` array.\n\n* `UserAndGroups`: An array of `_SID_AND_ATTRIBUTES` structures associated with the token. Each element in the array describes a different user or group that the process is a member of. The `Sid` member of `_SID_AND_ATTRIBUTES` points to a `_SID` structure, which has `IdentifierAuthority` and `SubAuthority` members that you can combine to form the S-1-5-[snip] SID strings.\n\n* `PrivilegeCount` (Windows XP and 2003 only): This integer stores the size of the `Privileges` array.\n\n* `Privileges` (Windows XP and 2003): An array of `_LUID_AND_ATTRIBUTES` structures\n\n  that each describe a different privilege and its attributes (that is, present, enabled, enabled by default).\n\n* `Privileges` (Windows Vista and later): This is an instance of `_SEP_TOKEN_PRIVILEGES`, which has three parallel 64-bit values (Present, Enabled, EnabledByDefault). The bit positions correspond to particular privileges, and the values of the bit (on or off) describe the privilege’s status.\n\n\n\n#### >> Accessing Tokens\n\nOn a live machine, a process can access its own token through the `OpenProcessToken` API. To enumerate the SIDs or privileges, it can then use `GetTokenInformation` with the desired parameters. \n\nWith administrator access, it can also query (or set) the tokens of other users’ processes, including the system-critical ones. Of course, existing tools already provide this type of functionality for you, such as **Sysinternals Process Explorer**.\n\n![image-20200308171420415](https://tva1.sinaimg.cn/large/00831rSTly1gcmmziqholj30df0g7juz.jpg)\n\nThis instance of explorer.exe belongs to a user named Jimmy, whose SID string is `S-1-5-21-[snip]-1000`. By analyzing the other SIDs in this process’ token, you can see it’s also in the `Everyone`, `LOCAL`, and `NT AUTHORITY\\Authenticated Users` groups.\n\n\n\n#### >> Extracting and Translating SIDs in Memory\n\nthere are User SIDs such as S-1-5-21-4010035002-774237572-2085959976-1000. These SIDs break down into the following components:\n\n* S: Prefix indicating that the string is a SID \n* 1: The revision level (version of the SID specification) from `_SID.Revision` \n* 5: The identifier authority value from `_SID.IdentifierAuthority.Value` \n* 21-4010035002-774237572-2085959976: The local computer or domain identifier from the `_SID.SubAuthority` values \n* 1000: A relative identifier that represents any user or group that doesn’t exist by default\n\nYou can map the SID string to a username by querying the registry:\n\n```\npython vol.py -f memory.img --profile=Win7SP0x86 printkey -K \"Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\S-1-5-21-4010035002-774237572-2085959976-1000\"\n```\n\n![image-20200308173111605](https://tva1.sinaimg.cn/large/00831rSTly1gcmnh1ueklj30n80alta3.jpg)\n\n\n\n#### >> Detecting Lateral Movement\n\nIf you need to associate a process with a user account or investigate potential lateral movement attempts, use the getsids plugin.\n\n```\n$ python vol.py –f grrcon.img --profile=WinXPSP3x86 getsids –p 1096\n\nexplorer.exe: S-1-5-21-2682149276-1333600406-3352121115-500 (administrator) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-513 (Domain Users) explorer.exe: S-1-1-0 (Everyone) explorer.exe: S-1-5-32-545 (Users)\nexplorer.exe: S-1-5-32-544 (Administrators) explorer.exe: S-1-5-4 (Interactive) explorer.exe: S-1-5-11 (Authenticated Users) explorer.exe: S-1-5-5-0-206541 (Logon Session) \nexplorer.exe: S-1-2-0 (Local (Users with the ability to log in locally)) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-519 (Enterprise Admins) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-1115 \nexplorer.exe: S-1-5-21-2682149276-1333600406-3352121115-518 (Schema Admins) explorer.exe: S-1-5-21-2682149276-1333600406-3352121115-512 (Domain Admins)\n```\n\nThis command shows the SIDs associated with explorer.exe for the current logged-on user.\n\n\n\n### > Privileges\n\nPrivileges are another critical component involved in security and access control. A privilege is the permission to perform a specific task, such as debugging a process, shutting down the computer, changing the time zone, or loading a kernel driver.\n\nBefore a process can enable a privilege, the privilege must be present in the process’ token. Administrators decide which privileges are present by configuring them in the Local Security Policy (LSP),\n\nYou can access the LSP by going to Start ➪ Run and typing SecPol.msc:\n\n![image-20200308174427394](https://tva1.sinaimg.cn/large/00831rSTly1gcmnuuh2ldj30gi0iadg7.jpg)\n\n![image-20200308174509331](https://tva1.sinaimg.cn/large/00831rSTly1gcmnvkq70mj30q60gmjva.jpg)\n\nIn English:\n\n![image-20200308174533487](https://tva1.sinaimg.cn/large/00831rSTly1gcmnvzwow0j30k80ak0ye.jpg)\n\n\n\nFrom a forensic perspective, you should be most concerned with the following privileges when they’ve been explicitly enabled:\n\n* `SeBackupPrivilege`: This grants read **access to any file on the file system**, regardless of its specified access control list (ACL). Attackers can leverage this privilege to copy locked files.\n* `SeDebugPrivilege`: This **grants the ability to read from or write to another process’ private memory space**. It **allows malware to bypass the security boundaries that typically isolate processes**. Practically all malware that performs code injection from user mode relies on enabling this privilege.\n\n* `SeLoadDriverPrivilege`: This **grants the ability to load or unload kernel drivers**.\n* `SeChangeNotifyPrivilege`: This **allows the caller to register a callback function that gets executed when specific files and directories change.** Attackers can use this to determine immediately when one of their configuration or executable files are removed by antivirus or administrators.\n* `SeShutdownPrivilege`: This **allows the caller to reboot or shut down the system**. Some infections, such as those that modify the Master Boot Record (MBR) don’t activate until the next time the system boots. Thus, you’ll often see malware trying to manually speed up the procedure by invoking a reboot.\n\n\n\n#### >> Analyzing Explicit Privileges\n\nHere’s the output of the Volatility `privs` plugin. You’ll see the privilege name along with its attributes (present, enabled, and/or enabled by default):\n\n```\npython vol.py -f grrcon.img privs -p 1096\n```\n\n![image-20200308175020273](https://tva1.sinaimg.cn/large/00831rSTly1gcmo0z63yvj30mv07swg1.jpg)\n\nand below:\n\n![image-20200308175027708](https://tva1.sinaimg.cn/large/00831rSTly1gcmo13rnf6j30mm08qmza.jpg)\n\nYou can see several privileges present in the output. Only six of them are enabled, but three are enabled by default.\n\n\n\n### > Process Handles\n\nA handle is a reference to an open instance of a kernel object, such as a file, registry key, mutex, process, or thread.\n\n> By enumerating and analyzing the specific objects a process was accessing at the time of a memory capture, it is possible to arrive at a number of forensically relevant conclusions—such as what process was reading or writing a particular file, what process accessed one of the registry run keys, and which process mapped remote file systems.\n\n\n\n#### >> Lifetime of a Handle\n\nBefore a process can access an object, it first opens a handle to the object by calling an API such as `CreateFile`, `RegOpenKeyEx`, or `CreateMutex`. These APIs return a special Windows data type called `HANDLE`, which is simply an index into a process-specific handle table.\n\nFor example, when you call `CreateFile`,\n\n a pointer to the corresponding `_FILE_OBJECT` in kernel memory is placed in the first available slot in the calling process’ handle table, and the respective index (such as 0x40) is returned. Additionally, **the handle count for the object is incremented**. The calling process then passes the `HANDLE` value to functions that perform operations on the object, such as reading, writing, waiting, or deleting. Thus, APIs such as ReadFile and WriteFile work in the following manner:\n\n1. Find the base address of the calling process’ handle table.\n2. Seek to index 0x40.\n3. Retrieve the _FILE_OBJECT pointer.\n4. Carry out the requested operation.\n\nWhen a process is finished using an object, it should close the handle by calling the appropriate function (`CloseHandle`, `RegCloseHandle`, and so on). These APIs **decrement the object’s handle count** and **remove the pointer to the object from the process’ handle table**.\n\n\n\n**❓WHY USE HANDLE TABLE MODEL❓**\n\nThe handle table model was designed for both convenience and security.\n\n*  It’s convenient because [you don’t have to pass the full name or path of an objec]()t each time you perform an operation—only when you initially open or create the object. \n* For security purposes, it also helps to **conceal the addresses of objects in kernel memory**. Because processes in user mode should never directly access kernel objects, there’s no reason why they would need the pointers. \n* Furthermore, the model **provides a centralized way for the kernel to monitor access to kernel objects**, thus giving it the chance to enforce security based on SIDs and privileges.\n\n\n\n#### >> Reference Counts and Kernel Handles\n\nSo far in this section, we’ve been referring to processes as the entities that interact with objects **via handles**.\n\nHowever, kernel modules, or threads in kernel mode, can call the equivalent kernel APIs (i.e., `NtCreateFile`, `NtReadFile`, `NtCreateMutex`) in a similar manner. In this case, the handles are **allocated from the System (PID 4) process’ handle table.** \n\n> Thus, when you dump the handles of the System process, you’re **actually seeing all the currently open resources requested by kernel modules.**\n\n* Even if handles are closed, and references are released, there’s still a chance that you can find the objects by scanning the physical address space (as described in Chapter 5).\n\n*  Of course, they wouldn’t be associated with a process’ handle table at that point, but their **presence in RAM can still lend clues to your investigations**. \n\n  > Likewise, after a process terminates, its handle table is destroyed, but that doesn’t mean all objects created by the process are destroyed at the same time.\n\n\n\n#### >> Handle Table Internals\n\nEach process’ `_EPROCESS.ObjectTable` member **points to a handle table** ( `_HANDLE_TABLE`). This structure has a `TableCode` that serves two critical purposes: \n\n* It **specifies the number of levels in the table.**\n* It **points to the base address of the first level.** \n\nAll processes start out with a single-level table, which is shown in Figure 6-12. The table size is one page (4096 bytes), and this scheme allows for up to 512 handles on a 32-bit system or 256 on a 64-bit system. Indexes in the table contain `_HANDLE_TABLE_ENTRY` structures if they’re in use; otherwise, they’re zeroed out.\n\n![image-20200308194859560](https://tva1.sinaimg.cn/large/00831rSTly1gcmrgfjz3cj30o20dsabx.jpg)\n\nAlso, there are two-level even three-level table.\n\n> You can image it as Page Directory and Page Table Entry and so on.\n\n\n\n#### >> Data Structures\n\n![image-20200308195404675](https://tva1.sinaimg.cn/large/00831rSTly1gcmrlq7r02j30m609bq4r.jpg)\n\nand below:\n\n![image-20200308195419291](https://tva1.sinaimg.cn/large/00831rSTly1gcmrlytjh8j30mc0bjjtm.jpg)\n\nSome key points for `_HANDLE_TABLE`:\n\n* `TableCode`: This value **tells you the number of levels in the table and points to the address of the top-level table**. The dual purpose is achieved using a bit mask of seven (7). For example, to obtain the number of tables, you can compute TableCode & 7; and to obtain the address, you can compute TableCode & ~7. \n* `QuotaProcess` : **A pointer to the process to which the handle table belongs**. It can come in handy if you find handle tables using the pool-scanning approach described in Chapter 5 rather than enumerating processes and following their ObjectTable pointer.\n* `HandleTableList`: **A linked list of process handle tables in kernel memory**. You can use it to locate other handle tables—potentially even those for processes that have been unlinked from the process list.\n* `HandleCount`: The **total number of handle table entries** that are currently in use by the process. This field was removed starting in Windows 8 and Server 2012.\n\nSome key points for `_HANDLE_TABLE_ENTRY`:\n\n* `Object`: This member points to the `_OBJECT_HEADER` of the corresponding object. The `_EX_FAST_REF` is a special data type that combines reference count information into the least significant bits of the pointer.\n\n* `GrantedAccess`: A bit mask that specifies the granted access rights (read, write, delete, synchronize, etc.) that the owning process has obtained for the object.\n\n\n\n### > Enumerating Handles in Memory*\n\nThe Volatility `handles` plugin generates output by walking the handle table data structures. There are a few filtering options:\n\n* Filter by process ID: You can pass one or more (comma-separated) process IDs to the `-p/--pid` option.\n\n* Filter by process offset: You can supply the physical offset of an `_EPROCESS` structure to the `-o/--offset` option.\n\n* Filter by object type: If you’re interested in only a particular type of object, such as files or registry keys, you can specify the appropriate name(s) to the `-t/--object-type` option. See Chapter 5 or enter `!object \\ObjectTypes` into Windbg to see the full list of object types.\n\n* Filter by name: Not all objects have names. Unnamed objects are obviously useless when searching for indicators by name, so one way to reduce noise is to use the `--silent` option, which suppresses handles to unnamed objects.\n\n\n\n```\npython vol.py -f zeus.vmem --profile=WinXPSP3x86 -p 632 handles\n```\n\n![image-20200308200304795](https://tva1.sinaimg.cn/large/00831rSTly1gcmrv336bfj30o2036gly.jpg)\n\nand below:\n\n![image-20200308200316769](https://tva1.sinaimg.cn/large/00831rSTly1gcmrvan7y9j30nw06iq44.jpg)\n\nAs shown in the next example, you can limit your search to files and mutexes opened by PID 632 and ignore unnamed objects:\n\n```\npython vol.py -f zeus.vmem --profile=WinXPSP3x86 -p 632 handles\n\t\t-t File,Mutant\n\t\t--silent\n```\n\n![image-20200308200423716](https://tva1.sinaimg.cn/large/00831rSTly1gcmrwge5e3j30o50df0vi.jpg)\n\nYou see the user.ds and local.ds files, which contain the configuration and stolen data. The sdra64.exe file in the system32 directory is the initial Zeus installer.\n\n> ou also may notice several open handles to `\\Device\\Tcp` and `\\Device\\Ip`. These are obviously different from the handles to files prefixed with `\\Device\\HarddiskVolume1`.\n>\n> Specifically, Tcp and Ip are not files on the machine’s hard drive. This is described in Chapter 11, but what you’re essentially seeing are artifacts of network sockets that the process creates. Although sockets aren’t files, they support similar operations such as opening, reading, writing, and deleting. As a result, the same handle/descriptor subsystem can service both files and network sockets.\n\n> Along the same lines, **named pipes are also represented as file objects**. Thus, if malware creates a named pipe for interprocess communication or to redirect output of a backdoor command shell into a file, you can determine which processes are involved in that activity, provided that you **know the name of the pipe it creates. In this case, it’s easy to identify because the name of the pipe that Zeus uses is the same as the standard mutex it creates to mark its presence on systems ( _AVIRA_)**.\n\n\n\n#### >> Detecting Registry Persistence\n\nMalware often leverages the registry for persistence. To write the pertinent values, the malicious process must first open a handle to the desired registry key.\n\n> you’ll see how obvious it is when malware chooses a well-known location (such as the Run key) and also suffers from a handle leak. You should not only recognize the registry key name but also the fact that you have numerous open handles to the same key.\n\n```\npython vol.py -f laqma.mem --profile=WinXPSP3x86 handles\n\t\t--object-type=Key\n\t\t--pid=1700\n```\n\n![image-20200308202015902](https://tva1.sinaimg.cn/large/00831rSTly1gcmsd08hraj30o60j3win.jpg)\n\n> The process has nearly 20 open handles to the RUN key (not all are shown). This is indicative of a bug in the code that fails to close its handles after opening them.\n\nOf course, the artifacts won’t always be this obvious, and just because a handle to a key is open, that doesn’t mean the process added values. \n\nHowever, you can always confirm your suspicions by using the `printkey` plugin (see Chapter 10) to look at the actual data that the key contains:\n\n```\npython vol.py -f laqma.mem printkey -K \"MICROSOFT\\WINDOWS\\CURRENTVERSION\\RUN\"\n```\n\n![image-20200308202735782](https://tva1.sinaimg.cn/large/00831rSTly1gcmsklhwp0j30nw0deac5.jpg)\n\nBased on their names, the final two entries seem suspicious—they cause `lanmanwrk.exe` and `KernelDrv.exe` to start automatically at each boot.\n\n\n\n#### >> Identifying Remote Mapped Drives\n\nMany adversaries rely on commands such as `net view` and `net use` to explore the surrounding network and map remote drives. \n\nObtaining read access to a company’s Server Message Block (SMB) file server or write access to various other workstations or servers in an enterprise can lead to successful lateral movement.\n\n* The following example shows **how an attacker navigates the network to mount two remote drives**. The Users directory of a system named WIN-464MMR8O7GF is mounted on P, and the C$ share of a system named LH-7J277PJ9J85I is mounted at Q:\n\n![image-20200308203556523](https://tva1.sinaimg.cn/large/00831rSTly1gcmsta2ujuj30m70ic0v9.jpg)\n\n\n\n* **The trick to finding evidence of remote mapped drives in memory** is to look for file handles prefixed with `\\Device\\Mup` and `\\Device\\LanmanRedirector`:\n\n  > MUP, which stands for Multiple Universal Naming Convention (UNC) Provider, is a kernel-mode component that channels requests to access remote files using UNC names to the appropriate network redirector. In this case, `LanmanRedirector` handles the SMB protocol.\n\n```\npython vol.py -f hop.mem --profile=VistaSP2x64 handles -t File | grep Mup\n```\n\n![image-20200308204050322](https://tva1.sinaimg.cn/large/00831rSTly1gcmsydpfuej30o10a9aby.jpg)\n\nYou have several plain handles to `\\Device\\Mup` (they are normal). The few in bold are the ones you should find interesting because they actually display the local drive letter, the remote NetBIOS name, and the share or file system path name. \n\n> There are also two different process IDs shown: 752 and 1544. In this case, 752 is the instance of svchost.exe that runs the LanmanWorkstation service; it creates and maintains client network connections to remote servers using the SMB protocol. PID 1544 is the cmd.exe shell, and it has a handle to `C$\\Users\\Jimmy\\Documents` as a result of the attacker changing into that directory.\n\n\n\n## 7 Process Memory Internals\n\nThis chapter analyzes the various application programming interfaces (APIs) used for allocating the different data types and examines how to enumerate process memory regions via memory forensics.\n\n\n\n### > What's in Process Memory?\n\nAs you know, each process has its owen private view of memory in this range(upper bounds of the range can be vary between of operating systems).\n\nWe simply represented the highest value as `MmHighestUserAddress`.\n\n> This is a symbol in the NT module that you can query with a debugger or inside Volatility’s `volshell` plugin.\n\n![image-20200309151913862](https://tva1.sinaimg.cn/large/00831rSTly1gcnpa1y6n7j30e10dgdgk.jpg)\n\nIt's important to know that **the positions of the ranges are not constant, especially on systems that levergae address spase layout randomization(ASLR)**.\n\n> the thread stacks can exist below or above the process executable, or the ranges containing mapped files can be interspersed throughout the entire process space, not gathered contiguously as the diagram above shows.\n\n* `Dynamic linked libraries (DLLs)`: This area represents **shared libraries (DLLs) that were loaded into the address space**, either intentionally by the process or forcefully through library injection.\n\n* `Environment variables`: This range of memory **stores the process’ environment variables, such as its executable paths, temporary directories, home folders**, and so on.\n\n* `Process Environment Block (PEB)`: An extremely useful structure that **tells you where to find several of the other items in this list**, including the DLLs, heaps, and environment variables. It also contains the process’ command line arguments, its current working directory, and its standard handles.\n\n* `Process heaps`: Where you can find a majority of the dynamic input that the process receives. \n\n  > For example, variable-length text that you type into e-mail or documents is often placed on the heap, as is data sent or received over network sockets.\n\n* `Thread stacks`: **Each thread has a dedicated range of process memory set aside for its runtime stack**. This is where you can find function arguments, return addresses (allowing you to reconstruct call history), and local variables.\n\n* `Mapped files and application data`: This item is left intentionally vague because the content really depends on the process. **Mapped files represent content from files on disk, which could be configuration data, documents, and so on**. **Application data is anything the process needs to perform its intended duties**.\n\n* `Executable`: The process executable contains **the primary body of code and read/ write variables for the application**. This data may be compressed or encrypted on disk, **but once loaded into memory, it unpacks, enabling you to dump plain-text code back to disk**.\n\n\n\n### Memory Allocation APIs\n\n![image-20200309152939761](https://tva1.sinaimg.cn/large/00831rSTly1gcnpkwg0pvj30ox0f9q5l.jpg)\n\n\n\nQUESTION❓\n\nThese two virtual allocation functions are also the only ones that allow the caller to reserve memory (that is, set it aside) before committing it. This allows applications to “save” a large region of virtually contiguous memory for later use, without tying up the underlying physical pages in the meantime.\n\nWHY？\n\n\n\n### > Enumerating Process Memory\n\n\n\n#### >> Process Page Tables\n\nWe can use `memmap` and `memdump` plugins to list and extract all pages accessible to a process.\n\n> In this case, accessible includes kernel mode addresses because even threads that start in user memory transition into kernel memory when system APIs are called.\n\n![image-20200309154721770](https://tva1.sinaimg.cn/large/00831rSTly1gcnq3brf4gj30fw0e0my0.jpg)\n\n```\n$ python vol.py -f memory.dmp --profile=Win7SP0x64 memmap –p 864\n```\n\n![image-20200309154752063](https://tva1.sinaimg.cn/large/00831rSTly1gcnq3ugu07j30mb0aidh4.jpg)\n\nand below:\n\n![image-20200309154806825](https://tva1.sinaimg.cn/large/00831rSTly1gcnq43wktzj30md08pwfp.jpg)\n\nAlthough the system’s default page size is 4KB (`0x1000` bytes hex), you can see a few pages of size `0x200000`, which is 2MB. These are Page Size Entry (PSE) pages.\n\n* `DumpFileOffset`: This value specifies the offset of the corresponding page in the file produced by the `memdump` plugin. \n\n  > Because process address spaces are sparse—holes or gaps exist between available pages—the output file is also sparse. For example, the data at virtual address `0xff4c1000` maps to physical offset `0x151b77000` (5.2GB), but your output file for this process will be nowhere near that large. Thus, the `DumpFileOffset` column tells you where to find the contents of `0xff4c1000` in your output file (`0x2a3000`). \n\n`memdump`:\n\n```\n$ python vol.py -f memory.dmp --profile=Win7SP1x64 memdump -p 864 -D OUTDIR\n$ ls -alh OUTDIR/864.dmp \n---------------------------------------------------------------------\n-rw-r--r-- 1 michael staff           434M Mar 14 14:51 864.dmp\n```\n\n![image-20200309160654094](https://tva1.sinaimg.cn/large/00831rSTly1gcnqnnldlhj30lo0frgov.jpg)\n\n\n\n### > Virtual Address Descriptors\n\nA process’ VAD tree describes the layout of its memory segments at a slightly higher level than the page tables. \n\n*The operating system, not the CPU, defines and maintains these data structures.*\n\n> VADs contain the names of memory-mapped files, the total number of pages in the region, the initial protection (read, write, execute), and several other flags that can tell you a lot about what type of data the regions contain.\n\nEach node in the tree **represents one range in process virtual memory**. A node that describes a memory range lower than its parent appears on the left, and a node that describes a higher range appears on the right：\n\n![image-20200309161110171](https://tva1.sinaimg.cn/large/00831rSTly1gcnqs3f7mtj30on0c43zo.jpg)\n\n\n\n#### >> VAD Structures\n\nFor each process, `_EPROCESS.VadRoot` points to the root of the VAD tree.\n\n> the type of the member has frequently changed, as have the names of the VAD nodes. The differences are shown in Table below. For example, on Windows XP and 2003 Server, VadRoot pointed to an` _MMVAD_SHORT`, `_MMVAD`, or `_MMVAD_LONG`.\n\n![image-20200309161744038](https://tva1.sinaimg.cn/large/00831rSTly1gcnqyx67iqj30ol08uwft.jpg)\n\n\n\n`_MM_AVL_TABLE`:\n\n![image-20200309164359492](https://tva1.sinaimg.cn/large/00831rSTly1gcnrq8u3rnj30nz08a0uc.jpg)\n\n* You can see the `_MM_AVL_TABLE` has a BalancedRoot member, which is an `_MMADDRESS_NODE`.\n* ***Each node* has a set of pointers to its child nodes and a `StartingVpn` and `EndingVpn`.** From these **virtual page numbers (VPNs)**, you can derive the addresses of the first and last pages in the target process’ virtual memory.\n* VPNs are page numbers, not addresses.(To get the address, you have to multiply the page number by the size of a page.)\n\n\n\n`_MMADDRESS_NODE(40 bytes)`:\n\nIt is an alias and it is really one of the `_MMVAD*`(short, regular, long)\n\n![image-20200309164742768](https://tva1.sinaimg.cn/large/00831rSTly1gcnru4bhuqj30nu059757.jpg)\n\n`_MMVAD_SHORT`:\n\n![image-20200309165155887](https://tva1.sinaimg.cn/large/00831rSTly1gcnryihkurj30o507r0u3.jpg)\n\n`_MMVAD`:\n\n![image-20200309165226422](https://tva1.sinaimg.cn/large/00831rSTly1gcnrz1cz78j30ny0cpgo8.jpg)\n\n`_MMVAD_LONG`:\n\n![image-20200309165303141](https://tva1.sinaimg.cn/large/00831rSTly1gcnrzoc1uzj30ne037jrn.jpg)\n\nand below:\n\n![image-20200309165317383](https://tva1.sinaimg.cn/large/00831rSTly1gcnrzx8k6ij30ny0aptav.jpg)\n\na short node does not have a `Subsection`, thus it cannot possibly store a mapped file. \n\nOn the other hand, shell code that gets injected into a process never needs to exist on disk. \n\nThus, it won’t be backed by a file. As a result, **if you’re hunting for code injection, you can probably ignore the regular and long nodes**.\n\n\n\n#### >> VAD Tags\n\nAfter reading the structures above, you may wonder how Volatility determines which of the three `_MMVAD*` structures is aliased by an `_MMADDRESS_NODE`.\n\nThe answer is `Tag` member.(The offset of this member is -`0xc`)\n\n> Indeed, this is a convenient hack allowed when defining structures with Volatility. Essentially what we’re doing is accessing the `PoolTag` member of the `_POOL_HEADER`, which exists in memory directly before the node.\n\nA mapping of VAD-Related Pool Tags to Strucrute type:\n\n![image-20200309171826693](https://tva1.sinaimg.cn/large/00831rSTly1gcnsq3c6zzj30of06ft94.jpg)\n\n**Memory regions that contain injected shell code won’t be backed by a file. Thus, you would be looking for nodes with a VadS or VadF tag.**\n\n\n\n#### >> VAD Flags\n\nEach node has one or more sets of flags that contain characteristics about the memory range.(These flags are located in embedded unions named u, u1, u2, u3, and so on).\n\nThis name is based on `unnamed-tag` because unions don't have associated types.\n\n![image-20200309174815086](https://tva1.sinaimg.cn/large/00831rSTly1gcntl3y1nrj30li0bitb9.jpg)\n\nBits 0 to 51 of the 8-byte value are for CommitCharge, and bits 56 to 61 are the Protection.\n\n\n\n#### >> CommitCharge\n\n`CommitCharge` specifies the number of pages committed in the region described by the VAD node.\n\nQUESTION:❓\n\nThe reason we care about this field is because historically when code injecting malware sets up the target process’ address space to receive the malicious code, it commits all pages up front—it doesn’t reserve them and then go back and commit them later (although it very well could). Thus, you can use these additional characteristics to help identify injected memory regions.\n\n\n\n#### >> Protection\n\nThis field indicates what type of access should be allowed to the memory region.\n\n* `PAGE_EXECUTE`: The memory can be executed, but not written. This protection cannot be used for mapped files.\n\n* `PAGE_EXECUTE_READ`: The memory can be executed or read, but not written.\n* `PAGE_EXECUTE_READWRITE`: The memory can be executed, read, or written. Injected code regions almost always have this protection.\n\n* `PAGE_EXECUTE_WRITECOPY`: Enables execute, read-only, or copy-on-write access to a mapped view of a file. It cannot be set by calling `VirtualAlloc` or `VirtualAllocEx`. DLLs almost always have this protection.\n\n* `PAGE_NOACCESS`: Disables all access to the memory. This protection cannot be used for mapped files. Applications can prevent accidental reads/writes to data by setting this protection.\n\n* `PAGE_READONLY`: The memory can be read, but not executed or written. \n* `PAGE_READWRITE`: The memory can be read or written, but not executed.\n* `PAGE_WRITECOPY`: Enables read-only or copy-on-write access to a mapped view of a file. It cannot be set by calling VirtualAlloc or VirtualAllocEx.\n\nNote:\n\nProtection field from the VAD `flags` is that it’s only the **initial protection** specified for all pages in the range when they were first reserved or committed. Thus, the current protection can be drastically different.\n\n\n\n#### >> Private Memory\n\nPrivate memory, in this context, refers to committed regions that **cannot typically be shared with or inherited by other processes**.\n\n* Mapped files, named shared memory, and copy-onwrite DLLs can be shared with other processes (although they may not be). **Thus, if the `PrivateMemory` bit is set for a memory region, it does not contain one of the aforementioned types of data**. \n* A process’ heaps, stacks, and ranges allocated with `VirtualAlloc` or `VirtualAllocEx` are usually marked as private.\n\n\n\n#### >> Volatility VAD Plugins\n\n* `vadinfo` : Displays the most verbose output, including the starting and ending addresses, the protection level, flags, and full paths to mapped files or DLLs. \n\n![image-20200310011133726](https://tva1.sinaimg.cn/large/00831rSTly1gco6eevfzsj30pb07a75c.jpg)\n\n* `vadtree`: In text mode, this plugin prints a tree-view of the nodes, so you can see the parent and child relationships on your console. \n\n* `vaddump` : **Extracts the range of process memory each VAD node describes to a separate file on disk**. Unlike memmap (discussed earlier), the output from this plugin is padded with zeros if any pages in the range are swapped to disk to maintain spatial integrity (offsets).\n\n\n\n## 8 Hunting Malware in Process Memory\n\nNow we will see some specific examples of how can detect malware that hides in process by unlinking dynamic linked ilbraries(DLL) or using one of four different methods of injecting code.\n\n\n\n### > Process Environment Block(PEB)\n\nEvery` _EPROCESS` structure contains a member called the Process Environment Block (PEB). \n\nThe PEB contains the full path to the process’ executable, the full command line that starts the process, the current working directory, pointers to the process’ heaps, standard handles, and three doubly linked lists that contain the full path to DLLs loaded by the process.\n\n\n\n#### >> Data Structures\n\nThe main PEB structure is appropriately named `_PEB`. \n\n> `_PEB` structure exists in process memory, so **a process can easily modify its own values** to falsely report information or thwart analysis.\n\n![image-20200310174936970](https://tva1.sinaimg.cn/large/00831rSTly1gcoz8u5pulj30ny0bp0ut.jpg)\n\nKey Points:\n\n* `BeingDebugged`: Tells you whether the process is currently being debugged. In the past, we’ve seen malware that attaches to itself (by calling `DebugActiveProcess`).\n\n  > Because only one debugger at a time can attach to a target process, it served as anti-debugging protection. Thus, **there is a red flag if this value is set to true, but there are no legitimate active debuggers running**.\n\n* `ImageBaseAddress` : **The address in process memory where the main executable (.exe) is loaded**. Before Volatility’s `procdump` plugin (described later in the chapter) carves an executable from memory, it reads this value so it knows where to look. \n* `Ldr`: Points to a `_PEB_LDR_DATA` structure, which **contains details about the DLLs loaded in a process**.\n* `ProcessParameters`: Points to a `_RTL_PROCESS_PARAMETERS` structure (described soon).\n\n* `ProcessHeap`: Primary heap for the process, which is created automatically when the process is initialized.\n\n* `NumberOfHeaps`: Number of heaps in a process. By default, a process has only one heap, but it can create others by calling `HeapCreate`.\n\n* `ProcessHeaps` : An array of pointers to process heaps. The first entry in this list always points to the same location as ProcessHeap because it is the primary.\n\n\n\nThen we look into the `_RTL_USER_PROCESS_PARAMETERS` structure:\n\n![image-20200310180558394](https://tva1.sinaimg.cn/large/00831rSTly1gcozpuoyqpj30nr04mgm8.jpg)\n\nand below:\n\n![image-20200310180640220](https://tva1.sinaimg.cn/large/00831rSTly1gcozqkx6gbj30nq04p3z2.jpg)\n\nKey Points:\n\n* `StandardInput`: The process’ standard input handle. \n* `StandardOutput`: The process’ standard output handle.\n\n* `StandardError`: The process’ standard error handle.\n* ` CurrentDirectory`: The current working directory for the application.\n\n* `ImagePathName`: The Unicode full path on disk to the process executable (.exe).\n\n  > You often need to consult this value because the `_EPROCESS.ImageFileName` (printed by the pslist plugin) contains only the first 16 characters and it does not include Unicode.\n\n* `CommandLine`: The full command line, including all arguments, used to invoke the process.\n\n* `Environment`: A pointer to the process’ environment variables.\n\n\n\nThe `_PEB_LDR_DATA` structure:\n\n![image-20200310181043016](https://tva1.sinaimg.cn/large/00831rSTly1gcozusn6ofj30n9053dgg.jpg)\n\nKey Points:\n\n* `InLoadOrderModuleList`: A linked list that organizes modules **in the order in which they are loaded into a process**. \n\n  > Because the **process executable is always first to load in the process address space**, its entry is first in this list. \n\n* `InMemoryOrderModuleList`: A linked list that organizes modules in the order in which they **appear in the process’ virtual memory layout**. \n\n  > For example, the last DLL to load may end up at a lower base address than the first (due to address space layout randomization [ASLR] and other factors). \n\n* `InInitializationOrderModuleList`: A linked list that organizes modules **in the order in which their `DllMain` function was executed**.\n\n  > This is different from the load order list because a module’s DllMain isn’t always called immediately when it loads. Sometimes it’s never called, for example when you load a DLL as a data file or image resource (see the `dwFlags` parameter to `LoadLibraryEx`).\n\n\n\nThe `_LDR_DATA_TABLE_ENTRY` structure:\n\n![image-20200310181813866](https://tva1.sinaimg.cn/large/00831rSTly1gcp02m453hj30np0980uc.jpg)\n\nKey Points:\n\n* `DllBase` : This is the base address of the module in process memory.\n\n* `EntryPoint`: The first instruction executed by the module. In most cases, it is taken from the PE file’s `AddressOfEntryPoint` value.\n\n* `SizeOfImage`: The size of the module, in bytes.\n\n* `FullDllName`: The full path to the module’s file on disk (for example, `C:\\Windows\\ System32\\kernel32.dll`).\n\n* `BaseDllName` : The base portion of the module’s filename (for example, `kernel32.dll`).\n\n* `LoadCount`: **The number of times** `LoadLibrary` was called for the module. **It is used as a reference count to know when it is safe to unload a DLL from process memory**. You’ll see this value later in the chapter to determine how a DLL was loaded (via the import address table [IAT] or an explicit call to LoadLibrary).\n\n\n\n#### >> Process Heap\n\nWhen you dump process memory via `memdump` or `vaddump`, you inevitably get the heap contents(at least the pages that are not swapped). However, you won't necessarily know which offsets in your dump file or signature results correspond to heap regions.\n\nBut in some cases you might want to analyze only heap memory.\n\n\n\n**Scenario:**\n\nSuppose we are investigating some suspects' notepad that is recorded something for crime as below:\n\n![image-20200310195417879](https://tva1.sinaimg.cn/large/00831rSTly1gcp2ukdyslj30og0ih11a.jpg)\n\nWe may obtain the memory dump from the suspects'system. Though we could use `vadinfo` or `vadtree` on the notepad process, we'll see 50+ VAD tress and its hard to analyze. The goal is to obtain the texts by pressing keyboard and we only need to analyze the heap.\n\nWe can use `heaps` plugin to layout the heap:\n\n```\npython vol.py -f Win2K3SP1x86.vmem --profile=Win2003SP1x86 heaps -p 3988\n```\n\n![image-20200310195057283](https://tva1.sinaimg.cn/large/00831rSTly1gcp2r38zxjj30o40jun0s.jpg)\n\n> As shown, two chunks stood out because the “`extra`” flag is displayed. In other words, the `HEAP_ENTRY_EXTRA_PRESENT` flag was set in the `_HEAP_ENTRY.Flags` member for these two chunks.\n\nRegardless of the actual meaning of the `extra` flag, we got two chunks at `0xa8028` and `0xac7b0`.\n\nWe could access the memory by `volshell` below.\n\n```\npython vol.py -f Win2K3SP1x86.vmem --profile=Win2003SP1x86 volshell -p 3988\n```\n\n![image-20200310195925790](https://tva1.sinaimg.cn/large/00831rSTly1gcp2zwsgpoj30nr081q4j.jpg)\n\n#### >> Environment Variables\n\nA process’ environment variables are pointed to by `_PEB.ProcessParameters.Environment`. The variables are organized as multiple NULL-terminated strings, similar to a `REG_MULTI_SZ` value in the registry.\n\n> If an attacker manipulates these variables, they can cause the target application to unexpectedly execute a malicious process. Additionally, some malware marks its presence by creating environment variables rather than mutexes.\n\nHere are some scopes of environment variables:\n\n![image-20200310200449010](https://tva1.sinaimg.cn/large/00831rSTly1gcp35ifgnuj30oj063q3u.jpg)\n\nThe System and User variables are both persistent in the registry. Thus, you can enumerate them by parsing registry hive files that were acquired from disk.\n\n> When a process is created, it usually inherits the environment block from its parent. The parent process can override this default behavior by specifying the `lpEnvironment` parameter when it calls `CreateProcess`.\n\nYou can find these types of data in environment variables:\n\n* Paths to executable programs (PATH) \n* Extensions assigned to executable programs (PATHEXT) \n* Paths to temporary directories \n* Paths to a user’s Documents, Internet History, and Application Data folders \n* User names, computer names, and domain names \n* The location of cmd.exe (ComSpec)\n\n\n\n#### >> Attacks on Environment variables\n\nThe two most common types of attacks on environment variables include changing the `PATH` and `PATHEXT` variables.\n\n```shell\nPATH=C:\\windows;C:\\windows\\system32 PATH=C:\\Users\\HR101\\.tmp;C:\\windows;C:\\windows\\system32\n```\n\nAn attacker could plant a file named calc.zzz in one of the searched directories, and it would be executed first:\n\n```shell\nPATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE\nPATHEXT=.ZZZ;.COM;.EXE;.BAT;.CMD;.VBS;.VBE\n```\n\n\n\n#### >> Coreflood Presence Marking\n\nMany malware samples mark their presence on a system by creating globally accessible mutexes. This helps prevent accidental re-infection. Mutexes also provide a strong forensic indicator. Coreflood used environment variables for a very similar purpose—to mark its presence within a process.\n\n**Example:**\n\nHow many of the following processes are infected with Coreflood’s DLL?\n\n```\npython vol.py -f coreflood.img --profile=WinXPSP3x86 envars\n```\n\n![image-20200310214200342](https://tva1.sinaimg.cn/large/00831rSTly1gcp5yo7ra2j30o80mojuz.jpg)\n\nAnswer : 2\n\nAt first glance, it appears as if all four processes are infected, because they all contain suspicious variable names. \n\nHowever, we previously mentioned that **child processes typically inherit their parent’s variables**. We also said **the variable name depends on the PID of the process**. **If all four processes were infected, you’d see four unique variable names**; but you see only two (VFTPXXPYVTAMF and QBYXKDAGXM). \n\nThe last three processes (IEXPLORE.EXE, notepad.exe, and firefox.exe) were spawned by PID 1144, which explains why they have a copy of the VFTPXXPYVTAMF variable.\n\n\n\n#### >> Standard Handles\n\nBy analyzing a process' standard handles, you can determine where it gets input and where it sends output and error messages.\n\nThis is especially useful when investigating potential breaches by **remote attackers**.\n\n> A fairly common way to create a backdoor command shell on a system involves **spawning an instance of `cmd.exe` and redirecting its standard handles over named pipes or network sockets**. Thus, the attackers can use `telnet` or `netcat` to connect to the target machine (provided that no firewall is blocking access), and type commands as if they were sitting at the console.\n\n\n\n#### >> Dynamic Link Libraries(DLLs)\n\nDLLs contain code and resources that can be shared between multiple processes. They’re popular among malware and threat actors because DLLs are designed to run inside a host process, thus giving them access to all of the process’ resources: its threads, handles, and full range of process memory.\n\n\n\n***How DLLs Are Loaded***\n\n* `Dynamic linking`: As part of the process initialization routines, any DLL in the executable (.exe) file’s IAT(import address table) automatically loads in the process’ address space.\n* ` Dependencies`: DLLs also have import tables, so when they’re loaded, all additional DLLs on which they rely load into the process’ address space. For more information, see Dependency Walker (http://www.dependencywalker.com/).\n\n* `Run-time dynamic linking (RTDL)`: A thread can explicitly call `LoadLibrary` (or the native `LdrLoadDll`) with the name of the DLL to load. This has the same end result as dynamic linking (a DLL loaded in the process), except there’s no trace of the DLL in the process’ IAT.\n\n* `Injections`: As you’ll learn later in the chapter, DLLs can also be forcefully injected into a target process.\n\n\n\n***Hiding DLLs***\n\nall three lists exist in process memory, any thread running in the process can unlink a metadata structure ( `_LDR_DATA_TABLE_ENTRY`) to hide it from the running system (and potentially memory forensics as well). For example, once loaded, the xyz.dll module can overwrite its own Flink and Blink pointers so that its entry is skipped during enumeration.\n\n![image-20200310224506418](https://tva1.sinaimg.cn/large/00831rSTly1gcp7samwu0j30p20gmdhb.jpg)\n\n\n\n***Listing DLLs in Memory***\n\nWe design `dlllist` plugin: enumerating DLLs by **walking the load order list.**  Thus The unlinking approach depicted in diagram above also affects Volatility’s dlllist plugin.\n\n```\npython vol.py –f mem.dmp --profile=WinXPSP3x86 dlllist –p 3108\n```\n\n![image-20200310225126658](https://tva1.sinaimg.cn/large/00831rSTly1gcp7yvtzq4j30ny0gigph.jpg)\n\n> The process executable (`notepad.exe`) is first to load in the process address space, thus it’s first in the load order list. Next, the `ntdll.dll` and `kernel32.dll` system libraries are loaded. The system then proceeds to load any DLLs in Notepad’s IAT and any dependency modules that those DLLs need.\n\nHowever, that the load count for the first batch of modules is 0xffff. Because this field is a short integer, **0xffff is actually -1**. A load **count of -1 means the DLL loaded because it was specified in an IAT**. (The others near the end, whose load counts are 0x3, 0x27, 0x4 and 0x1, were all loaded via explicit calls to `LoadLibrary`)\n\nAlthough there are plenty of legitimate reasons to call LoadLibrary, **its usage is also consistent with the techniques shellcode uses to set up the target process’ address space**. You may notice none of the explicitly loaded DLLs are suspicious per se—they’re all properly named and in the correct system32 path. \n\nHowever, when you consider their purpose (network related) and the host process context (notepad.exe), the situation begins to look quite abnormal. Most likely code needing access to networking DLLs has infected this process, and it loads them by calling `LoadLibrary`.\n\n\n\n***Detecting Unlinked DLLs***\n\nTwo methods can help you detect DLLs that are unlinked from all three lists:\n\n* `PE file scanning`: You can leverage techniques described in Chapter 7 to perform a brute force scan through process memory, **looking for all instances of PE files (based on their known MZ header signatures)**. \n\n  Remember, however, that the **PE headers are also in process memory**, so the same body of code that unlinks the DLL metadata structure can easily overwrite them.\n\n* `VAD cross-referencing`: This is the technique implemented by Volatility’s `ldrmodules` plugin. If you recall from Chapter 7, **VAD nodes contain full paths on disk to files mapped into the regions—including DLL files**. \n\n  The unique aspect of VADs is that **they exist in kernel memory** and attempts to manipulate the tree (i.e., unlink a VAD node) or overwrite their file pointers quickly result in system instability (blue screens).\n\n\n\nWe can use `ldrmodules` plugin\n\n* First enumerates all VAD nodes that contain mapped executable images. Specifically, **it looks for large nodes with `PAGE_EXECUTE_WRITECOPY` protections, a `VadImageMap` type, and the Image control flag set.**\n*  It then compares **the starting addresses from the VAD nodes** with the **`DllBase` value from the `_LDR_DATA_TABLE_ENTRY` structures found in process memory**. \n* Entries identified through the VAD that aren’t represented in the DLL lists are potentially hidden.\n\n```\n$ python vol.py -f memory.dmp --profile=Win7SP1x64 ldrmodules -p 616\n```\n\n![image-20200310232557769](https://tva1.sinaimg.cn/large/00831rSTly1gcp8ysqshhj30o70djq6o.jpg)\n\n\n\n### > PE Files in Memory\n\n* Volatility can dump and rebuild PE files.\n\n* **Due to changes that occur during program execution, it's hard for you to get an exact copy of the original binary or even one that runs on another machine.**\n\nDumping an executable and compare its MD5 or SHA1 hash to the file on disk is also not likely possible.\n\nAnother reason why PE files dumped from memory often differ from the original file on disk is because of slack space:\n\n\n\n***PE File Slack Space***\n\nThe smallest page size on a typical x86 or x64 Windows system is 4,096 bytes. Most PE files have sections that are not exact multiples of the smallest page size.\n\n![image-20200311010829443](https://tva1.sinaimg.cn/large/00831rSTly1gcpbxhgloaj30h20ay3zi.jpg)\n\nAs the diagram above, the .text section, which is not an exact multiple of 4,096, must fully exist in memory marked as RX (read, execute), and the .data section must fully exist in memory marked as RW (read, write).\n\n> Because **protections are applied at the page level** (in other words, if a page is marked as executable, all bytes in the page are executable)---\n>\n> That the two sections must **be separated after being loaded into memory**. Otherwise, the beginning of the .data section ends up being RX instead of RW.\n\n\n\n#### >> Parsing PE Headers in Memory\n\nIt can be described as following steps:\n\n* using volatility to attach the certain process and launch volshell\n\n```\npython vol.py -f memory.dmp --profile=Win7SP1x64 volshell -p 516\n```\n\n* get the `process.peb` and `ImageBaseAddress`\n\nLet's take a review, `ImageBaseAddress` in PEB is **the address in process memory where the main executable (.exe) is loaded**. Take a look at `ImageBaseAddress` below:\n\n![image-20200311095415129](https://tva1.sinaimg.cn/large/00831rSTly1gcpr4j5amgj30nx02fmxb.jpg)\n\nWe can see `MZ(4d5a)` signature appears first.\n\n* get `NT` header\n\nWe could create an `_IMAGE_DOS_HEADER` at the base address we first got and use the `get_nt_header` function.\n\n![image-20200311100253259](https://tva1.sinaimg.cn/large/00831rSTly1gcprdirfx8j30o2083q46.jpg)\n\n* then print sections in PE\n\n![image-20200311100844130](https://tva1.sinaimg.cn/large/00831rSTly1gcprjm0fvvj30ny06jdgl.jpg)\n\n\n\n#### >> PE Extraction Plugins\n\nWe have shown in previous the whole process of extracting PE file to memory. Then there are some plugins that can automate the process:\n\n* `procdump`: Dump a process executable. You can identify the process by PID (`--pid`) or the physical offset of its `_EPROCESS` (`--offset`). \n\n  > The latter option enables you to dump processes hidden from the active process list.\n\n* `dlldump`: Dump a DLL. You can identify the host process by PID ( `--pid`) or the physical offset of its `_EPROCESS` (`--offset`). \n\n  > If the DLL(s) are in the load order list, you can identify them using a regular expression (`--regex/--ignore-case`) on their name. Otherwise, you can refer to them by their base address in process memory (`--base`). The latter option enables you to dump hidden or injected PE files. \n\n* `moddump`: **Dump a kernel module**. \n\nAll the plugins require an output directory (`--dump-dir`) to write the extracted files.\n\nThey also all accept an optional `--memory` parameter, which is how you request the slack space between sections to be included in the output file.\n\n\n\n**Examples:**\n\n* `procdump`\n\n```\n$ python vol.py -f memory.dmp --profile=Win7SP1x64 procdump --dump-dir=OUTDIR/\n```\n\n![image-20200311102633430](https://tva1.sinaimg.cn/large/00831rSTly1gcps251gtmj30nz07cmy9.jpg)\n\n> Notice the name of the output file is based on the PID of the process (`executable.PID.exe`).\n\nWe can extract a process that's not in the active process list based on the physical offset of its `_EPROCESS` **(which you can get with psscan or psxview)**:\n\n![image-20200311104526554](https://tva1.sinaimg.cn/large/00831rSTly1gcpslsm7c6j30o606a0ti.jpg)\n\n* `dlldump`\n\nextract any DLL from PID 1408 that has a name or path matching \"crypt\" string:\n\n![image-20200311105130051](https://tva1.sinaimg.cn/large/00831rSTly1gcpss3ljovj30o408k75u.jpg)\n\n> output files are named according to the PID and physical offset of the host process and the base virtual address of the DLL (module.PID. OFFSET.ADDRESS.dll)\n\n\n\nBut to dump DLLs hidden or injected we should use `--base` the base address where the DOS header exists:\n\n![image-20200311105642004](https://tva1.sinaimg.cn/large/00831rSTly1gcpsxijalsj30o706j3zd.jpg)\n\n\n\n***Caveats***\n\nOne thing to note about these plugins is that they’re susceptible to attacks that manipulate PE header values. For example, **if the MZ or PE signature isn’t found, they cannot properly locate the sections**. Furthermore, they also rely on the advertised section virtual addresses and sizes, which malicious code can easily overwrite.\n\nIf you encounter issues dumping PE files from process memory, whether it’s the process executable or a DLL, you can always fall back to just dumping the containing VAD region.\n\n\n\n### > Code Injection\n\nThe way to detect code injection depends on how the code was injected.\n\n* **Remote DLL injection**: A malicious process forces the target process to load a specified DLL from disk by calling LoadLibrary or the native LdrLoadDll. By definition, the DLL must exist on disk prior to being injected.\n\n* **Remote code injection**: A malicious process writes code into the memory space of a target process and forces it to execute. The code can be a block of shellcode (i.e., not a PE file) or it can be a PE file whose import table is preemptively configured for the target process.\n\n* **Reflective DLL injection**: A malicious process writes a DLL (as a sequence of bytes) into the memory space of a target process. The DLL handles its own initialization without the help of the Windows loader. The DLL does not need to exist on disk prior to being injected.\n\n* **Hollow process injection**: A malicious process starts a new instance of a legitimate process (such as lsass.exe) in suspended mode. Before resuming it, the executable section(s) are freed and reallocated with malicious code.\n\nIn the following descriptions, ***Process A is the malicious process and Process B is the target.***\n\n\n\n#### >> *Remote DLL Injection*\n\n1. ProcessA **enables debug privilege**(`SE_DEBUG_PRIVILEGE`) as if it were a debugger, so that it can read and write other process' memory.\n2. ProcessA calls `OpenProcess` and **opens a handle to ProcessB** (also request `PROCESS_CREATE_THREAD`, `PROCESS_VM_OPERATION`, and `PROCESS_VM_WRITE`)\n3. ProcessA calls `VirtualAllocEx` to **allocate memory in ProcessB**\n4. ProcessA **transfers a string(identifies the full path on disk to the malicious DLL)** to ProcessB's memory by calling `WriteProcessMemory`.(writing at the address allocated in previous step)\n5. ProcessA calls `CreateRemoteThread` to **start a new thread in ProcessB that executes the `LoadLibrary` function**.\n6. Now the injection is complete and processB has loaded the DLL. ProcessA calls `VirtualFree` to free the memory containing the DLL's path.\n7. ProcessA calls `CloseHandle` on ProcessB's process to clean up.\n\n\n\n***Detection***\n\n`LoadLibrary` was used to load the DLL, there is no good way to conclusively distinguish between the malicious DLL and other explicitly loaded DLLs in ProcessB.\n\n> The VAD and PEB lists look nearly identical from a metadata perspective for all modules loaded with the same API. \n>\n> **In other words, the injected DLL isn’t necessarily hidden at this point**; it is perfectly visible with `dlllist` or tools such as Process Explorer running on the live system. However, unless you know the specific name of the DLL, it can easily blend in with the legitimate modules.\n\nThere are still two factors can make detection possible:\n\n* If the injected DLL does attempt to hide from tools on the live system after it gets loaded (by unlinking its `_LDR_DATA_TABLE_ENTRY` from one or more of the ordered lists), you can use `ldrmodules` to detect it.\n* If the injected DLL is packed, and the unpacking procedure copies the decompressed code to a new memory region. In this case, you’ll detect it with `malfind` (described next).\n\n\n\n#### >> *Remote Code Injection*\n\nIt starts out with the same two steps as remote DLL injection above.\n\n3. ProcessA **allocates memory in ProcessB with `PAGE_EXECUTE_READWRITE` protection**.(It can alloc ProcessA to write and ProcessB to read and execute it).\n4. ProcessA **transfer a block of code to ProcessB** using `WriteProcessMemory`.\n5. ProcessA calls `CreateRemoteThread` and points the thread's starting address to a function within the code.\n\n\n\n***Detection***\n\nWe could use `malfind` plugin(it is designed to hunt down remote code injections).\n\nThe concept is:\n\n* There will be a readable, writeable, and executable private memory region (that is, no file mapping) with all pages committed (we use a few variations of these criteria for detection). \n* The region will **contain a PE header and/or valid CPU instructions**.\n\n**Examples:**\n\n```\n$ python vol.py –f stuxnet.mem --profile=WinXPSP3x86 malfind\n```\n\n\n\n*case1 - obvious injected code with MZ signature*\n\n\n\n![image-20200311122718332](https://tva1.sinaimg.cn/large/00831rSTly1gcpvjs26njj30nx0dnwg5.jpg)\n\n> In some cases, you’ll leverage the hex dump to determine whether the region is malicious (for example, **because you see an MZ signature**); \n\nIn other cases, you’ll need to rely on the disassembly(no `MZ` signature):\n\n\n\ncase2 - unconspicuous injected code without MZ signature*\n\n\n\n![image-20200311152041422](https://tva1.sinaimg.cn/large/00831rSTly1gcq0k6tf7sj30o40dtwh1.jpg)\n\n> This region at 0x9d0000 is worth further investigation because the disassembly contains CPU instructions that make sense. For example, the `JMP` destinations are valid, and the combination of `MOV EDI, EDI` followed by `PUSH EBP` indicates the start of a function prologue.\n\n\n\n*case3 - normal code similar to injected code*\n\n\n\nThe following region in `csrss.exe` was not injected by malware, it was picked up by the plugin due to its similarity to injection regions:\n\n![image-20200311154500763](https://tva1.sinaimg.cn/large/00831rSTly1gcq19hzu1jj30o20bkabo.jpg)\n\nKeep in mind that programs may allocate executable private memory for legitimate reasons.\n\n> For example, there’s an `ENTER` instruction, but no `LEAVE`. There’s conditional jump (`JNO`), but no condition. Furthermore, the destination of the jump leads to 0x7f6f0007, an address that does not contain an instruction according to the current alignment.\n>\n> It is just meaningless.\n\n\n\n*case4 - hidden injected code with coreflood*\n\n\n\n![image-20200311155332478](https://tva1.sinaimg.cn/large/00831rSTly1gcq1idd58pj30o00csabu.jpg)\n\nMost analysts assume that this range at 0x7ff80000 is a false positive. The hex dump and disassembly both consist of only zeros. (**In this case, Coreflood’s antidumping feature wiped out its PE header (which occupied the first page) by overwriting it with zeros)**.\n\n However, remember that this is only a preview of the data. **The CPU doesn’t necessarily start executing code at offset 0 in the injected region; it can easily point somewhere within the range.**\n\nUse `volshell` to disassemble code in the seconde page we could see the main function:\n\n![image-20200311155607867](https://tva1.sinaimg.cn/large/00831rSTly1gcq1l279lfj30o70bjgnn.jpg)\n\n\n\n#### >> *Reflective DLL Injection*\n\nThis method is a hybrid of the two approaches discussed previously. \n\nThe content transferred from Process A to Process B is a DLL (as opposed to a block of shellcode), but after it exists in Process B, it initializes itself instead of calling `LoadLibrary`.\n\nIt has several anti-forensics advantages:\n\n* `LoadLibrary` only loads libraries from disk. **Because this method doesn’t rely on the API, the injected DLL never needs to be written to more permanent storage**. It can be loaded into memory straight from the network (for example, when exploiting a remote buffer overflow).\n\n* Also as a result of avoiding `LoadLibrary`, **the `_LDR_DATA_TABLE_ENTRY` metadata structures are not created**. Thus the **three lists in the PEB do not have a record of this DLL** loading.\n\n\n\n***Detection***\n\nFirst take a look at an example(a snippet of code) of Reflection DLL Injection project's `LoadLibraryR.c` file:\n\n```\n// alloc memory (RWX) in the host process for the image... \nlpRemoteLibraryBuffer = VirtualAllocEx( hProcess, NULL, dwLength,\n                           MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); \nif(!lpRemoteLibraryBuffer) \n   break;\n```\n\nDue to the options chosen during allocation, the VAD in the host process that contains the DLL fits the criteria for `malfind`.\n\nSo we can use `malfind`.\n\n\n\n#### >> *Hollow Process Injection*\n\nThe malware starts a new instance of a legitimate process, such as lsass.exe. Before the process’ first thread begins, the malware frees the memory containing the lsass.exe code (it hollows it out) and replaces it with the body of the malware.\n\n![image-20200311161409689](https://tva1.sinaimg.cn/large/00831rSTly1gcq23twd95j30oj0d0wfr.jpg)\n\n> PEB and various other data structures identify the path to the legitimate lsass.exe binary.(unchanged)\n\n***Hollow a process***\n\n1. Start a new instance of a legitimate process (for example, C:\\windows\\system32\\lsass.exe), but with its first thread suspended. \n\n   > At this point, the `ImagePathName` in the PEB of the new process identifies the full path to the legitimate lsass.exe.\n\n2. **Acquire the contents for the malicious replacement code**. This content can come from a file on disk, an existing buffer in memory, or over the network.\n\n3. Determine the base address (ImageBase) of the lsass.exe process, and then **free or unmap the containing memory section**. \n\n   > At this point, the process is just an empty container (the DLLs, heaps, stacks, and open handles are still intact, but no process executable exists).\n\n4. Allocate a new memory segment in lsass.exe and make sure that the memory can be read, written, and executed. \n\n   > You can reuse the same `ImageBase` or a different one\n\n5. Copy the PE header for the malicious process into the newly allocated memory in lsass.exe\n\n6. Copy each PE section for the malicious process into the proper virtual address in lsass.exe\n\n7. Set the start address for the first thread (the one that has been in a suspended state) to point at the malicious process’ AddressOfEntryPoint value.\n\n8. Resume the thread.\n\n   > The malicious process begins executing within the container created for lsass.exe. The ImagePathName in the PEB still points to C:\\windows\\system32\\lsass.exe.\n\n\n\n***Detection***\n\n\n\nFirst we can list all processes using `pslist`:\n\n![image-20200311165645526](https://tva1.sinaimg.cn/large/00831rSTly1gcq3c5jf4vj30oc05b758.jpg)\n\n> There are three processes (PID 680, 868, and 1928), but only one is the “real” lsass.exe. Intuition may tell you that the one that **started first based on creation time (PID 680) is the legitimate one**, but we’ll show you how to confirm.\n\nNow we can see `ImageBase` by `dlllist` for the processes:\n\n![image-20200311165841601](https://tva1.sinaimg.cn/large/00831rSTly1gcq3e5shgaj30o40a1myy.jpg)\n\n> The advertised paths are all the same (despite two having an extra set of quotes around the path) because the data in the PEB, including the `ImageBase`, is initialized at process creation, and all processes started out the same.\n\n\n\nHowever, as a result of being hollowed, the VAD characteristics for the region that contains the ImageBase are drastically different:\n\n![image-20200311165948460](https://tva1.sinaimg.cn/large/00831rSTly1gcq3fb9za5j30o00hi77u.jpg)\n\n![image-20200311165956271](https://tva1.sinaimg.cn/large/00831rSTly1gcq3fgk8bej30nz0b2dhu.jpg)\n\n> Only the legitimate one (PID 680) still has a copy of the lsass.exe file mapped into the region\n\n","tags":["memory forensics","notes"],"categories":["memory forensics"]},{"title":"手把手带你MIT6.828 - Lab2","url":"/2020/03/04/joslab2/","content":"\n# Lab2 Memory Management\n\n官方文档: [lectures](https://pdos.csail.mit.edu/6.828/2018/lec/)\n\n### > 实验介绍\n\n在本次实验中，我们将为操作系统编写内存管理代码。内存管理包括两个组件：\n\n1. 第一个是内核的物理内存分配器，它可以使内核分配并释放内存。我们的分配器以4096Bytes为单位进行操作，该单位称为页面（Page）。\n\n我们将维护一个数据结构，这个数据结构能够记录哪些物理pages是空闲的，哪些是已经分配的，以及多少个进程正在共享每个分配的页。同时我们需要编写程序来分配和释放内存页面。\n\n2. 第二个组件是虚拟内存(virtual memory)。它将内核与用户软件使用的虚拟内存映射到物理内存中的地址。当指令使用内存时，x86硬件的内存管理单元(MMU)执行这个映射过程。\n\n我们将根据规范来修改jos以设置MMU的页表。\n\n\n\n### > 实验准备\n\n根据官方网站的提示，将lab2分支进行merge，合并到lab1中。\n\n实验二包括如下的新文件：\n\n- inc/memlayout.h 描述了虚拟地址空间的结构\n- kern/pmap.c 需要修改、添加代码以完成实验\n- kern/pmap.h 定义了PageInfo结构 用来管理物理页状态\n- kern/kclock.h\n- kern/kclock.c 操作电池供电的时钟以及CMOS RAM硬件\n\n个人建议在实验之前再次对段/页式管理有所了解（附上链接）：\n\n80386内存的基本概念和方式：[Memory Organization](https://pdos.csail.mit.edu/6.828/2018/readings/i386/s02_01.htm)\n\n这个章节中包含了段/页式管理，详细阅读：[Memory Management](https://pdos.csail.mit.edu/6.828/2018/readings/i386/c05.htm)\n\n\n\n## Part1: Physical Page Management\n\n操作系统必须追踪物理内存从而知晓哪些内存是空闲的，哪些内存是正在使用的。JOS使用页面粒度(page granularity)管理PC的物理内存，以便利用MMU映射和保护每一片被分配的内存。\n\n首先我们**需要实现一个物理内存分配器**(physical page allocator)。它将根据`struct PageInfo`链表进行空闲页面的追踪。\n\n注意：**我们必须先实现物理页分配器**，然后才能编写其余的虚拟内存实现。因为我们的页表管理代码将需要**分配用于储存页表的物理内存**。\n\n在继续之前，我们仍然需要一些背景知识，这可能仍然有些painful...\n\n### > bootloader读入kernel后的内存分布\n\n![image-20200304125040479](https://tva1.sinaimg.cn/large/00831rSTly1gchsvxxlc1j30j505qmy1.jpg)\n\n上图的代码是kernel刚刚被读入内存，还没有开启保护方式的结构。\n\n#### >> 回顾Lab1\n\n通过lab1，我们知道了，jos启动的过程实际上就是把bootsector的内容读到了0x7c00的位置（注意：bootsector的代码在编译的时候已经故意将逻辑地址的首地址定在了0x7c00上），bootsector中的代码开始执行的时候会从磁盘上紧接着自己的第二个扇区开始一直读8个扇区(一共8x512 = 4K，ELF头的大小)一直到0x10000(64KB)的地方，然后通过对ELF头的解析，得到kernel模块编译出来之后占的大小，并将kernel读到物理内存0x100000(1MB)的地方。然后设置好GDT并且调用`i386_init()`函数，而`i386_init()`函数将在自己的BSS区域清零后，调用`cons_init()`函数设置好屏幕显示设备为cprintf的运行做好准备。\n\n之后就会调用`i386_detect_memory()`函数和`i386_vm_init()`函数。前者的主要功能是读CMOS取得物理内存的实际大小，后者是本次lab的主要函数，将在之后进行讨论。当然`i386_init()`最后会调用`monitor(NULL)`，进入循环处理用户终端的交互。\n\n调用`i386_init()`之后，系统将会重载GDT，新的GDT：\n\n![image-20200304144728023](https://tva1.sinaimg.cn/large/00831rSTly1gchw9gn2sdj30h002i0sy.jpg)\n\n**新的GDT后两项的base是-KERNBASE**。如果KERNBASE=0xf0000000，则GDT的base为0x00100000，通过保护模式的段式地址转换机制(pa = la+base)，将程序内的KERNBASE开始的逻辑地址转换成物理地址。\n\n### > JOS分段和分页\n\n同时我们需要知道JOS是如何使用分段和分页的：[How we will use paging (and segments) in JOS](https://pdos.csail.mit.edu/6.828/2018/lec/l-josmem.html\n\n虚拟内存是将很小的物理内存映射到很大的虚拟内存空间，这个映射关系需要一个输入地址和一个输出地址才能作用。**物理地址**是物理内存中真实的地址，可以直接由硬件寻址得到；**虚拟地址/线性地址**是物理地址通过转换得到的，用于虚拟内存空间索引的地址。\n\n![image-20200304125540629](https://tva1.sinaimg.cn/large/00831rSTly1gcht15732bj30hk0cl0st.jpg)\n\n`mmu.h`对我们线性地址的结构有了详细的描述：\n\n```c\n// A linear address 'la' has a three-part structure as follows:\n//\n// +--------10------+-------10-------+---------12----------+\n// | Page Directory |   Page Table   | Offset within Page  |\n// |      Index     |      Index     |                     |\n// +----------------+----------------+---------------------+\n//  \\--- PDX(la) --/ \\--- PTX(la) --/ \\---- PGOFF(la) ----/\n//  \\---------- PGNUM(la) ----------/\n//\n// The PDX, PTX, PGOFF, and PGNUM macros decompose linear addresses as shown.\n// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),\n// use PGADDR(PDX(la), PTX(la), PGOFF(la)).\n```\n\n我们的线性地址分为三段：\n\n- `Page directory index`：页目录的序号(10位) -> 2^10个页表\n- `Page table index`：页表的序号(10位) -> 2^10页\n- `Page offset`：地址在页内的偏移(12位) -> 2^12 = 4K\n\n也就是说，每个页表有1024个页，每个页目录有1024个页表，每一页的大小是4KB。\n\n`memlayout.h`中可以看整个虚拟内存空间的分配：\n\n```c\n/*\n * Virtual memory map:                                Permissions\n *                                                    kernel/user\n *\n *    4 Gig -------->  +------------------------------+\n *                     |                              | RW/--\n *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *                     :              .               :\n *                     :              .               :\n *                     :              .               :\n *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--\n *                     |                              | RW/--\n *                     |   Remapped Physical Memory   | RW/--\n *                     |                              | RW/--\n *    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+\n *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |\n *                     | - - - - - - - - - - - - - - -|                   |\n *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |\n *                     +------------------------------+                   |\n *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |\n *                     | - - - - - - - - - - - - - - -|                 PTSIZE\n *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |\n *                     +------------------------------+                   |\n *                     :              .               :                   |\n *                     :              .               :                   |\n *    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+\n *                     |       Memory-mapped I/O      | RW/--  PTSIZE\n * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000\n *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE\n *    UVPT      ---->  +------------------------------+ 0xef400000\n *                     |          RO PAGES            | R-/R-  PTSIZE\n *    UPAGES    ---->  +------------------------------+ 0xef000000\n *                     |           RO ENVS            | R-/R-  PTSIZE\n * UTOP,UENVS ------>  +------------------------------+ 0xeec00000\n * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE\n *                     +------------------------------+ 0xeebff000\n *                     |       Empty Memory (*)       | --/--  PGSIZE\n *    USTACKTOP  --->  +------------------------------+ 0xeebfe000\n *                     |      Normal User Stack       | RW/RW  PGSIZE\n *                     +------------------------------+ 0xeebfd000\n *                     |                              |\n *                     |                              |\n *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *                     .                              .\n *                     .                              .\n *                     .                              .\n *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n *                     |     Program Data & Heap      |\n *    UTEXT -------->  +------------------------------+ 0x00800000\n *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE\n *                     |                              |\n *    UTEMP -------->  +------------------------------+ 0x00400000      --+\n *                     |       Empty Memory (*)       |                   |\n *                     | - - - - - - - - - - - - - - -|                   |\n *                     |  User STAB Data (optional)   |                 PTSIZE\n *    USTABDATA ---->  +------------------------------+ 0x00200000        |\n *                     |       Empty Memory (*)       |                   |\n *    0 ------------>  +------------------------------+                 --+\n *\n * (*) Note: The kernel ensures that \"Invalid Memory\" is *never* mapped.\n *     \"Empty Memory\" is normally unmapped, but user programs may map pages\n *     there if desired.  JOS user programs map pages temporarily at UTEMP.\n */\n```\n\n- `0xf0000000`以上：`Remapped physical memory`，物理内存的原样映射，这一部分为虚拟地址\n- `0xefc00000`以上：内核栈区域，存放各个CPU的内核栈。\n  - `0xef800000`：`ULIM`，内核内存区和用户内存区的分界线，这以上用户不可读写\n- `0xef400000`以上：页表区域\n  - `0xef400000`：`UVPT`，页表区域的开始。\n- `0xef000000`以上：页区域\n  - `0xef000000`：`UPAGES`，页区域的开始。\n- `0xeec00000`以上：当前进程的环境变量区域\n  - `0xeec00000`：`UTOP`，用户只读区和读写区的分界线，这以上到`ULIM`之间用户只有读权限\n- ``0xeebff000 1 PGSIZE`：用户的异常栈\n- `0xeebfe000 一段留空内存`\n- `0xeebfd000 1 PGSIZE`：用户栈，可以增长\n- `0x00800000`以上：用户的堆区域和程序数据\n- 以下：用户的符号表区域和空内存\n\n**exercise 1:**\n\n我们需要实现`kern/pmap.c`中的以下函数：\n\n```c\nboot_alloc()\nmem_init()   //（完成直到调用check_page_free_list(1)为止）\npage_init()\npage_alloc()\npage_free()\n```\n\n完成后，我们可以在boot jos的过程中使用`check_page_free_list()`以及`check_page_alloc()`来检查我们的物理内存分配器。\n\ntips：使用assert()进行断言验证。\n\n* `boot_alloc()`\n\n这个函数的解释是，**建立在虚拟内存系统过程中用来为数据结构分配内存空间**。\n\n值得注意的是，`end`变量是在`kernel.ld`中的`.bss`段定义的，也就是说其**首次调用的时候，从内核的bss段结束处分配一个内存块。**\n\n这个bss段在虚拟地址空间`0xf0000000`以上的部分，也就是上图中**物理地址的直接映射区**。从这个地方开始，我们就开始建立用于管理虚拟内存的内核数据结构：\n\n```c\n// This simple physical memory allocator is used only while JOS is setting\n// up its virtual memory system.  page_alloc() is the real allocator.\n//\n// If n>0, allocates enough pages of contiguous physical memory to hold 'n'\n// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.\n//\n// If n==0, returns the address of the next free page without allocating\n// anything.\n//\n// If we're out of memory, boot_alloc should panic.\n// This function may ONLY be used during initialization,\n// before the page_free_list list has been set up.\nstatic void *\nboot_alloc(uint32_t n)\n{\n\tstatic char *nextfree;\t// virtual address of next byte of free memory\n\tchar *result;\n\n\t// Initialize nextfree if this is the first time.\n\t// 'end' is a magic symbol automatically generated by the linker, <-在kernel.ld中\n\t// which points to the end of the kernel's bss segment:\n\t// the first virtual address that the linker did *not* assign\n\t// to any kernel code or global variables.\n\tif (!nextfree) {\n\t\textern char end[];\n\t\tnextfree = ROUNDUP((char *) end, PGSIZE);\n\t}\n\t// Allocate a chunk large enough to hold 'n' bytes, then update\n\t// nextfree.  Make sure nextfree is kept aligned\n\t// to a multiple of PGSIZE.\n\t//\n\t// LAB 2: Your code here.\n\t//return address of next free page\n\tif(n ==0){\n\t\treturn nextfree;\n\t}\n\t//allocate\n\tresult = nextfree;\n\tnextfree = ROUNDUP((char *)(nextfree + n), PGSIZE);\n\treturn result;\n}\n```\n\n* `mem_init()`\n\n这个函数一上来就调用`boot_alloc()`分配了一页的空闲内存并且初始化，该区域的指针为`kern_pgdir`，换句话说**这就是我们的页目录**`page directory`。\n\n接下来我们需要做的工作是为页数组`pages`分配虚拟内存，`pages`以及其数据结构的定义如下：\n\n```c\n/*\n * Page descriptor structures, mapped at UPAGES.\n * Read/write to the kernel, read-only to user programs.\n *\n * Each struct PageInfo stores metadata for one physical page.\n * Is it NOT the physical page itself, but there is a one-to-one\n * correspondence between physical pages and struct PageInfo's.\n * You can map a struct PageInfo * to the corresponding physical address\n * with page2pa() in kern/pmap.h.\n */\nstruct PageInfo {\n\t// Next page on the free list.\n  //pp_link 是下一项地址\n\tstruct PageInfo *pp_link;\n\n\t// pp_ref is the count of pointers (usually in page table entries)\n\t// to this page, for pages allocated using page_alloc.\n\t// Pages allocated at boot time using pmap.c's\n\t// boot_alloc do not have valid reference count fields.\n\t//pp_ref 是引用数量，凡是调用page_alloc 分配了该页的进程都会引用\n\tuint16_t pp_ref;\n};\n\nstruct PageInfo *pages;\t\t// Physical page state array\nsize_t npages;\t\t\t// Amount of physical memory (in pages)\n\t\t\t\t\t\t\t\t\t\t//npages在kernel中i386_detect_memory的时候被赋值\n```\n\n也就是说，`PageInfo`该结构体就是一个能够与物理内存映射的页面。`pages`数组就是每一个分页的信息，可以通过函数将其转换成物理地址，换句话说该数组中的每一个元素都映射到一个物理页面。我们这里就将所有物理内存做一个到pages中的映射。\n\n我们直接调用`boot_alloc()`即可。\n\n```c\n\t//////////////////////////////////////////////////////////////////////\n\t// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.\n\t// The kernel uses this array to keep track of physical pages: for\n\t// each physical page, there is a corresponding struct PageInfo in this\n\t// array.  'npages' is the number of physical pages in memory.  Use memset\n\t// to initialize all fields of each struct PageInfo to 0.\n\t// Your code goes here:\n\tn = npages * sizeof(struct PageInfo);\n\tpages = (struct PageInfo *)boot_alloc(n);\n\tmemset(pages, 0, n);\n```\n\n该步骤完毕后，所有的物理内存都已经按照页面大小划分成了页面，并依次存放在了pages中。\n\n* `page_init()`\n\n我们刚才已经为页表数组分配了空间并初始化，这一步我们需要初始化页的数据结构以及**初始化能够分配的空闲物理空间页的链表(memory free list)**。\n\n原始代码已经给出了，但是我们需要将其进行修改，因为该代码将所有物理内存页都标记为free，这就导致一些问题：\n\n1. 物理页面0处应该是used，这部分保存着实模式的IDT和BIOS的数据结构，这些结构我们可能之后还会用到。\n2. 还记得lab1中为了向后兼容8086而留下的`I/O hole`吗？这一部分内存是不能够被使用的，也就不能标记为free。\n3. `I/O hole`之后的extended memory（从`0x00100000`(1MB)开始，参考lab1笔记的`PC物理空间`部分），这些内存中有一部分被kernel占用了，存放kernel的代码和数据结构，不能被标记为free。\n\n对于可用的空间，我们有`npages_basemem`，这是在如下的`i386_detect_memory`函数detect内存时确定的：\n\n```c\nstatic void\ni386_detect_memory(void)\n{\n\tsize_t basemem, extmem, ext16mem, totalmem;\n\n\t// Use CMOS calls to measure available base & extended memory.\n\t// (CMOS calls return results in kilobytes.)\n\tbasemem = nvram_read(NVRAM_BASELO);\n\textmem = nvram_read(NVRAM_EXTLO);\n\text16mem = nvram_read(NVRAM_EXT16LO) * 64;\n\n\t// Calculate the number of physical pages available in both base\n\t// and extended memory.\n\tif (ext16mem)\n\t\ttotalmem = 16 * 1024 + ext16mem;\n\telse if (extmem)\n\t\ttotalmem = 1 * 1024 + extmem;\n\telse\n\t\ttotalmem = basemem;\n\n\tnpages = totalmem / (PGSIZE / 1024);\n\tnpages_basemem = basemem / (PGSIZE / 1024);\n\n\tcprintf(\"Physical memory: %uK available, base = %uK, extended = %uK\\n\",\n\t\ttotalmem, basemem, totalmem - basemem);\n}\n\n```\n\n这里的重点就是，如何知道extended memory起始的哪部分区域被kernel占用？实际上我们可以调用`boot_alloc(0)`得知我们分配的页目录的最后的区域，这个区域之后就全是空闲了。\n\n最终我们完成的`page_init()`如下：\n\n```c\nvoid\npage_init(void)\n{\n\t// The example code here marks all physical pages as free.\n\t// However this is not truly the case.  What memory is free?\n\t//  1) Mark physical page 0 as in use.\n\t//     This way we preserve the real-mode IDT and BIOS structures\n\t//     in case we ever need them.  (Currently we don't, but...)\n\t//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)\n\t//     is free.\n\t//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must\n\t//     never be allocated.\n\t//  4) Then extended memory [EXTPHYSMEM, ...).\n\t//     Some of it is in use, some is free. Where is the kernel\n\t//     in physical memory?  Which pages are already in use for\n\t//     page tables and other data structures?\n\t//\n\t// Change the code to reflect this.\n\t// NB: DO NOT actually touch the physical memory corresponding to\n\t// free pages!\n\tsize_t i;\n\t// for (i = 0; i < npages; i++) {\n\t// \tpages[i].pp_ref = 0;\n\t// \tpages[i].pp_link = page_free_list;\n\t// \tpage_free_list = &pages[i];\n\t// }\n\t// 跳过page[0]，分配npages_basemem数量\n\tfor (i = 1; i < npages_basemem; i++){\n\t\tpages[i].pp_ref = 0;\n\t\tpages[i].pp_link = page_free_list;\n\t\tpage_free_list = &pages[i];\n\t}\n\t// 无视I/O hole，这部分之前使用了npages_basemem所以不用操作\n\t// 从extended_memory的kernel使用之后的位置开始分配\n\t\t\t// 首先取出最后一块目录项的地址\n\tphysaddr_t next_page = PADDR(boot_alloc(0));\n\t\t\t// 得到索引\n\tsize_t idx_free = next_page / PGSIZE;\n\tfor(i = idx_free; i < npages; i++){\n\t\tpages[i].pp_ref = 0;\n\t\tpages[i].pp_link =page_free_list;\n\t\tpage_free_list = &pages[i];\n\t}\n}\n```\n\n这一步完成之后，我们就已经配置好了一个`page_free_list`，也就是说我们初始化了一个物理内存的所有可用空间页的链表。\n\n* `page_alloc()`\n\n这个函数的作用很简单，就是请求页面，即从`page_free_list`中分配一个空闲的主存页，我们只需要按照注释实现功能。\n\n```c\nstruct PageInfo *\npage_alloc(int alloc_flags)\n{\n\t// Fill this function in\n\tstruct PageInfo * alloc_page = page_free_list;\n\tif(!page_free_list){\n\t\treturn NULL;\n\t}\n\t// move page_free_list\n\tpage_free_list = page_free_list -> pp_link;\n\t// init free page\n\talloc_page -> pp_link = NULL;\n\tif(alloc_flags & ALLOC_ZERO){\n    // page2kva 是将输入的PageInfo结构体转换成对应的pages[]虚拟地址\n    //（因为pages都是通过boot_alloc分配在kernel区，所以是kva）\n    // kva 是kernel virtual address的缩写\n\t\tmemset(page2kva(alloc_page), 0, PGSIZE);\n\t}\n\treturn alloc_page;\n}\n```\n\n这个部分完成后，我们就实现了分配空闲内存页的操作。\n\n* `page_free()`\n\n同样这个函数就是字面意思，释放一块空闲页。\n\n```c\n//\n// Return a page to the free list.\n// (This function should only be called when pp->pp_ref reaches 0.)\n//\nvoid\npage_free(struct PageInfo *pp)\n{\n\t// Fill this function in\n\t// Hint: You may want to panic if pp->pp_ref is nonzero or\n\t// pp->pp_link is not NULL.\n\tif(pp -> pp_ref){\n\t\tpanic(\"[page_free] page : %p is still being used\", pp);\n\t}\n\telse if(pp -> pp_link){\n\t\tpanic(\"[page_free] page : %p is already freed\", pp);\n\t}\n\tpp -> pp_link = page_free_list;\n\tpage_free_list = pp;\n}\n```\n\n\n\n## Part2: Virtual Memory\n\n**exercise 2: **\n\n阅读[Intel 80386 Reference Manual](https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm)第五章以及第六章。这两章的主要内容都是段式和页式管理的方式，以及80386的保护模式。关键内容将在下面呈现：\n\n### > 段式管理-Segment\n\n回顾一下lab1中我们介绍了段式管理的基本流程：程序首先将对应的**段选择子（数组索引）加载到段寄存器**中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，然后**根据段寄存器的段选择子再确定最终要使用的段描述符**。结合段描述符中包含的信息加上指令自身的地址构造出实际的物理地址。\n\n可能这段话有些抽象，我们需要详细说明这个过程。\n\n#### >> 描述符(Descriptors)\n\n在分段保护方式下，**每一个段都需要很多相应的描述信息（包括但不限于段基址、段大小、特权级等）**，描述符是用来统一的描述这些数据。注意：描述符是由编译器、链接器、加载器或者操作系统创建的，而非应用程序的程序员创建的。\n\n对于一个描述符（`64位`），我们将其分为4个16位（蓝色标记），其结构如图：\n\n![image-20200305101256359](https://tva1.sinaimg.cn/large/00831rSTly1gcity4nq0jj30hg0bpwer.jpg)\n\n* 第一个16位：段界限（segment limit）。段界限用于限定段的大小，但是要注意的是段界限实际上有20位，它需要和描述符中另一段4bits的数据拼接（如上图）。\n* 第二个16位：段基址（segment base）。段基址用于描述段在虚拟地址的起始地址。同样显然虚拟地址应该是32位的，它也需要和描述符中的其他数据位拼接（如上图）\n* 第三个16位：\n  * `P`：**存在位**，表示该描述符对应的段是否已经读入内存。\n  * `DPL`：长度为两位，表示该段所属的特权级\n  * `1`或`0`：记录段的类型是存储段还是系统段\n  * `TYPE`：记录段的属性\n    - 如果是存储段，那么是代码段还是数据段\n    - 段的读写权限如何\n  * `A`：访问位，记录段是否被访问过\n\n* 第四个16位：\n  * `G`：**粒度位**，G=0说明段长度的单位是`Byte`，而G=1说明单位是`page`。\n  * `X`：用于区分32位和16位访问方式。\n  * `O`和`AVL`：保留位和系统专用位\n  * `LIMIT`：段界限的16-19位\n\n这样，有了段描述符，我们就能描述一个段的全部信息。\n\n#### >> 段描述符表(Descriptor Table)\n\n顾名思义，段描述符表就是用来存储段描述符的数据结构，它是由8Bytes为一个单位的元素组成的数组。实际上有如下两种段描述符表：\n\n* LDT：局部描述符表。**每一个进程都有一个局部描述符表**，存放在系统的特定的位置。LDT中存有进程对应的代码以及数据段位置等信息。\n\n* GDT：全局描述符表。全局描述符表一定是存在且唯一的。他存放操作系统内核所使用的描述符以及所有系统段的描述符。同时可以通过GDT索引LDT。\n\n![image-20200305102057147](https://tva1.sinaimg.cn/large/00831rSTly1gciu6gqjzrj30h00czt8r.jpg)\n\n#### >> 描述符表寄存器(GDTR/LDTR)\n\n显然，描述符表寄存器是处理器用于定位GDT和LDT在内存中的位置的寄存器。\n\n```c\nstruct gdtr {\n\tu16 limite;    //描述符表的表限长\n\tu32 base;      //描述符表的基址\n} __attribute__ ((packed));\n```\n\n机器刚刚加电，或者处理器复位后，表基址被默认设置为0，而表限长默认设置为0xffff。在保护模式初始化的过程中，必须给GDTR加载新的值。可以使用lgdt指令为GDTR加载新的值。\n\n#### >> 段选择子(Selectors)\n\n段选择子（2Bytes）用于**选择特定的描述符表以及表中特定的描述符**。段选择子一般都是被放置于段寄存器中，段选择子由**13位的索引**、**1位的表指示位**以及**2位的请求特权级**三部分组成。其中**索引指定了描述符**；**表指示位选择应该访问的描述符表**-0代表全局描述符表，1代表局部描述符表；**请求特权级用于段级的保护机制**，自0到4分别代表ring 0 到ring 3。结构体如下：\n\n```c\nstruct selector {\n    u16 index:13;      //用于指定描述符\n    u16 ti:1;          //用于访问描述符表 0-GDT   1-LDT\n    u16 rpl:2;         //请求特权级保护机制\n}\n```\n\n\n\n### > 页式管理(Pages)\n\n#### >> Linear Address\n\n对于虚拟地址的构成，再次将上文的图片搬上来：\n\n![image-20200305150546864](https://tva1.sinaimg.cn/large/00831rSTly1gcj2etkyucj30h507ft8n.jpg)\n\n#### >>页表(Page Tables)\n\n页表可以理解为是32bits的页说明符(Page specifiers)的数组。页表本身就是一页，就代表了它本身占用4KB的内存以及其中包含1KB的元素（每个页说明符元素占32-bits）。\n\n而80386可以采用多级页表，比如上图的二级页表。这种情况MMU在索引一个线性地址LA的时候，首先取出LA中的页目录DIR(高10位)，然后这种情况下`cr3`寄存器（也称为页目录基址寄存器page directory base register（PDBR））中存放的是当前页目录的首地址，通过DIR页目录的内容索引到LA所在的**页表首地址**。然后再通过LA中间部分的10位PAGE位（**页表索引部分**），根据DIR找到的页表首地址结合找到页表项。\n\n该过程中，页目录表项被称为DIR Entry，页表表项被称为Page Table Entry。结构在上图已经非常清晰。\n\n#### >>页表项(Page-Table Entries)\n\n无论是哪一级别的页表，其中的表项的形式都是相同的（无论是DIR Entry还是Page Table Entry），如下所示：\n\n![image-20200305152142276](https://tva1.sinaimg.cn/large/00831rSTly1gcj2ve1m96j30ft04zq2v.jpg)\n\n注：如果是两级页表，那DIR Entry(PDE)中的`page frame address`部分就是索引到的页表的地址，Page Table Entry(PTE)中的该部分则是索引到的物理页（page frame）。\n\n而最低12位就是权限位，表示该项的各种权限。其中最低位`P`（Present Bit）代表该entry项是否可以用于地址转换，如果为0则表示不可以使用。\n\n\n\n### 2.1 Virtual, Linear and Physical Addresses\n\nx86中，虚拟地址（virtual address）是由段选择子和段内偏移组成的（段式管理），而线性地址（linear address）是段翻译机制翻译后得到的地址，之所以该地址不能称为物理地址，是因为还未经过页翻译机制。线性地址经过页翻译之后，得到物理地址也就是内存的实际位置：\n\n![image-20200305153427296](https://tva1.sinaimg.cn/large/00831rSTly1gcj38nqj5yj30h403t74e.jpg)\n\n**在JOS中默认的boot过程中，我们通过boot.S设置了GDT，GDT中每个描述符的段基址base为0且段限长limit为0xffffffff，也就是说lab2中，我们不涉及内存的分段机制。**\n\n回忆lab1的part3：`kern/entrypgdir.c`将物理地址的0x00000000-0x00400000（`4M`）映射为虚拟地址0xf0000000-0xf0400000（`4M`），同时也将0x00000000-0x00400000的虚拟地址翻译为0x00000000-0x00400000。\n\n本实验中，我们要映射物理内存的最低256M到`0xf0000000`(KERNBASE)开始的虚拟地址。此外还要映射其它一些虚拟地址空间。\n\n**exercise 3:**\n\n我们首先进入qemu-gdb进入调试状态，输入`ctrl-a c`进入qemu monitor。在这里我们需要用到如下几条指令：\n\n```\nxp/Nx paddr -- 查看paddr物理地址处开始的，N个字的16进制的表示结果。\ninfo registers -- 展示所有内部寄存器的状态。\ninfo mem -- 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。\ninfo pg -- 展示当前页表的结构。\n```\n\ngdb的`x/Nx addr`指令是用来查看指定虚拟地址的数据的。\n\n我们这里将存在映射关系的虚拟地址与物理地址的内容进行对比，观察是否一致：\n\n![image-20200305160716822](https://tva1.sinaimg.cn/large/00831rSTly1gcj46t9za7j318f04d0ur.jpg)\n\n使用`(qemu)info mem`看看内存映射关系以及权限：\n\n```\n(qemu) info mem\n0000000000000000-0000000000400000 0000000000400000 -r-\n00000000f0000000-00000000f0400000 0000000000400000 -rw\n```\n\n刚进入kernel保护模式时，使用`(qemu)info pg`查看当前页表结构：\n\n```\n(qemu) info pg\nVPN range     Entry         Flags        Physical page\n[00000-003ff]  PDE[000]     ---------P\n  [00000-003ff]  PTE[000-3ff] --------WP 00000-003ff\n[f0000-f03ff]  PDE[3c0]     --------WP\n  [f0000-f03ff]  PTE[000-3ff] --------WP 00000-003ff\n```\n\nkernal运行完之后加载完成后再次使用命令`(qemu)info pg`:\n\n```\n(qemu) info pg\nVPN range     Entry         Flags        Physical page\n[00000-003ff]  PDE[000]     ----A----P\n  [00000-00000]  PTE[000]     --------WP 00000\n  [00001-0009f]  PTE[001-09f] ---DA---WP 00001-0009f\n  [000a0-000b7]  PTE[0a0-0b7] --------WP 000a0-000b7\n  [000b8-000b8]  PTE[0b8]     ---DA---WP 000b8\n  [000b9-000ff]  PTE[0b9-0ff] --------WP 000b9-000ff\n  [00100-00102]  PTE[100-102] ----A---WP 00100-00102\n  [00103-00111]  PTE[103-111] --------WP 00103-00111\n  [00112-00112]  PTE[112]     ---DA---WP 00112\n  [00113-00114]  PTE[113-114] --------WP 00113-00114\n  [00115-003ff]  PTE[115-3ff] ---DA---WP 00115-003ff\n[f0000-f03ff]  PDE[3c0]     ----A---WP\n  [f0000-f0000]  PTE[000]     --------WP 00000\n  [f0001-f009f]  PTE[001-09f] ---DA---WP 00001-0009f\n  [f00a0-f00b7]  PTE[0a0-0b7] --------WP 000a0-000b7\n  [f00b8-f00b8]  PTE[0b8]     ---DA---WP 000b8\n  [f00b9-f00ff]  PTE[0b9-0ff] --------WP 000b9-000ff\n  [f0100-f0102]  PTE[100-102] ----A---WP 00100-00102\n  [f0103-f0111]  PTE[103-111] --------WP 00103-00111\n  [f0112-f0112]  PTE[112]     ---DA---WP 00112\n  [f0113-f0114]  PTE[113-114] --------WP 00113-00114\n  [f0115-f03ff]  PTE[115-3ff] ---DA---WP 00115-003ff\n```\n\n\n\n一旦我们进入了保护模式，我们就无法直接使用物理地址或者线性地址，MMU会将所有内存引用转换为虚拟地址。\n\nJOS的kernel通常需要将地址作为不透明值或者integer进行操作，而不对其进行解引用（比如在物理内存分配器中）。为了记录代码，JOS内核有两种表示方式：\n\n* `uintptr_t`：代表虚拟地址，同普通指针一样\n* `physaddr_t`：代表物理地址\n\n实际上他们都只是`uint32_t`的别名。\n\n注意：我们不能直接对int类型进行解引用，而是先转换为指针类型。而且对于`physaddr_t`转换成的指针类型不能解引用，因为MMU会将其视为虚拟地址，这样导致我们无法得到正确的内容。\n\n**Question:** \n\n假定下面的代码正确，x应该是什么类型？`physaddr_t`还是`uintaddr_t`？\n\n```c\n\tmystery_t x;\n\tchar* value = return_a_pointer();\n\t*value = 10;\n\tx = (mystery_t) value;\n```\n\n肯定是`uintaddr_t`，因为第三行可以对指针value进行解引用，所以value肯定是虚拟地址。\n\n\n\nJOS的kernel有些时候需要读写物理地址，可以通过宏KADDR(pa)实现将物理地址+KERNBASE转换为内核虚拟地址。同理，有时候需要能通过内核虚拟地址找到物理地址，-KERNBASE，通过宏PADDR(va)实现。\n\n\n\n### 2.2 Reference Counting\n\n在之后的实验中，我们可能将同一个物理页同时映射到很多虚拟地址，我们必须维护`struct PageInfo`结构体中的`pp_ref`来保持引用计数。当引用计数为0的时候，页面就可以被释放。\n\n一般来说，这个引用计数等同于物理页面在`UTOP`以下的区域出现的次数（这个以上的区域的物理页面大多数都是在启动的时候被内核分配，而且不会被释放）。\n\n同样地，引用计数也可以追踪指向页目录的数量，以及页目录对页表项的引用计数。\n\n\n\n### 2.3 Page Table Management\n\n在这个环节中，我们需要编写管理页表的例程：插入以及删除线性地址到物理地址的映射，同时还需要创建页表。\n\n**exercise 4:**\n\n在`kern/pmap.c`中，实现以下函数：\n\n```c\npgdir_walk()\nboot_map_region()        \npage_lookup()\npage_remove()        \npage_insert()\n//最终通过mem_init()中的check_page()进行检查\n```\n\n* `pgdir_walk()`\n\n这个函数的以一个线性地址`va`和一个页目录`pgdir`作为参数，返回该线性地址对应的页面所在页表项(PTE)的地址。\n\n我们需要使用线性地址进行页目录索引，索引到对应的页表地址。如果索引到的页表还没被创建且`create`参数为1，则我们创建以个新的页表。进而我们获取页表项索引，通过页表结合表项索引，得到页表项。\n\n有一点需要注意的是，页表项实际上都是在KERNBASE之上，我们必须返回一个`kva(kernel virtual address)`。\n\n```c\n// Given 'pgdir', a pointer to a page directory, pgdir_walk returns\n// a pointer to the page table entry (PTE) for linear address 'va'.\n// This requires walking the two-level page table structure.\n//\n// The relevant page table page might not exist yet.\n// If this is true, and create == false, then pgdir_walk returns NULL.\n// Otherwise, pgdir_walk allocates a new page table page with page_alloc.\n//    - If the allocation fails, pgdir_walk returns NULL.\n//    - Otherwise, the new page's reference count is incremented,\n//\tthe page is cleared,\n//\tand pgdir_walk returns a pointer into the new page table page.\n//\n// Hint 1: you can turn a PageInfo * into the physical address of the\n// page it refers to with page2pa() from kern/pmap.h.\n//\n// Hint 2: the x86 MMU checks permission bits in both the page directory\n// and the page table, so it's safe to leave permissions in the page\n// directory more permissive than strictly necessary.\n//\n// Hint 3: look at inc/mmu.h for useful macros that manipulate page\n// table and page directory entries.\n//\npte_t *\npgdir_walk(pde_t *pgdir, const void *va, int create)\n{\n\t// page directory index and entry\n\tuint32_t pd_idx = PDX(va);\n\tpde_t pd_entry = pgdir[pd_idx];\n\t// page table index and entry\n\tuint32_t pt_idx = PTX(va);\n\t// page directory entry ->page table does not exists\n\tif((pd_entry & PTE_P) != 1){\n\t\tif(!create)\n\t\t\treturn NULL;\n\t\t//create page table\n\t\tstruct PageInfo * pg_new = page_alloc(ALLOC_ZERO);\n\t\tif(pg_new == NULL)\n\t\t\treturn NULL;\n\t\tpg_new -> pp_ref += 1;\n\t\tphysaddr_t pg_pa = page2pa(pg_new);\n\t\t// add to page directory entry\n\t\tpgdir[pd_idx] = pg_pa | PTE_P | PTE_W | PTE_U;\n\t\t// return (pte_t *)(KADDR(PTE_ADDR(pd_entry)))+ pt_idx;\n\t\treturn (pte_t *)page2kva(pg_new) + pt_idx;\n\t}\n\t//pte_t : page table entry      pte_t* : page table addr\n\t// 取得pte_t* 仿照其他函数获取pte_t* 的过程\n\t// 这个操作只能return Kernel Virtual Address（物理地址0-4M是不可写的）\n\tpte_t * pg_table = KADDR(PTE_ADDR(pd_entry));\n\treturn (pte_t *)(pg_table + pt_idx);\n}\n```\n\n我们这里要分析一下，当`!(pd_entry & PTE_P)`的情况：也就是说这个时候通过页目录无法索引一个有效的页表，此时我们需要创建一个页表。\n\n创建页表调用`page_alloc()`分配一个空闲页面当作我们的页表即可。（空闲页面4K，页表项32bits = 4B，那么一个页面正好能装下1K个页表项）\n\n完成后，我们就实现了通过虚拟地址以及页目录首址来获取相应的页表项(PTE)地址的功能。\n\n* `boot_map_region()`\n\n这个函数的作用是将一段虚拟内存映射到同样长度的物理内存(都经过页面对齐)。而且映射是以页面为单位。\n\n实际上这个函数的使用过程中只会映射`UTOP`之上的地址。\n\n```c\n// Map [va, va+size) of virtual address space to physical [pa, pa+size)\n// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and\n// va and pa are both page-aligned.\n// Use permission bits perm|PTE_P for the entries.\n//\n// This function is only intended to set up the ``static'' mappings\n// above UTOP. As such, it should *not* change the pp_ref field on the\n// mapped pages.\n//\n// Hint: the TA solution uses pgdir_walk\nstatic void\nboot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)\n{\n\t// Fill this function in\n\tsize_t page_num = size / PGSIZE, i;\n\tfor(i = 0; i < page_num; i++){\n\t\tpte_t * pt_entry = pgdir_walk(pgdir, (void*)(va + i * PGSIZE), 1);\n    // set PTE -> pa\n\t\t*pt_entry = (pa + i * PGSIZE) | perm | PTE_P;\n\t}\n}\n```\n\n* `page_lookup`\n\n这个函数的功能是，给定一个虚拟地址`va`以及相应的页目录地址`pgdir`，我们查找该虚拟地址的页表地址和物理地址，然后将`PageInfo`返回即可。\n\n```c\n// Return the page mapped at virtual address 'va'.\n// If pte_store is not zero, then we store in it the address\n// of the pte for this page.  This is used by page_remove and\n// can be used to verify page permissions for syscall arguments,\n// but should not be used by most callers.\n//\n// Return NULL if there is no page mapped at va.\n//\n// Hint: the TA solution uses pgdir_walk and pa2page.\n//\nstruct PageInfo *\npage_lookup(pde_t *pgdir, void *va, pte_t **pte_store)\n{\n\t// Fill this function in\n\tpte_t *pt_entry = pgdir_walk(pgdir, va, 0);\n\t// no page mapped at va\n\tif(!pt_entry)\n\t\treturn NULL;\n\tif(pte_store){\n\t\t*pte_store = pt_entry;\n\t}\n\treturn pa2page(PTE_ADDR(*pt_entry));\n}\n```\n\n* `page_remove()`\n\n这个函数的作用是解引用，给定虚拟地址`va`以及页目录`pgdir`，我们将其页表中对应的页（如果有）进行解引用。\n\n```c\n// Unmaps the physical page at virtual address 'va'.\n// If there is no physical page at that address, silently does nothing.\n//\n// Details:\n//   - The ref count on the physical page should decrement.\n//   - The physical page should be freed if the refcount reaches 0.\n//   - The pg table entry corresponding to 'va' should be set to 0.\n//     (if such a PTE exists)\n//   - The TLB must be invalidated if you remove an entry from\n//     the page table.\n//\n// Hint: The TA solution is implemented using page_lookup,\n// \ttlb_invalidate, and page_decref.\n//\nvoid\npage_remove(pde_t *pgdir, void *va)\n{\n\t// Fill this function in\n\tpte_t * ptestore_temp;\n\tstruct PageInfo * pg_entry = page_lookup(pgdir, va, &ptestore_temp);\n\t// PTE does not exist\n\tif(!pg_entry) return;\n\t// \n\tpage_decref(pg_entry);\n\t*ptestore_temp = 0;\n\t// invalidate a TLB entry\n\ttlb_invalidate(pgdir, va);\n}\n```\n\n* `page_insert()`\n\n这个函数是将给定的虚拟地址`va`对应的页面映射到给定的物理页面`pp`。\n\n注意一个case：就是我们对同一个`pp`和同一个`va`进行两次重复的insert，如果我们先使用`page_remove()`再增加`pp`的引用数，那会导致`pp`进入了`free_list`但是引用数+1后不为0。所以我们必须先增加引用数。\n\n```c\n// Map the physical page 'pp' at virtual address 'va'.\n// The permissions (the low 12 bits) of the page table entry\n// should be set to 'perm|PTE_P'.\n//\n// Requirements\n//   - If there is already a page mapped at 'va', it should be page_remove()d.\n//   - If necessary, on demand, a page table should be allocated and inserted\n//     into 'pgdir'.\n//   - pp->pp_ref should be incremented if the insertion succeeds.\n//   - The TLB must be invalidated if a page was formerly present at 'va'.\n//\n// Corner-case hint: Make sure to consider what happens when the same\n// pp is re-inserted at the same virtual address in the same pgdir.\n// However, try not to distinguish this case in your code, as this\n// frequently leads to subtle bugs; there's an elegant way to handle\n// everything in one code path.\n//\n// RETURNS:\n//   0 on success\n//   -E_NO_MEM, if page table couldn't be allocated\n//\n// Hint: The TA solution is implemented using pgdir_walk, page_remove,\n// and page2pa.\n//\nint\npage_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)\n{\n\t// Fill this function in\n\t// page table could not be allocated\n\tpte_t * pt_entry = pgdir_walk(pgdir, va, 1);\n\tif(!pt_entry) return -E_NO_MEM;\n\tpp -> pp_ref += 1;\n\t//remove page\n\tif((*pt_entry) & PTE_P){\n\t\tpage_remove(pgdir, va);\n\t}\n\t*pt_entry = page2pa(pp) | perm | PTE_P;\n\treturn 0;\n}\n```\n\n实现这些，我们就可以通过`check_page()`函数了，大功告成。\n\n![image-20200306161147186](https://tva1.sinaimg.cn/large/00831rSTly1gck9xtm008j30hp065q46.jpg)\n\n\n\n## Part3: Kernel Address Space\n\n这一部分我们终于可以讨论内核地址空间了。JOS将32位的线性地址空间分成了两部分：\n\n* 用户环境（在Lab3中涉及）：将控制低地址空间\n\n* 内核：总是完全地控制高地址空间\n\n将内核与用户环境分隔是在`inc/memlayout.h`中进行定义的，且为内核保留了大于256MB的虚拟地址空间。（实际上这解释了为什么我们需要在lab1中给内核提供如此高的链接地址：否则内核的虚拟地址空间将没有足够的空间同时映射到其下方的用户环境中）\n\n\n\n### 3.1 Permissions and Fault Isolation\n\n尽管内核与用户的内存都位于同一地址空间，我们仍然需要在x86页表中使用权限位去保证用户代码仅能够访问低地址空间。否则用户代码可能会覆写内核数据，这就会有潜在的冲突，此外用户代码还可能能窃取其他用户、内核的私有数据。注意可写权限位`PTW_W`会同时影响用户代码以及内核代码。\n\n用户的环境将不具备任何内存权限在`ULIM`之上，而内核是可以读写这些内存的。对于`[UTOP, ULIM)`这个范围的地址，用户环境和内核的权限是相同的：均是只能读不能写。这段内存的主要作用是向用户暴露内核中的一些只读的数据结构。最后，`UTOP`以下的地址空间将是用户环境使用的，用户环境可以自行设置这些内存的权限。\n\n\n\n### 3.2 Initializing the Kernel Address Space\n\n在这个部分，我们需要设置`UTOP`之上的内核地址空间。`inc/memlayout.h`展示了我们可能需要的layout结构，这个结构在文章开头的*JOS分段与分页*这一节已经进行了详细描述。\n\n**exercise 5:**\n\n补全`mem_init()`函数在调用`check_page()`之后未完成的缺失部分。在我们完善了`mem_init()`之后，将可以通过`check_kern_pgdir()`以及`check_page_installed_pgdir()`的检查。\n\n跟着注释读一遍，就没有什么难度了。\n\n```c\n\t//////////////////////////////////////////////////////////////////////\n\t// Now we set up virtual memory\n\n\t//////////////////////////////////////////////////////////////////////\n\t// Map 'pages' read-only by the user at linear address UPAGES\n\t// Permissions:\n\t//    - the new image at UPAGES -- kernel R, user R\n\t//      (ie. perm = PTE_U | PTE_P)\n\t//    - pages itself -- kernel RW, user NONE\n\t// Your code goes here:\n\t// 将pages数组映射到UPAGE地址区域以上\n\tboot_map_region(kern_pgdir, UPAGES, npages * sizeof(struct PageInfo), PADDR(pages), PTE_U | PTE_P);\n\t//////////////////////////////////////////////////////////////////////\n\t// Use the physical memory that 'bootstack' refers to as the kernel\n\t// stack.  The kernel stack grows down from virtual address KSTACKTOP.\n\t// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)\n\t// to be the kernel stack, but break this into two pieces:\n\t//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory\n\t//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if\n\t//       the kernel overflows its stack, it will fault rather than\n\t//       overwrite memory.  Known as a \"guard page\".\n\t//     Permissions: kernel RW, user NONE\n\t// Your code goes here:\n\tboot_map_region(kern_pgdir, (KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);\n\t//////////////////////////////////////////////////////////////////////\n\t// Map all of physical memory at KERNBASE.\n\t// Ie.  the VA range [KERNBASE, 2^32) should map to\n\t//      the PA range [0, 2^32 - KERNBASE)\n\t// We might not have 2^32 - KERNBASE bytes of physical memory, but\n\t// we just set up the mapping anyway.\n\t// Permissions: kernel RW, user NONE\n\t// Your code goes here:\n\tsize_t KERNSIZE = (unsigned)0xffffffff - KERNBASE;\n\tboot_map_region(kern_pgdir, KERNBASE, KERNSIZE, 0, PTE_W | PTE_P);\n```\n\n这里我们同样就大功告成了，再次启动qemu信息如下：（请选择性忽略我debug过程中的log）\n\n![image-20200307132808176](https://tva1.sinaimg.cn/large/00831rSTly1gclatuiullj30k00bqmxn.jpg)\n\n再次，我们回顾一下`mem_init()`的全过程，这就是jos设置页表管理内存的全过程：\n\n```c\n// Set up a two-level page table:\n//    kern_pgdir is its linear (virtual) address of the root\n//\n// This function only sets up the kernel part of the address space\n// (ie. addresses >= UTOP).  The user part of the address space\n// will be set up later.\n//\n// From UTOP to ULIM, the user is allowed to read but not write.\n// Above ULIM the user cannot read or write.\nvoid\nmem_init(void)\n{\n\tuint32_t cr0;\n\tsize_t n;\n\n\t// Find out how much memory the machine has (npages & npages_basemem).\n\ti386_detect_memory();\n\n\t// Remove this line when you're ready to test this function.\n\t//panic(\"mem_init: This function is not finished\\n\");\n\n\t//////////////////////////////////////////////////////////////////////\n\t// create initial page directory.\n\tkern_pgdir = (pde_t *) boot_alloc(PGSIZE);\n\tcprintf(\"kern_pgdir info: %x\\n\",kern_pgdir);\n\tcprintf(\"kern_pgdir address: %x\\n\", &kern_pgdir);\n\tcprintf(\"[mem_init] kern_pgdir[0] addr: %x\\n\", PTE_ADDR(kern_pgdir[0]));\n\tmemset(kern_pgdir, 0, PGSIZE);\n\n\t//////////////////////////////////////////////////////////////////////\n\t// Recursively insert PD in itself as a page table, to form\n\t// a virtual page table at virtual address UVPT.\n\t// (For now, you don't have understand the greater purpose of the\n\t// following line.)\n\n\t// Permissions: kernel R, user R\n\t// UVPT是页表区域的开始\n\tkern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;\n\n\t//////////////////////////////////////////////////////////////////////\n\t// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.\n\t// The kernel uses this array to keep track of physical pages: for\n\t// each physical page, there is a corresponding struct PageInfo in this\n\t// array.  'npages' is the number of physical pages in memory.  Use memset\n\t// to initialize all fields of each struct PageInfo to 0.\n\t// Your code goes here:\n\tn = npages * sizeof(struct PageInfo);\n\tpages = (struct PageInfo *)boot_alloc(n);\n\tmemset(pages, 0, n);\n\t//////////////////////////////////////////////////////////////////////\n\t// Now that we've allocated the initial kernel data structures, we set\n\t// up the list of free physical pages. Once we've done so, all further\n\t// memory management will go through the page_* functions. In\n\t// particular, we can now map memory using boot_map_region\n\t// or page_insert\n\tpage_init();\n\n\tcheck_page_free_list(1);\n\tcheck_page_alloc();\n\tcheck_page();\n\n\t//////////////////////////////////////////////////////////////////////\n\t// Now we set up virtual memory\n\n\t//////////////////////////////////////////////////////////////////////\n\t// Map 'pages' read-only by the user at linear address UPAGES\n\t// Permissions:\n\t//    - the new image at UPAGES -- kernel R, user R\n\t//      (ie. perm = PTE_U | PTE_P)\n\t//    - pages itself -- kernel RW, user NONE\n\t// Your code goes here:\n\t// 将pages数组映射到UPAGE地址区域以上\n\tboot_map_region(kern_pgdir, UPAGES, npages * sizeof(struct PageInfo), PADDR(pages), PTE_U | PTE_P);\n\t//////////////////////////////////////////////////////////////////////\n\t// Use the physical memory that 'bootstack' refers to as the kernel\n\t// stack.  The kernel stack grows down from virtual address KSTACKTOP.\n\t// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)\n\t// to be the kernel stack, but break this into two pieces:\n\t//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory\n\t//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if\n\t//       the kernel overflows its stack, it will fault rather than\n\t//       overwrite memory.  Known as a \"guard page\".\n\t//     Permissions: kernel RW, user NONE\n\t// Your code goes here:\n\tboot_map_region(kern_pgdir, (KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);\n\t//////////////////////////////////////////////////////////////////////\n\t// Map all of physical memory at KERNBASE.\n\t// Ie.  the VA range [KERNBASE, 2^32) should map to\n\t//      the PA range [0, 2^32 - KERNBASE)\n\t// We might not have 2^32 - KERNBASE bytes of physical memory, but\n\t// we just set up the mapping anyway.\n\t// Permissions: kernel RW, user NONE\n\t// Your code goes here:\n\tsize_t KERNSIZE = (unsigned)0xffffffff - KERNBASE;\n\tboot_map_region(kern_pgdir, KERNBASE, KERNSIZE, 0, PTE_W | PTE_P);\n\t// Check that the initial page directory has been set up correctly.\n\tcheck_kern_pgdir();\n\n\t// Switch from the minimal entry page directory to the full kern_pgdir\n\t// page table we just created.\tOur instruction pointer should be\n\t// somewhere between KERNBASE and KERNBASE+4MB right now, which is\n\t// mapped the same way by both page tables.\n\t//\n\t// If the machine reboots at this point, you've probably set up your\n\t// kern_pgdir wrong.\n\tlcr3(PADDR(kern_pgdir));\n\n\tcheck_page_free_list(0);\n\n\t// entry.S set the really important flags in cr0 (including enabling\n\t// paging).  Here we configure the rest of the flags that we care about.\n\tcr0 = rcr0();\n\tcr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;\n\tcr0 &= ~(CR0_TS|CR0_EM);\n\tlcr0(cr0);\n\n\t// Some more checks, only possible after kern_pgdir is installed.\n\tcheck_page_installed_pgdir();\n}\n```\n\n**Question**\n\n* What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:\n\n这个我们需要填写在`mem_init()`过程中映射的地址\n\n| Entry | Base Virtual Address |     Points to (logically)     |\n| :---: | :------------------: | :---------------------------: |\n| 1023  |      0xFFC00000      |        Physical Memory        |\n|   …   |         ……….         |               …               |\n|  960  |      0xF0000000      | First 4 MB on Physical Memory |\n|  959  |      0xEFC00000      |         Kernel Stack          |\n|  957  |      0xEF400000      |     Kernel Page Directory     |\n|  956  |      0xEF000000      |             Pages             |\n\n* We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?\n\n虽然用户环境和内核都在同样的地址空间中，但用户显然无法访问内核区域的内存的。回忆我们在`mem_init()`过程中对所有的映射设置了特权级，没有`PTE_U`特权的页显然是用户无法访问的。\n\n* What is the maximum amount of physical memory that this operating system can support? Why?\n\n操作系统虚拟内存空间部分分布如下：\n\n```\n * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000\n *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE\n *    UVPT      ---->  +------------------------------+ 0xef400000\n *                     |          RO PAGES            | R-/R-  PTSIZE\n *    UPAGES    ---->  +------------------------------+ 0xef000000\n```\n\n回顾我们实验的第一部分，我们建立了一个物理内存分配器。在`page_init()`函数中，我们将所有可用的物理内存按照页面进行划分并且存放在了`pages`结构体数组中。在第三部分设置操作系统内核虚拟空间的过程中，我们在`mem_init()`配置页表的过程中使用`boot_map_regions()`将`pages`映射到了`UPAGES`以上的区域。\n\n那么程序空间是利用虚拟地址进行访问`pages`的，此时对应虚拟空间的`R0 PAGES`，大小为`0xef000000-0xef400000(4MB)`。一旦超过4MB就越界到了`UVPT`这个空间，而`UVPT`这个空间是映射在了`kern_pgdir`中。\n\n也就是说，虚拟空间访问`UPAGES`最多只有4MB，而`pages`的每个元素是`struct PageInfo`类型的结构体，占8B空间，其每一个元素对应的一个页面有4KB大。因此一共支持物理空间2GB。\n\n* How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?（内存管理的开销问题，如果我们有能支持的最大的物理内存，管理内存的开销是什么？且如何减少？）\n\n经过上一问的分析，操作系统支持虚拟空间最多寻址512KB个页面，也就是有512个页表（一个页表能够寻址`2^10`个页面）。再次回顾我们在2.3节进行页表管理的时候，对于每一个`kern_dir`未初始化的页表项，我们都通过`page_alloc()`分配一个页表。也就是说实际上每一个页表的大小都是`PGSIZE`。那么页表所需的空间开销就是`PGSIZE * 512 = 2MB`，再加上4KB的页目录以及刚才所需4MB的空间存放所有`PageInfo`，总共的空间开销就是`6MB + 4KB`。\n\n如果想降低开销的话，可以把`PGSIZE`设置的大一些。\n\n* Revisit the page table setup in `kern/entry.S` and `kern/entrypgdir.c`. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?（在我们刚开启分页机制的时候，程序还运行在低地址1MB上，控制流在什么时候跳转到KERNBASE以上？为什么在打开分页机制之后我们仍能够运行在物理地址的低地址上？）\n\n我们查看`entry.S`的关键代码，这部分代码实际上是`obj/kern/kernal.asm`中的entry部分。\n\n```assembly\nentry:\n\tmovw\t$0x1234,0x472\t\t\t# warm boot\n\n\t# We haven't set up virtual memory yet, so we're running from\n\t# the physical address the boot loader loaded the kernel at: 1MB\n\t# (plus a few bytes).  However, the C code is linked to run at\n\t# KERNBASE+1MB.  Hence, we set up a trivial page directory that\n\t# translates virtual addresses [KERNBASE, KERNBASE+4MB) to\n\t# physical addresses [0, 4MB).  This 4MB region will be\n\t# sufficient until we set up our real page table in mem_init\n\t# in lab 2.\n\n\t# Load the physical address of entry_pgdir into cr3.  entry_pgdir\n\t# is defined in entrypgdir.c.\n\tmovl\t$(RELOC(entry_pgdir)), %eax\n\tmovl\t%eax, %cr3\n\t# Turn on paging.\n\tmovl\t%cr0, %eax\n\torl\t$(CR0_PE|CR0_PG|CR0_WP), %eax\n\tmovl\t%eax, %cr0\n\n\t# Now paging is enabled, but we're still running at a low EIP\n\t# (why is this okay?).  Jump up above KERNBASE before entering\n\t# C code.\n\tmov\t$relocated, %eax\n\tjmp\t*%eax\n```\n\n我们可以看到最后五行，也就是执行指令`movl %eax, %cr0`之后，控制流就使用`jmp`指令跳转到了`KERNBASE`以上的高地址部分。之所以打开分也机制我们还能在低地址运行，是由于实际上低地址和`KERNBASE`以上的高地址区域都被映射在同一片物理内存中。所以运行无误。\n\n\n\n完成了上述的所有问题，就也可以使用`make grade`。\n\n```\n  Physical page allocator: OK\n  Page management: OK\n  Kernel page directory: OK\n  Page management 2: OK\nScore: 70/70\n```\n\n舒服了。完结撒花🎉","tags":["operating system","lab"],"categories":["operating system"]},{"title":"手把手带你MIT6.828 - Lab1","url":"/2020/03/02/joslab1/","content":"\n# Lab1 Booting a PC\n\n官方文档: [lectures](https://pdos.csail.mit.edu/6.828/2018/lec/)\n\n## Part 1: PC Bootstrap\n\n这个部分是为了熟悉x86汇编语言，以及PC的启动流程。同时在实验的过程中，我们需要使用qemu和gdb进行调试。\n\n\n\n### 1.1 x86 Assembly\n\n**exercise 1：**熟悉x86汇编。\n\n很显然，这个步骤不需要再次赘述。\n\n如果你看这篇文章的时候没学过assembly，那说明你看这篇文章的时候没学过assembly。可能你入门os比较超前。\n\n请注意哦～本实验的所有assembly都是AT&T格式的，不是INTEL格式的哦～不要把sourse和dest弄反。\n\n\n\n### 1.2 Simulating the x86\n\n在我们的实验中并没有使用真正的PC，而是qemu模拟的PC。我们按照实验要求下载好一切依赖项以及资源后，直接使用`make`指令。\n\n`make`之后，我们就bulid完成了一个低配版6.828boot loader以及kernal（在之后的环节中，我们会逐渐完善这个kernal的）。\n\n同时，我们qemu所需的虚拟硬盘就在`/obj/kern/kernal.img`下生成完毕，这个硬盘镜像中包括我们的boot loader(`obj/boot/boot`)以及我们的kernal(`/obj/kernal`)。\n\n当我们唤起qemu的虚拟PC时，我们只需要在lab文件夹的terminal中输入`make qemu`即可。\n\n这将使用设置硬盘并将串行端口直接输出到终端所需的选项执行qemu，我们可以看到启动时屏幕上显示的一系列字符串：\n\n<img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gcej5omkh1j31400ngwmt.jpg\" alt=\"image-20200301165721235\" style=\"zoom:50%;\" />\n\nbooting from hard disk之后的一切流程都已经呈现在屏幕上。\n\n实际上，我们可以通过regular shell window和qemu display window同时与kernal进行交互。\n\n有一点需要注意的是：我们的kernal monitor是直接运行在仿真的虚拟硬盘上的。这就意味着我们是可以将`obj/kern/kernal.img`的内容拷贝到真实硬盘的前几个扇区的，这样就可以在实际的PC屏幕中看到qemu window中相同的内容。（不建议如此的原因是，将其复制到硬盘的开头会破坏主引导记录master boot record，以及第一个分区的开头beginning of the first partition）\n\n\n\n### > PC物理地址空间\n\nPC的物理空间布局如下：\n\n```\n+------------------+  <- 0xFFFFFFFF (4GB)\n|      32-bit      |\n|  memory mapped   |\n|     devices      |\n|                  |\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n|                  |\n|      Unused      |\n|                  |\n+------------------+  <- depends on amount of RAM\n|                  |\n|                  |\n| Extended Memory  |\n|                  |\n|                  |\n+------------------+  <- 0x00100000 (1MB)\n|     BIOS ROM     |\n+------------------+  <- 0x000F0000 (960KB)\n|  16-bit devices, |\n|  expansion ROMs  |\n+------------------+  <- 0x000C0000 (768KB)\n|   VGA Display    |\n+------------------+  <- 0x000A0000 (640KB)\n|                  |\n|    Low Memory    |\n|                  |\n+------------------+  <- 0x00000000\n```\n\n最初的PC基于16位的8088处理器，仅仅能够支持**2^20B = 2^10KB = 1MB** 的寻址。所以早起的地址空间从0x00000开始到0xFFFFF结束（2^20B）。\n\n* 0x00000 - 0xA0000(640KB)被称为低内存，这就是早期的PC能用的唯一RAM。\n\n* 0xA0000-0xFFFFF(384KB)被硬件保留作特殊用途比如视频缓冲区或者固件。这部分中最重要的区域是从0xF0000-0xFFFFF(64KB)的**基本输入输出系统BIOS**。\n\n  > BIOS的作用是初始化系统，比如激活显卡(video card)、检查内存等。在该初始化过程完成后，BIOS从合适的位置，如硬盘(hard disk)、软盘(floppy disk)、光碟(CD-ROM)甚至网络中读取操作系统，然后将机器的控制权转移给操作系统。\n\n从Intel的80286到80386，处理器能够支持16MB以及4GB的地址空间！但是为了向后兼容(backward compatibility)，PC架构保留了原始的最低的1MB的内存布局。\n\n现代PC因此在0x000A0000-0x00100000的内存中有一个“洞”。这个洞将内存分为了低内存/保留内存(Low Memory)(低640KB)以及拓展内存(Extended Memory)(其他范围)。除此之外，32位的PC的地址空间的最上方，常常被BIOS保留用于32位的PCI设备。\n\n最新的x86处理器可以支持超过4GB的物理内存，也就是说内存可以超过0xFFFFFFFF。因此BIOS需要预留出第二个“洞”以保证那些32位的PCI设备的地址可以被正确的映射。\n\n\n\n### 1.3 ROM BIOS\n\n根据实验的指导，我们使用qemu和gdb的联合调试。输入指令`make qemu-gdb`。此时qemu将在第一条指令执行之前暂停，并且等待gdb的debugging connection。\n\n然后我们新开一个terminal，输入指令`make gdb`我们可以看到如图所示的输出：\n\n![image-20200301173547006](https://tva1.sinaimg.cn/large/00831rSTly1gcek9o3f62j31h80bzte3.jpg)\n\n因为提供了`.gdbinit`文件，所以我们的gdb能够一下子链接进来，自动attach到需要调试的程序上。（前提当然是需要debug的程序已经运行起来了）\n\n我们看到需要执行的第一条指令`ljmp`如下\n\n```assembly\n[f000:fff0] 0xffff0:    ljmp   $0xf000,$0xe05b\n```\n\n* 从这个指令可以看出，从上电开始，IBM PC从0x000ffff0开始执行指令。该处地址位于BIOS的64位空间的顶层。\n* 此时，CS = 0xf000, IP = 0xfff0\n* 第一条指令是一个`jmp`指令，跳转至CS = 0xf000, IP = 0xe05b\n\n这些其实都是早期的8088处理器设计的。这样的设计能够保证BIOS在刚刚上电之后总是能够控制机器。因为在刚上电的时候，内存中并不存在可以执行的代码。\n\n> 在这里我们需要理解CS:IP是如何表示一个实地址空间的：\n>\n> 8086是分段式寻址，也就是通过两个16位的寄存器值构造一个20位的地址。实际地址是CS * 16 + IP = 0xf000 * 16 + 0xfff0 = 0xffff0\n\n**exercise 2:**\n\n使用gdb的`si`（单步调试）命令进入ROM BIOS并且追踪几条指令，猜测这些指令的作用。我们在这里不需要指出指令的细节，只需要了解BIOS开始运行的核心思想即可。\n\n```assembly\n[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b # 跳到一个较早的位置\n[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6ac8 # 测试cs段的0x6ac8字是否为0\n[f000:e062]    0xfe062: jne    0xfd2e1         \n[f000:e066]    0xfe066: xor    %dx,%dx         # 测试为0\n[f000:e068]    0xfe068: mov    %dx,%ss         # 设置栈段-ss段寄存器\n[f000:e06a]    0xfe06a: mov    $0x7000,%esp    # 设置栈指针寄存器\n                                               # 栈的延伸方向和代码段延伸方向相反\n[f000:e070]    0xfe070: mov    $0xf34c2,%edx   # 设置edx寄存器值\n[f000:e076]    0xfe076: jmp    0xfd15c         # 跳转\n[f000:d15c]    0xfd15c: mov    %eax,%ecx       \n[f000:d15f]    0xfd15f: cli                    # 关闭硬件中断\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # 为啥要关中断不用爷多说了吧？启动的时候\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # 你害敢被中断？\n[f000:d160]    0xfd160: cld                    # 设置串传送指令方向\n[f000:d161]    0xfd161: mov    $0x8f,%eax      \n[f000:d167]    0xfd167: out    %al,$0x70       # IO端口指令，8086的端口和内存编址分开\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # 端口0x70的寄存器是控制寄存器\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # 将要访问的CMOS中的数据偏移传入0x70端口\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # 就可以在0x71号端口下读取相应数据\n[f000:d169]    0xfd169: in     $0x71,%al       # 从CMOS读取选择的寄存器\n[f000:d16b]    0xfd16b: in     $0x92,%al       # 读取系统控制端口A\n/*我们知道了，0x70端口和0x71端口是用于控制系统中一个叫做CMOS的设备，这个设备是一个低功耗的存储设备，它可以用于在计算机关闭时存储一些信息，它是由独立的电池供电的。*/\n/*这个CMOS中可以控制跟PC相关的多个功能，其中最重要的就是时钟设备（Real Time Clock）的 ，它还可以控制是否响应不可屏蔽中断NMI(Non-Maskable Interrupt)。\n操作CMOS存储器中的内容需要两个端口，一个是0x70另一个就是0x71。其中0x70可以叫做索引寄存器，这个8位寄存器的最高位是不可屏蔽中断(NMI)使能位。如果你把这个位置1，则NMI不会被响应。低7位用于指定CMOS存储器中的存储单元地址，所以如果你想访问第1号存储单元，并且在访问时，我要使能NMI，那么你就应该向端口0x70里面送入0b10000001 = 0x81。 mov $0x8f, %eax实际做到了这一点*/\n/*\nmov $0x81, %al\nout %al, 0x70\n然后对于这个地址单元的操作，比如读或者写就可以由0x71端口完成，比如你现在想从1号存储单元里面读出它的值，在完成上面的两条指令后，就可以输入这条指令\nin $0x71, %al \n再回到我们的系统，这三条指令可以看出，它首先关闭了NMI中断，并且要访问存储单元0xF的值，并且把值读到al中，但是在后面我们发现这个值并没有被利用，所以可以认为这三条指令是用来关闭NMI中断的。*/\n[f000:d16d]    0xfd16d: or     $0x2,%al        \n[f000:d16f]    0xfd16f: out    %al,$0x92       # 通过快速A20以启动A20\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # A20是个历史遗留的问题，爷不想了解这根线\n/*这三步操作又是在控制端口，此时被控制的端口号为0x92。我们可以查看到，它控制的是 PS/2系统控制端口A，而这两步的操作明显是在把这个端口的1号bit置为1。这个端口的bit1的功能是：\nbit 1= 1 indicates A20 active\n即A20位，即第21个地址线被使能，了解实模式和保护模式的同学肯定清楚，如果A20地址线被激活，那么系统工作在保护模式下。但是在之后的boot loader程序中，计算机首先要工作在实模式下啊。所以这里的这个操作，根据网上 http://kernelx.weebly.com/a20-address-line.html 所说应该是去测试可用内存空间。在boot loader之前，它肯定还会转换回实模式。*/\n[f000:d171]    0xfd171: lidtw  %cs:0x6ab8      # 将cs:0x6ab8加载进入IDT表\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # IDT表是中断描述符表\n[f000:d177]    0xfd177: lgdtw  %cs:0x6a74      # 将cs:0x6a74加载进入GDT表\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t # GDT表是全局描述符表\n[f000:d17d]    0xfd17d: mov    %cr0,%eax   \n[f000:d180]    0xfd180: or     $0x1,%eax       \n[f000:d184]    0xfd184: mov    %eax,%cr0       # 将cr0寄存器的保护模式位打开\n\n/*计算机中包含CR0~CR3四个控制寄存器，用来控制和确定处理器的操作模式。其中这三个语句的操作明显是要把CR0寄存器的最低位(0bit)置1。CR0寄存器的0bit是PE位，启动保护位，当该位被置1，代表开启了保护模式。但是这里出现了问题，我们刚刚说过BIOS是工作在实模式之下，后面的boot loader开始的时候也是工作在实模式下，所以这里把它切换为保护模式，显然是自相矛盾。所以只能推测它在检测是否机器能工作在保护模式下。*/\n\n[f000:d187]    0xfd187: ljmpl  $0x8,$0xfd18f   # 通过ljmp指令进入保护模式\n=> 0xfd18f:     mov    $0x10,%eax              # 设置段寄存器\n=> 0xfd194:     mov    %eax,%ds\n=> 0xfd196:     mov    %eax,%es  \n=> 0xfd198:     mov    %eax,%ss\n=> 0xfd19a:     mov    %eax,%fs\n=> 0xfd19c:     mov    %eax,%gs\n=> 0xfd19e:     mov    %ecx,%eax  \n=> 0xfd1a0:     jmp    *%edx                   # 跳转\n```\n\n在这里必须附上一个牛逼的链接：[I/O Func](http://bochs.sourceforge.net/techspec/PORTS.LST)。你可以看到各种I/O设备的端口号清单。\n\n关于CMOS的介绍，请看：[CMOS](http://wiki.osdev.org/CMOS)。\n\n中断向量表，请看：[IDT](http://wiki.osdev.org/Interrupt_Descriptor_Table)。\n\nGDT表实现了保护方式下非常重要的一部分，但是具体介绍将在boot loader过程中。\n\n\n\n## Part2: BootLoader\n\n软盘和硬盘都被分为了512 Bytes的扇区(sector)。一个扇区是磁盘传输的最小粒度：每一个读操作和每一个写操作都必须是一个或者多个扇区，而且必须要扇区边界对齐。\n\n如果说一个磁盘是可引导的，那么该磁盘的第一个扇区就叫做**引导扇区(boot sector)**，也就是引导程序的代码储存的扇区。（意思就是引导盘的引导内容都在磁盘的第一个扇区）**当BIOS发现一个可引导的硬件（软盘或者硬盘等），它将把引导扇区从磁盘中读取至内存的0x7c00-0x7dff位置**，同时使用一个`jmp`指令设置CS:IP = 0000:7000，然后将控制权交给boot loader(引导程序)。与BIOS加载地址相同，这个地址对于PC来说是固定的且是标准化的(说实话原文还说是fairly arbitrary，我没读懂是什么意思)。\n\n> 从光盘中引导的情形更加复杂而且更加powerful，因为光盘的一个扇区大小是2048Bytes，也就是说BIOS可以从光盘中读取一个更大的引导镜像加载到内存中。\n\n在6.828中，我们使用传统的硬盘引导机制，这意味着我们的boot loader必须满足512Bytes的限制。\n\n引导由一个汇编源文件`boot/boot.s`，以及一个C源文件`boot/main.c`组成。\n\n如果我们想要完全理解这些文件，我们需要一些前置知识：下面可能…painful。\n\n\n\n### > 实模式和保护模式\n\n关于这些的简单介绍，请参考[PC Assembly Language](https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf)该书的1.2.7和1.2.8节。内容不多。\n\n实模式是为了与8086兼容而设置的。在实模式下，处理器相当于一个快速8086处理器。\n\n实际上，在**处理器被加电或者复位的时候，实模式就会启动**。\n\n* 实模式下，各寄存器以实模式的初始化值进行工作；\n* 实模式的地址空间一共有20位(1MB)；\n* 实模式下不支持内存分页机制（显然内存分页是为了给保护模式设置的）；\n* 实模式下，各内存段都是可读、可写、可执行的，不支持指令优先级，所有的指令均运行在特权级；\n* 实模式不支持任务切换；\n* 实模式的中断处理与8086相同，使用中断矢量表来定位中断服务程序。\n\n在保护模式下，处理器的所有功能都是可用的，具体来说：\n\n* 保护模式提供了完全的32位空间，寻址空间为4GB；\n* 保护模式支持内存分页机制，提供了对虚拟内存的硬件支持；\n* 保护模式的处理器支持多任务（上下文切换）；\n* 保护模式的处理器支持指令和数据的特权级，配合边界检查等机制，既可以共享数据也可以隔离各个任务。\n\n\n\n### > A20地址线\n\n不要意思，爷本来以为不用了解这个。。。\n\n早期的PC上，处理器只支持20位的地址空间，任何超过20位的地址都会被卷回。\n\n也就是说 0xffff + 0xffff = 0x1fffe -> 0xfffe。\n\n然而从80286开始，Intel支持了24位的地址空间，上例的地址相加不会发生卷回。\n\n为了保证与早期的PC完全兼容，Intel采用“黑魔法”，将A20(第21根)地址线与键盘控制器的一个输出进行了与运算。进而控制了A20地址线的值。\n\n默认情况下，A20是置0的，PC将智能访问1M、3M、5M……这样的奇数段，进入保护模式之前我们必须先打开A20以获得完全寻址能力。\n\nJOS的内核可以通过端口的方式与键盘控制器进行通信而且打开A20。\n\n- 8042有一个1 Byte的输入缓冲区，一个1 Byte的输出缓冲区、一个1 Byte的状态寄存器、以及一个1 Byte的控制寄存器。前三个寄存器可以直接从0x60和0x64端口进行访问。最后一个寄存器通过“Read Command Byte”命令进行读，通过“Write Command Byte”命令进行写。\n- 对0x60端口读会读输入缓冲区；对0x60端口写会写输出缓冲区；对0x64端口读会读状态寄存器；对0x64端口写会发送命令。\n- 状态寄存器的Bit1为IBF - Input Buffer Full，当该Bit为1时，输入缓冲区满，不能对0x60端口或0x64端口写。\n- 对0x64端口写0xd1发送的命令是“Write Output Port”写输出端口，表明将参数写入输出端口（0x60端口写）。\n- A20使用的是键盘控制器输出的Bit 1，向输出端口写入0xdf可以打开A20；向输出端口写入0xdd则会关闭A20。\n\n\n\n### > 分段机制和全局描述符表GDT\n\n注⚠️：**更具体的段管理方式将在lab2中进行介绍。在不具备这些知识的前提下，可以暂时忽略下文关于分段机制的内容和介绍，直接跳到boot.S。**\n\n分段机制可以看看：[分段机制](http://www.kerneltravel.net/chenlj/lecture4.pdf)\n\nx86处理器提供了分段机制和分页机制两种内存管理模式。如果要进入保护模式，就必须要启动分段机制（分页机制不是必须的）。\n\n分段机制将内存划分为若干个段，每一个段都由段基址、段界限和段属性构成。**由一个段描述符表（可以理解为一个数组）描述所有段的信息**。段描述符表可以是全局的也可以是局部的。\n\n简化来说，程序首先将对应的**段选择子（数组索引）加载到段寄存器**中。然后在执行程序时，根据指令的内容确定应该使用的段寄存器，然后**根据段寄存器的段选择子再确定最终要使用的段描述符**。结合段描述符中包含的信息加上指令自身的地址构造出实际的线性地址（什么是线性地址呢？这个在lab2中会介绍）。最终将物理地址送到地址总线上，在物理内存中进行寻址，取回相应的数据。\n\n\n\n#### >> 全局描述符表寄存器\n\nx86处理器提供了专门的全局描述符表寄存器GDTR(Global Description Table Register)用于保存全局描述符表的表基址和表限长。GDTR由两个字节的表限长(limit)和4个字节的表基址(base)构成。表基址制定了全局描述符表的起始地址，表限长确定了全局描述符表的大小，结构体描述如下：\n\n```c\nstruct gdtr {\n\tu16 limite;\n\tu32 base;\n} __attribute__ ((packed));\n```\n\n机器刚刚加电，或者处理器复位后，表基址被默认设置为0，而表限长默认设置为0xffff。在保护模式初始化的过程中，必须给GDTR加载新的值。可以使用lgdt指令为GDTR加载新的值。\n\n\n\n#### >> 段选择子\n\n段选择子（2Bytes）用于**选择特定的描述符表以及表中特定的描述符**。段选择子一般都是被放置于段寄存器中，段选择子由**13位的索引**、**1位的表指示位**以及**2位的请求特权级**三部分组成。其中**索引指定了描述符**；**表指示位选择应该访问的描述符表**-0代表全局描述符表，1代表局部描述符表；**请求特权级用于段级的保护机制**，自0到4分别代表ring 0 到ring 3。结构体如下：\n\n```c\nstruct selector {\n    u16 index:13;\n    u16 ti:1;\n    u16 rpl:2;\n}\n```\n\n\n\n#### >> 段描述符\n\n段描述符（8Bytes）是段描述符表这个“数组”的“元素”。结构体描述如下：\n\n```c\nstruct gdtdesc {\n\tu16 lim0_15;\n\tu16 base0_15;\n\tu8 base16_23;\n\tu8 acces;\n\tu8 lim16_19:4;\n\tu8 other:4;\n\tu8 base24_31;\n} __attribute__ ((packed));\n```\n\n总共包含32位的段基址、20位的段界限、12位的类型。\n\n段基址确定了段的起始地址。段界限规定了段的大小。类型用于**区别不同类型的描述符（包括描述符特权级、段存在位、已访问位等）**\n\n\n\n### > GDT与LDT\n\n看了这些我们再来了解一下保护模式的地址。也就是计算机中实际存在两个表GDT、LDT，前者是全局描述符表，后者是本地段描述符表。他们都用来存放某个运行在内存中的程序的分段信息的。只不过全局描述符表是全局可见的，**即每一个运行在内存中的程序都能访问这个表**。**操作系统的内核程序的段信息就存在GDT表里面。**而LDT表是每一个在内存中的程序都包含的，这里面指明了每一个程序的段信息。\n\n<img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gcfn2gz5knj30f506paar.jpg\" alt=\"image-20200302155554248\" style=\"zoom: 67%;\" />\n\n这就是刚才的段描述符的结构了哈。\n\n\n\ngkd好了好了，我们现在回到BootLoader。BootLoader引导程序通过x86特殊的I/O指令直接访问IDE磁盘设备寄存器，从而从硬盘读取内核。如果需要对这个过程进行更加详细的了解，请阅读[the 6.828 reference page](https://pdos.csail.mit.edu/6.828/2018/reference.html)中的\"IDE hard drive controller\"部分。\n\n现在我们就来看一看我们的引导，boot.s和main.c：\n\n\n\n### 2.1 boot.s 代码\n\nboot.s代码在源文件中打开如下：\n\n```assembly\n#include <inc/mmu.h>\n\n# Start the CPU: switch to 32-bit protected mode, jump into C.\n# The BIOS loads this code from the first sector of the hard disk into\n# memory at physical address 0x7c00 and starts executing in real mode\n# with %cs=0 %ip=7c00.\n# boot.S 主要将CPU切换至32位保护模式，并且跳转进入C代码\n\n.set PROT_MODE_CSEG, 0x8         # kernel code segment selector\n.set PROT_MODE_DSEG, 0x10        # kernel data segment selector\n.set CR0_PE_ON,      0x1         # protected mode enable flag\n\n.globl start\nstart:                        # 程序入口\n  .code16                     # Assemble for 16-bit mode 指导生成16位汇编代码\n  cli                         # Disable interrupts 关中断\n  cld                         # String operations increment 设置串传递顺序递增\n\n  # Set up the important data segment registers (DS, ES, SS). 设置重要的段寄存器为0\n  xorw    %ax,%ax             # Segment number zero\n  movw    %ax,%ds             # -> Data Segment\n  movw    %ax,%es             # -> Extra Segment\n  movw    %ax,%ss             # -> Stack Segment\n\n  # Enable A20:\n  #   For backwards compatibility with the earliest PCs, physical\n  #   address line 20 is tied low, so that addresses higher than\n  #   1MB wrap around to zero by default.  This code undoes this.\n  # 开启A20：\n  #   A20的介绍已经给出，不再赘述。\nseta20.1:\n  inb     $0x64,%al               # Wait for not busy 等待缓冲区可用\n  testb   $0x2,%al                # Test for bit1\n                                  # if bit1 = 1 then buffer is full\n  jnz     seta20.1\n\n  movb    $0xd1,%al               # 0xd1 -> port 0x64\n  outb    %al,$0x64               # Prepare to write output port 准备写入输出端口\n\nseta20.2:\n  inb     $0x64,%al               # Wait for not busy 等待缓冲区可用\n  testb   $0x2,%al\n  jnz     seta20.2                # The same as above 同上\n\n  movb    $0xdf,%al               # 0xdf -> port 0x60\n  outb    %al,$0x60               # 0xdf -> A20 gate enable command 打开A20\n\n  # Switch from real to protected mode, using a bootstrap GDT\n  # and segment translation that makes virtual addresses\n  # identical to their physical addresses, so that the\n  # effective memory map does not change during the switch.\n  lgdt    gdtdesc                # Load gdt size/base to gdtr 设置全局描述符表\n  movl    %cr0, %eax             # Control register 0\n                                 # bit0 is protected enable bit\n                                 # 读取控制寄存器0的值，其Bit0为允许保护模式位\n  orl     $CR0_PE_ON, %eax       # Set PE 将允许保护模式位置1\n  movl    %eax, %cr0             # Update Control register 0 设置控制寄存器0\n\n  # Jump to next instruction, but in 32-bit code segment.\n  # Switches processor into 32-bit mode.\n  ljmp    $PROT_MODE_CSEG, $protcseg # 通过ljmp指令（跳转至下一条指令）进入保护模式\n\n  .code32                     # Assemble for 32-bit mode 指导生成32位汇编代码\nprotcseg:\n  # Set up the protected-mode data segment registers 设置保护模式的数据段寄存器\n  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector\n  movw    %ax, %ds                # -> DS: Data Segment\n  movw    %ax, %es                # -> ES: Extra Segment\n  movw    %ax, %fs                # -> FS\n  movw    %ax, %gs                # -> GS\n  movw    %ax, %ss                # -> SS: Stack Segment\n\n  # Set up the stack pointer and call into C. 设置栈指针并且调用C\n  movl    $start, %esp  # Stack has the opposite extension direction than Code\n                        # 注意栈的延伸方向和代码段相反\n  call bootmain #调用main.c中的bootmain函数\n\n  # If bootmain returns (it shouldn't), loop.\nspin:\n  jmp spin\n\n# Bootstrap GDT 引导GDT\n.p2align 2                                # force 4 byte alignment\ngdt:\n  SEG_NULL\t\t\t\t# null seg 默认第一个段描述符为空\n  SEG(STA_X|STA_R, 0x0, 0xffffffff)\t# code seg 设置代码段描述符\n  SEG(STA_W, 0x0, 0xffffffff)\t        # data seg 设置数据段描述符\n  # 关于SEG宏可以参考mmu.h\n\ngdtdesc:                                  # 用于设置全局段描述符寄存器\n  .word   0x17                            # sizeof(gdt) - 1 # Size of gdt\n  .long   gdt                             # address gdt # Base address of gdt\n```\n\n------\n\n看完了boot.s，我们还需要去理解main.c，同时我们需要了解以下内容。\n\n\n\n### > ELF文件格式\n\n可执行和可链接格式(Executable and Linkable Format)，相信学过计算机系统基础课程的朋友都不陌生（这一部分的详细内容可以参见CSAPP图书关于链接的详细章节）。简单来说ELF格式就是一种用于二进制文件、可执行文件、目标代码、共享库、核心转储格式文件。\n\nELF文件可以分为两种视图：链接视图（Linking View）和执行视图（Execution View）。在这里我们只描述执行视图：\n\n```\n+--------------------+\n|     ELF Header     |\n+--------------------+\n|Program Header Table|\n+--------------------+\n|      Segment 1     |\n+--------------------+\n|      Segment 2     |\n+--------------------+\n|         ...        |\n+--------------------+\n|Section Header Table|\n|       optinal      |\n+--------------------+\n```\n\nELF文件格式主要由ELF头（ELF Header）、程序头部表（Program Header Table）个节头表（Section Header Table），执行视图中，节头表是可选的。\n\n<img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gcfndwkks1j30go0g9gna.jpg\" alt=\"image-20200302160913062\" style=\"zoom:67%;\" />\n\n**注意：段（`Segment`）与节（`Section`）的区别。很多地方对两者有所混淆。段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中。相比而言，节的粒度更小。**\n\n有关于这些数据结构的C语言定义可以参考头文件<inc/elf.h>。\n\n- ELF头主要包含了ELF魔数、文件类型、程序头部表偏移和大小、程序入口等信息；\n- 程序头部表可以看做一个数据结构的数组，**每一个元素都描述了一个段。主要包含了段的偏移、段的虚拟地址、段的物理地址、段的大小等信息**。\n\n\n\n### > 磁盘控制器\n\n![image-20200302161557953](https://tva1.sinaimg.cn/large/00831rSTly1gcfnmnm2m6j305m09pjsc.jpg)\n\n![image-20200302161758369](https://tva1.sinaimg.cn/large/00831rSTly1gcfnn0xdabj305m08o0tk.jpg)\n\n磁盘是电脑的主要媒介。磁盘是由盘面构成的。每个盘面有两面或者称为表面，表面覆盖着磁性记录材料。盘面中央有一个可以旋转的主轴，使得盘面能够以固定的旋转速率旋转，通常为5400-15000转每分钟（Revolution Per Minute）。磁盘通常包含一个或多个这样的盘面，并且封装在一个密封的容器内。\n\n每一个表面是**由一组称为磁道的同心圆组成**。**每个磁道被划分为一组扇区**，**每个扇区的数据位是等大的（通常为512字节）**，这些数据编码在扇区上的磁性材料中。扇区之间由一些间隔分开，这些间隔中不存储数据位。间隔用来标识扇区的格式化位。\n\n磁盘的**柱面是所有盘片上到主轴中心距离相等的磁道的集合**。\n\n<img src=\"https://tva1.sinaimg.cn/large/00831rSTly1gcfnx1wkbbj30hq0fwwqb.jpg\" alt=\"image-20200302162737033\" style=\"zoom:50%;\" />\n\n对于磁盘的寻址通常分为CHS和LBA两种。\n\n1. CHS即柱面（cylinder）-磁头（head）-扇区（sector）寻址。每个盘片都对应着一个磁头，每一个盘片都被划分成柱面，每一个柱面都被划分成多个段。磁盘的最小存储单元是段。早期的IBM PC架构上采用CHS进行磁盘寻址。CHS是一个三元组，包括10bit的柱面号，8bit的磁头号以及6bit的扇区号。这样CHS的最大寻址范围为2^10 × 2^8 × 2^6 × 512 = 8GB。\n2. 随着磁盘容量的不断扩大，CHS的8GB寻址范围已经不能满足需要，现在的磁盘普遍采用逻辑区块地址（Logical Block Adress）的方式进行寻址来进行抽象。LBA是一个整数，代表磁盘上的一个逻辑区块编号，通过将这个整数转换成CHS格式来完成磁盘的具体寻址。LBA为48个bit，最大寻址范围为128PB。在本实验中，LBA按照旧的规范采用28个bit。\n\nIDE硬盘控制器（IDE Hard Drive Controller）的0x1F7端口读为磁盘0状态寄存器。\n其Bit6为RDY Bit，当其置1表明磁盘上电完成。在对于磁盘做任何操作（除了复位）之前务必要保证该Bit为1。\n其Bit7为BSY Bit，当其置1表明磁盘忙。在你向磁盘发送任何指令前务必保证该Bit为0。\n\n通过IDE硬盘控制器读取扇区需要如下的步骤：\n\n1. 向0x1F2端口写入待操作的扇区数目；\n2. 向0x1F3-0x1F5端口依次写入LBA的低24位；\n3. 向0x1F6端口的低4位写入LBA的高4位，向0x1F6端口的高4位写入驱动器地址；\n4. 向0x1F7端口写入读命令0x20。\n\n0x1F6寄存器又称Drive/Head寄存器。其低4位是LBA的高4位。其Bit5和Bit7一般是1。其Bit6为LBA位，当置1时表示启用LBA寻址。其Bit4为DRV位。用来选择驱动器，Master驱动器为0，Slave驱动器为1。这里将高4位置为0x1110\n\n在使用读命令0x20之前需要完整的设置柱面/磁头/扇区。当这个命令完成，你可以从磁盘的数据寄存器（0x1F0端口）读取256个字（16Bits）。\n\n------\n\n好了下面我们就开始看main.c。\n\n\n\n### 2.2 main.c 代码\n\n官方的代码注释中已经详细的介绍了代码作用以及BOOT UP的总体流程。务必仔细阅读代码的注释。\n\n```c\n#include <inc/elf.h>\n#include <inc/x86.h>\n/**********************************************************************\n * This a dirt simple boot loader, whose sole job is to boot\n * an ELF kernel image from the first IDE hard disk.\n *\n * DISK LAYOUT\n *  * This program(boot.S and main.c) is the bootloader.  It should\n *    be stored in the first sector of the disk.\n *\n *  * The 2nd sector onward holds the kernel image.\n *\n *  * The kernel image must be in ELF format.\n *\n * BOOT UP STEPS\n *  * when the CPU boots it loads the BIOS into memory and executes it\n *\n *  * the BIOS intializes devices, sets of the interrupt routines, and\n *    reads the first sector of the boot device(e.g., hard-drive)\n *    into memory and jumps to it.\n *\n *  * Assuming this boot loader is stored in the first sector of the\n *    hard-drive, this code takes over...\n *\n *  * control starts in boot.S -- which sets up protected mode,\n *    and a stack so C code then run, then calls bootmain()\n *\n *  * bootmain() in this file takes over, reads in the kernel and jumps to it.\n **********************************************************************/\n\n#define SECTSIZE 512\n#define ELFHDR ((struct Elf *)0x10000)    // scratch space  暂存空间\n\nvoid readsect(void *, uint32_t); //读磁盘扇区\nvoid readseg(uint32_t, uint32_t, uint32_t);//从内核的offset处读取count个字节到物理地址pa处\n\nvoid bootmain(void) {\n    struct Proghdr *ph, *eph;\n\n    // read 1st page off disk 从磁盘上读取第一页\n    readseg((uint32_t)ELFHDR, SECTSIZE * 8, 0);\n\n    // is this a valid ELF? 通过ELF魔数确认ELF有效\n    if (ELFHDR->e_magic != ELF_MAGIC) goto bad;\n\n    // load each program segment (ignores ph flags) 读取各个段\n  \t// ELF header里面指明了第一个program section header的位置。\n    // 也指明了最后一个位置在哪里\n    // [ph, end_of_program_header)这个区间\n    // 这里面表明了每个程序段的大小以及位置。\n    ph = (struct Proghdr *)((uint8_t *)ELFHDR + ELFHDR->e_phoff);\n    // 程序头部表的起始地址\n    eph = ph + ELFHDR->e_phnum;    // 程序头部表的结束地址\n    for (; ph < eph; ph++)\n        // p_pa is the load address of this segment (as well\n        // as the physical address)\n        // p_pa是加载地址也是物理地址\n        readseg(ph->p_pa, ph->p_memsz, ph->p_offset);\n\n    // call the entry point from the ELF header 从ELF头调用程序入口\n    // note: does not return!\n    ((void (*)(void))(ELFHDR->e_entry))();\n\nbad:\n    // stops simulation and breaks into the debug console\n    outw(0x8A00, 0x8A00);\n    outw(0x8A00, 0x8E00);\n    while (1) /* do nothing */;\n}\n\n// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.\n// 从内核的offset处读取count个字节到物理地址pa处\n// Might copy more than asked 可能会读取超过count个（扇区对齐）\nvoid readseg(uint32_t pa, uint32_t count, uint32_t offset) {\n    uint32_t end_pa;\n\n    end_pa = pa + count;    // 结束物理地址\n\n    // round down to sector boundary 对齐到扇区\n    pa &= ~(SECTSIZE - 1);\n\n    // translate from bytes to sectors, and kernel starts at sector 1\n    offset =\n        (offset / SECTSIZE) + 1;    // 算出扇区数 注意扇区从1开始（0为引导扇区）\n\n    // If this is too slow, we could read lots of sectors at a time.\n    // We'd write more to memory than asked, but it doesn't matter --\n    // we load in increasing order.\n    // 在实际中往往将多个扇区一起读出以提高效率。\n    while (pa < end_pa) {\n        // Since we haven't enabled paging yet and we're using\n        // an identity segment mapping (see boot.S), we can\n        // use physical addresses directly.  This won't be the\n        // case once JOS enables the MMU.\n        // 考虑到没有开启分页以及boot.S中使用了一一对应的映射规则，\n        // 加载地址和物理地址是一致的。\n        readsect((uint8_t *)pa, offset);\n        pa += SECTSIZE;\n        offset++;\n    }\n}\n\nvoid waitdisk(void) {\n    // wait for disk reaady 等待磁盘准备完毕。\n    while ((inb(0x1F7) & 0xC0) != 0x40) /* do nothing */;\n}\n\nvoid readsect(void *dst, uint32_t offset) {\n    // wait for disk to be ready\n    waitdisk();\n\n    outb(0x1F2, 1);    // count = 1 0x1F2 Disk 0 sector count\n    // Read one sector each time\n    outb(0x1F3, offset);    // Disk 0 sector number (CHS Mode)\n    // First sector's number\n    outb(0x1F4, offset >> 8);     // Cylinder low (CHS Mode)\n    outb(0x1F5, offset >> 16);    // Cylinder high (CHS Mode)\n    // Cylinder number\n    outb(0x1F6, (offset >> 24) | 0xE0);    // Disk 0 drive/head\n    // MASK 11100000\n    // Drive/Head Register: bit 7 and bit 5 should be set to 1\n    // Bit6: 1 LBA mode, 0 CHS mode\n    outb(0x1F7, 0x20);    // cmd 0x20 - read sectors\n    /*20H       Read sector with retry. NB: 21H = read sector\n                without retry. For this command you have to load\n                the complete circus of cylinder/head/sector\n                first. When the command completes (DRQ goes\n                active) you can read 256 words (16-bits) from the\n                disk's data register. */\n\n    // wait for disk to be ready\n    waitdisk();\n\n    // read a sector\n    insl(0x1F0, dst, SECTSIZE / 4);\n    // Data register: data exchange with 8/16 bits\n    // insl port addr cnt: read cnt dwords from the input port\n    // specified by port into the supplied output array addr.\n    // dword: 4 bytes = 16 bits\n}\n```\n\n------\n\n我们看完了boot.s和main.c就大概知道了BootLoader的流程，下面让我们用gdb实际调试跟踪一下哈。在此之前我们先打开`/obj/boot/boot.asm`，这个汇编文件是我们的GNUmakefile在编译boot loader之后实际生成的机器码经过反汇编得到的。我们之前已经分析了boot.s和main.c，之所以要在这里看boot.asm是为了能够得到代码实际运行时的物理地址，也就是说为我们gdb调试进行服务的哈。\n\n同时，我们经过BootLoader加载的jos kernal实际上在`/obj/kernal/kernal.asm`文件中。\n\n**exercise 3:**\n\n现在我们仍然在qemu启动时，使用gdb在地址0x7c00的地方打一个断点`b *0x7c00`，这是boot sector被加载过程的起始代码地址。我们从这个断点开始，根据boot.asm中的地址继续跟踪。\n\n![image-20200302172636927](https://tva1.sinaimg.cn/large/00831rSTly1gcfpmfrg2tj309o04e0sw.jpg)\n\n果然我们现在来到了程序起始的关中断指令。然后我们跟着流程走一遍很快就会走完boot.s。\n\n紧接着我们需要执行0x7c45处的代码，也就是将程序交给main.c接管，也就是下图的call指令。\n\n![image-20200302173124668](https://tva1.sinaimg.cn/large/00831rSTly1gcfprf7b3hj30a802a3yj.jpg)\n\n我们继续跟踪到bootmain函数中，根据之前的分析bootmain需要调用readseg()，从磁盘中读操作系统内核，而readseg()实际上是调用了一系列的readsect()函数读取磁盘扇区。我们把这一系列指令都执行一遍之后，来回答下面的四个问题。\n\n1. At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode? 处理器是什么时候开始执行32位的代码？什么原因导致了16位模式切换到32位模式？\n\n这一步实际上就在地址0x7c2d的ljmp指令，从这句汇编指令执行完之后可见gdb调试界面输出 The target architecture is assumed to be i386。原因就是ljmp指令。\n\n![image-20200302173526768](https://tva1.sinaimg.cn/large/00831rSTly1gcfpvmih7hj30a502caa4.jpg)\n\n2. What is the *last* instruction of the boot loader executed, and what is the *first* instruction of the kernel it just loaded?boot loader执行的最后一条指令和kernal加载的第一条指令分别是什么？\n\n![image-20200302174416401](https://tva1.sinaimg.cn/large/00831rSTly1gcfq4tg0i4j30a302g0ss.jpg)\n\n一图解决，boot loader最后一条指令显然就是call指令，也就是说将控制权交给加载好的kernal接管。而kernal执行的第一条指令是`movw $0x1234, 0x472`。\n\n3. *Where* is the first instruction of the kernel?内核的第一条指令在哪？\n\n上面那张图其实就说明了，就在0x10000c。\n\n4. How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?引导加载程序如何确定必须读多少个扇区才能从磁盘获取整个内核？它从哪里读取到这个信息？\n\n有意思的来了哈，这就需要对main.c中的bootmain函数进行理解了，上文已经解释过了。这里实际上就是引导从程序头部表中得到了段的数目以及每个段的大小，然后决定了要从磁盘上读多少个扇区。\n\n\n\n###  2.3 Loading the Kernal\n\n为了有更好的学习体验，在此我们必须确保对C语言指针的知识有充分了解。\n\n**exercise4：**\n\n阅读C语言指针，下载pointer.c，编译运行并且确保能够理解。\n\npointer.c的代码和解释如下：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid f(void) {\n    int  a[4];    // 含有4个元素的整形数组\n    int *b =\n        malloc(16);    // 分配16个字节的内存，并且用一个整形指针指向内存首地址\n    int *c;    // 一个悬挂的整形指针\n    int  i;    // 一个整形数\n\n    printf(\"1: a = %p, b = %p, c = %p\\n\", a, b, c);\n    // 打印a和b和c的地址，分别为0xff9bebcc, 0x566fc160和0xf7ede1e8\n\n    c = a;\n    // 令c指向数组a的首地址\n    for (i = 0; i < 4; i++) a[i] = 100 + i;    // 为a[0]到a[3]分配100-103\n    c[0] = 200;                                // 将c[0]也就是a[0]改为200\n    printf(\"2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],\n           a[3]);\n    // 输出200 101 102 103\n\n    c[1]     = 300;    // 将c[1]也就是a[1]改为300\n    *(c + 2) = 301;    //将*(c + 2)也就是a[2]改为301\n    3 [c]    = 302;    // 将3[c]也就是c[3]改为302\n    printf(\"3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],\n           a[3]);\n    // 输出200 300 301 302\n\n    c  = c + 1;    // 令c指向a[1]\n    *c = 400;      // 将a[1]改为400\n    printf(\"4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],\n           a[3]);\n    // 输出200 400 301 302\n\n    c = (int *)((char *)c + 1);\n    // 将c先转换为char指针指向下一个字节后再转回int指针\n    // 现在a数组的字节分布为（小端）C8000000 90010000 2D010000 2E010000\n    | (c的指针)*c = 500;\n    // 执行后的a数组字节分布（小端）C8000000 90F40100 00010000 2E010000\n    printf(\"5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n\", a[0], a[1], a[2],\n           a[3]);\n    // 输出200 128144 256 302\n\n    b = (int *)a + 1;\n    // 将b指向a[1]\n    c = (int *)((char *)a + 1);\n    // 将a先转换为char指针指向下一个字节后再转回int指针\n    printf(\"6: a = %p, b = %p, c = %p\\n\", a, b, c);\n    // 输出0xff9bebcc, 0xff9bebd0和0xff9bebcd\n}\n\nint main(int ac, char **av) {\n    // 函数入口\n    f();\n    return 0;\n}\n```\n\n为了接下来的实验，我们仍然需要对ELF文件格式有深入了解。至于此部分，详细的介绍全部都在[ELF specfication](https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf)。\n\n简单来说一些除了上文介绍过的结构以外的基本知识。复习一下上文哦，ELF二进制文件是从一个固定长度的ELF头部开始的，然后是程序头表(program header)列出程序要加载的每个程序段，在之后是节头表(section header)。我们要关注几个程序节：\n\n* .text：存放可执行执行程序指令\n* .rodata：存放只读数据，比如一些由编译器生成的ASCII\n* .data：已初始化的数据部分\n* .bss：未赋值的全局变量\n\n在这里我们尝试使用`objdump -h obj/kern/kernel`，看到dump之后的ELF文件信息如下图。其中`-h`参数的意义是显示头部摘要信息。\n\n```\nobj/kern/kernel:\tfile format ELF32-i386\n\nSections:\nIdx Name          Size      Address          Type\n  0               00000000 0000000000000000\n  1 .text         00001736 00000000f0100000 TEXT\n  2 .rodata       00000714 00000000f0101740 DATA\n  3 .stab         00004195 00000000f0101e54 DATA\n  4 .stabstr      0000194b 00000000f0105fe9\n  5 .data         0000a300 00000000f0108000 DATA\n  6 .bss          00000648 00000000f0112300 DATA\n  7 .comment      00000011 0000000000000000\n  8 .debug_info   00001811 0000000000000000\n  9 .debug_abbrev 00000486 0000000000000000\n 10 .debug_loc    00000eef 0000000000000000\n 11 .debug_aranges 00000040 0000000000000000\n 12 .debug_ranges 00000070 0000000000000000\n 13 .debug_line   000006fc 0000000000000000\n 14 .debug_str    00000b87 0000000000000000\n 15 .symtab       000006b0 0000000000000000\n 16 .strtab       00000343 0000000000000000\n 17 .shstrtab     000000a5 0000000000000000\n```\n\n有一说一，节头表的内容还是比列出的那几个多很多的。\n\n在.text节中，地址分为\"VMA\"(link address)和\"LMA\"(load address)，load address也就是加载地址，就是该节需要被加载到内存中的地址；link address也就是链接地址，是该节期望从中执行的内存地址。这次我们来看看boot.out。\n\n我们仍然使用指令`objdump -h obj/boot/boot.out`并换成参数`-x`。参数`-x`说明了显示可使用的头信息，包括符号表、重定位入口等。：\n\n```\nobj/boot/boot.out:\tfile format ELF32-i386\n\nSections:\nIdx Name          Size      Address          Type\n  0               00000000 0000000000000000\n  1 .text         0000018c 0000000000007c00 TEXT\n  2 .eh_frame     0000009c 0000000000007d8c DATA\n  3 .stab         00000744 0000000000000000\n  4 .stabstr      000008e1 0000000000000000\n  5 .comment      00000011 0000000000000000\n  6 .symtab       00000190 0000000000000000\n  7 .strtab       000000a7 0000000000000000\n  8 .shstrtab     00000043 0000000000000000\n```\n\n```\nobj/boot/boot.out:\tfile format ELF32-i386\n\nSections:\nIdx Name          Size      Address          Type\n  0               00000000 0000000000000000\n  1 .text         0000018c 0000000000007c00 TEXT\n  2 .eh_frame     0000009c 0000000000007d8c DATA\n  3 .stab         00000744 0000000000000000\n  4 .stabstr      000008e1 0000000000000000\n  5 .comment      00000011 0000000000000000\n  6 .symtab       00000190 0000000000000000\n  7 .strtab       000000a7 0000000000000000\n  8 .shstrtab     00000043 0000000000000000\n---\n此处略去了symbol table\n---\nProgram Header:\n    LOAD off    0x00000054 vaddr 0x00007c00 paddr 0x00007c00 align 2**2\n         filesz 0x00000228 memsz 0x00000228 flags rwx\n```\n\n我们可以看到最后几行的program header程序头，需要被加载到内存中的区域已经被标记为LOAD，所有程序头的信息都已经被给出，比如vaddr（虚拟地址）以及paddr（物理地址）。\n\n这实际上就解释了BootLoader中读ELF的作用，就是将不同的section加载到不同的地址。\n\n这次我们使用指令`objdump -x obj/kern/kernel`。\n\n```\nobj/kern/kernel:\tfile format ELF32-i386\n\nSections:\nIdx Name          Size      Address          Type\n  0               00000000 0000000000000000\n  1 .text         00001736 00000000f0100000 TEXT\n  2 .rodata       00000714 00000000f0101740 DATA\n  3 .stab         00004195 00000000f0101e54 DATA\n  4 .stabstr      0000194b 00000000f0105fe9\n  5 .data         0000a300 00000000f0108000 DATA\n  6 .bss          00000648 00000000f0112300 DATA\n  7 .comment      00000011 0000000000000000\n  8 .debug_info   00001811 0000000000000000\n  9 .debug_abbrev 00000486 0000000000000000\n 10 .debug_loc    00000eef 0000000000000000\n 11 .debug_aranges 00000040 0000000000000000\n 12 .debug_ranges 00000070 0000000000000000\n 13 .debug_line   000006fc 0000000000000000\n 14 .debug_str    00000b87 0000000000000000\n 15 .symtab       000006b0 0000000000000000\n 16 .strtab       00000343 0000000000000000\n 17 .shstrtab     000000a5 0000000000000000\n---\n此处仍然略去了symbol table\n---\nProgram Header:\n    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12\n         filesz 0x00007934 memsz 0x00007934 flags r-x\n    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12\n         filesz 0x0000a948 memsz 0x0000a948 flags rw-\n\nDynamic Section:\n```\n\n我们可以看到最后几行的program header程序头，需要被加载到内存中的区域已经被标记为LOAD，所有程序头的信息都已经被给出，比如vaddr（虚拟地址）以及paddr（物理地址）。\n\n这里保留一个疑惑：记不记得我们之前通过gdb调试的时候，call指令交给kernal接管操作系统的地址是`0x10000c`，为什么这里LOAD的是`0x100000`？\n\n**exercise5:**\n\n这次我们魔改一下`boot/Makefrag`，我们手动把链接到的.text地址改成一个错误的地址，然后运行指令`make clean`，我们再启动qemu，看看瞎引导会发生什么后果。\n\n![image-20200303160457185](https://tva1.sinaimg.cn/large/00831rSTly1gcgsvs038rj30dz02v74f.jpg)\n\n我们把这个0x7c00给他改了：\n\n![image-20200303161125681](https://tva1.sinaimg.cn/large/00831rSTly1gcgt2ioj44j30os09lq5l.jpg)\n\n谢谢，有被秀到。整个引导因为错误，提前中止了。\n\n然后我们似乎忘记了另一个地址：link address。这就是ELF header中另一个很重要的内容：e_entry。这标记了程序入口点：程序段中程序开始执行的入口内存地址，\n\n我们使用`objdump -f obj/kern/kernel`：\n\n```\nobj/kern/kernel:\tfile format ELF32-i386\n\narchitecture: i386\nstart address: 0x0010000c\n```\n\n这就把上文的疑惑解决了，因为上文的地址是.text段的起始地址，而真正开始执行的地址则是link address。\n\n**exercise 6:**\n\n这波啊，这波我们在之前已经知道kernal加载的内存地址了，我们在BIOS启动过程中就用gdb的`x/Nx addr`指令查看一下从0x10000开始的位置。\n\n然后再次，我们将BootLoader加载kernal之后再使用同样的指令，看看有什么区别没。\n\n我们先直接在引导过程就使用指令查看：\n\n![image-20200303162511445](https://tva1.sinaimg.cn/large/00831rSTly1gcgtgu4kwgj315d034dgo.jpg)\n\n然后我们等执行到bootmain交给kernal接管时，再次使用指令：\n\n![image-20200303163342172](https://tva1.sinaimg.cn/large/00831rSTly1gcgtpoyrnhj30f204c74q.jpg)\n\n懂得都懂，因为BootLoader本身就是把kernal加载到内存中，所以第二次使用指令查看到的就是加载kernal之后的有效内存。我们甚至可以继续看看kernel.asm：\n\n![image-20200303163523218](https://tva1.sinaimg.cn/large/00831rSTly1gcgtrg363nj30c101ea9z.jpg)\n\n看看这个entry的机器码，是不是和0x10000c处的0x7205c766指令对上了？\n\n\n\n## Part 3: The Kernel\n\n\n\n### 3.1 Using virtual memory to work around position dependence\n\n当你观察了链接器加载的内存，你发现内核实际上将自己链接到了非常高的虚拟地址，比如0xf010000，为了将处理器虚拟地址的较低部分交给用户的程序去使用。这个现象将在下一个实验中被介绍。\n\n而实际上，许多机器在物理内存中并没有0xf0100000这样的高地址。也就是说，处理器的内存管理硬件将虚拟地址0xf0100000映射到了实际内存中的物理地址0x0010000（BootLoader将kernel加载到的物理内存）。\n\n在`kern/entry.S`将CR0_FG进行标记之前（还记着这个标志位吗？开保护模式用的），我们的内存引用被当作线性地址。实际上由于`boot/boot.S`设置了线性地址到物理地址的一致映射，我们可以认为线性地址就等同于物理地址。\n\n当CR0_FG被标记之后，所有的内存就是虚拟地址了。虚拟地址通过虚拟内存硬件被翻译成物理地址。\n\n`kern/entrypgdir.c`将0xf0000000-0xf0400000的虚拟地址翻译为物理地址的0x00000000-0x00400000，同时也将0x00000000-0x00400000的虚拟地址翻译为0x00000000-0x00400000。\n\n引用这些范围以外的虚拟地址就会抛出缺页异常。但是现在我们还没有为该异常设置中断程序，所以这就会导致qemu直接退出。\n\n**exercise 7:**\n\n使用qemu和gdb追踪kernel然后停留在`movl %eax, %cr0`。然后此时检查地址0x00100000和0xf0100000。使用`si`指令前进一步再次检查这两个地址。\n\n我们先停留到标记cr0之前进行检查：\n\n![image-20200303170039419](https://tva1.sinaimg.cn/large/00831rSTly1gcguhqethvj30bg057t96.jpg)\n\n\n\n我们看出，此时还没有设置cr0也就是虚拟内存管理硬件并没有将0xf0100000进行映射。\n\n然后执行下一步再次查看：\n\n![image-20200303170133220](https://tva1.sinaimg.cn/large/00831rSTly1gcguio4zokj30f003b3ys.jpg)\n\n确实，这时页表已经启动了，地址映射就此完成。\n\n\n\n### 3.2 Formatted Printing to the Console\n\n这里我们需要了解print()是如何在底层实现的。\n\n首先我们要阅读`kern/printf.c`, `lib/printfmt.c`以及`kern/console.c`。理解一下他们之间的关系。\n\n**exercise 8:**\n\n我们需要补全未完成的 print \"%o\"格式，其实很简单，只要参照上面的\"%d\"即可，注意这里我们处理的是无符号数。\n\n```c\n\t\tcase 'o':\n\t\t\t// Replace this with your code.\n//\t\t\tputch('X', putdat);\n//\t\t\tputch('X', putdat);\n//\t\t\tputch('X', putdat);\n            num = getuint(&ap, lflag);\n            base = 8;\n            goto number;\n\t\t\tbreak;\n```\n\n同时我们需要理解这些文件之间的关系。\n\n1. printf.c以及console.c之间的关系是什么？同时console.c导出的函数是什么，且如何被printf.c使用？\n\nconsole.c是由kernel使用了一系列I/O序列号，提供了基本的I/O操作，然后同时封装了cputchar()、getchar()等函数用于提供printf.c中printf的使用。printf使用了vprintfmt去解析格式化字符串并且提供可变参数的特性。\n\nprint.c的调用链：`cprintf -> vcprintf -> vprintfmt -> putch -> cputchar`。\n\n2. console.c中如下的代码含义？\n\n```c\n//一页写满，滚动一行\nif (crt_pos >= CRT_SIZE) {\n       \tint i;\n  \t// 把从第1~n行的内容复制到0~(n-1)行，第n行未变化\n    // 通过这一行代码完成了整个屏幕向上移动一行的操作。\n        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));\n  \t// 把最后一行清空\n        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)\n            crt_buf[i] = 0x0700 | ' ';\n  \t// 清空了最后一行，同步crt_pos\n        crt_pos -= CRT_COLS;\n    }\n```\n\n3. For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.\n\n单步执行以下代码：\n\n```c\nint x = 1, y = 3, z = 4;\ncprintf(\"x %d, y %x, z %d\\n\", x, y, z);\n```\n\n这里我们需要在`/kern/monitor.c`的monitor函数中插入这段代码。\n\ntips：GNUmakefile中的C_FLAGS -O1优化会重排C代码，这样的话一会儿单步执行时追踪va_arg会变得非常困难，在此处将-O1先变为-O0（尽管这会导致backtrace时的kernal panic）。\n\n![image-20200303182914110](https://tva1.sinaimg.cn/large/00831rSTly1gcgx1wqqppj30ui05gznq.jpg)\n\n配置好之后，我们直接开始在`b kern/monitor.c:118`打断点（别问，就是可以这样断点）\n\n![image-20200303183912619](https://tva1.sinaimg.cn/large/00831rSTly1gcgxcadv6jj30db07o75a.jpg)\n\n我们现在就进入va_start(ap, fmt)。\n\n```\ncprintf(\"x %d, y %x, z %d\\n\",x, y, z);\ncprintf (fmt=0xf0101aae \"x %d, y %x, z %d\\n\") at kern/printf.c:31\nva_start(ap, fmt)\nvcprintf (fmt=0xf0101aae \"x %d, y %x, z %d\\n\", ap=0xf010ff64 \"\\001\") at kern/printf.c:19\n\n(gdb) x/1x 0xf010ff64\n0xf010ff64:\t0x00000001\n```\n\n可见fmt就是我们的格式化字符串\"x %d, y %x, z %d\\n\"，ap指向了局部变量0xf010ff64初始为1。\n\n为了保证接下来的过程能够理解清楚，我们需要了解cprintf()函数里面的一系列调用：\n\n```c\ncprintf(const char *fmt, ...)\n{\n        va_list ap;\n        int cnt;\n        va_start(ap, fmt);\n        cnt = vcprintf(fmt, ap);\n        va_end(ap);\n        return cnt;\n}\n```\n\n要注意这个va_start等va_开头的都是一个宏里面的内容：\n\n```c\ntypedef __builtin_va_list va_list;\n#define va_start(ap, last) __builtin_va_start(ap, last)\n#define va_arg(ap, type) __builtin_va_arg(ap, type)\n#define va_end(ap) __builtin_va_end(ap)\n```\n\n这个宏已经由gcc提供了，我们要阅读代码知道这个宏的作用：\n\n```c\n// 指针定义为char *可以指向任意一个内存地址。\ntypedef char *va_list;\n// 类型大小，注意这里是与CPU位数对齐 ＝ sizeof(long)的作用。\n#define    __va_size(type) \\\n    (((sizeof(type) + sizeof(long) - 1) / sizeof(long)) * sizeof(long))\n\n// 这里个宏并不是取得参数的起始地址。而是说参数将从什么地址开始放。\n#define    va_start(ap, last) \\\n    ((ap) = (va_list)&(last) + __va_size(last))\n\n// va_arg就是用来取参数的起始地址的。然后返回type类型。\n// 从整个表达式的意义来说没有什么好用的。\n// 其实等价于(*(type*)ap)\n// 但是实际上使ap指针移动一个参数大小。\n#define    va_arg(ap, type) \\\n    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))\n\n// 空指令，没有什么用\n#define    va_end(ap)    ((void)0)\n```\n\n所以实际上该操作就是栈操作，从高地址向低地址压栈，并且压栈的时候类型与long对齐，就是说即使压入一个char，我们也要对栈空间以long的大小进行对齐。压入5个char = 需要两个long的空间。\n\n所以回到原来的代码，fmt就是指向const char * 我们的格式化字符串，开始调用时栈结构如下：\n\n```c\n+-----------------+\n|                 |\n|     Z           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     Y           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     X           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     fmt         |\n|                 |\n|                 |\n+-----------------+ <-----------+&fmt\n\n```\n\n然后接下来cprintf需要调用va_start()：\n\n```c\nva_start(fmt, ap) 作用如下\n#define    va_start(ap, last) \\\n    ((ap) = (va_list)&(last) + __va_size(last))\n展开就是\nap = (char *)(&fmt) + align_long(fmt);\n+-----------------+\n|                 |\n|     Z           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     Y           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     X           |\n|                 |\n|                 |\n+-----------------+ <--------------+ap\n|                 |\n|     fmt         |\n|                 |\n|                 |\n+-----------------+\n```\n\n然后进一步调用vcprint至vprintfmt到输出\n\n```c\nvoid\nvprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)\n{\n    while (1) {\n        // 如果只是一般的字符串，直接输出。\n        while ((ch = *(unsigned char *) fmt++) != '%') {\n            if (ch == '\\0')\n                return;\n            putch(ch, putdat);\n        }\n        // 如果发现是%c\n    reswitch:\n        // 先把%号跳掉，取出'c'\n        switch (ch = *(unsigned char *) fmt++) {\n        // .. \n        case 'c':\n            putch(va_arg(ap, int), putdat);\n            break;\n        }\n    }\n}\n```\n\n我们就明白了，根据当前参数栈的位置，通过fmt解析出参数的类型，拿出特定长度的参数。就是这样。\n\n接下来的过程只是逐步重复：\n\n```c\nva_arg(ap, int) 展开后就是\n#define    va_arg(ap, type) \\\n    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))\n// putat用来统计输出的字符的个数。在这里可以不用去管\nchar temp = *(char*)ap;\nputch(temp, putdat); // 输出到console上。\nap += align_long(char);\n执行完成之后。\n+-----------------+\n|                 |\n|     Z           |\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     Y           |\n|                 |\n|                 |\n+-----------------+ <------+ap\n|                 |\n|     X           |   这个x会被%d提出来进行输出。\n|                 |\n|                 |\n+-----------------+\n|                 |\n|     fmt         |\n|                 |\n|                 |\n+-----------------+\n```\n\n这样我们就明白了实际上是如何调用的。\n\n4. 运行以下代码，会输出什么：\n\n```c\nunsigned int i = 0x00646c72;\ncprintf(\"H%x Wo%s\", 57616, &i);\n-----------------------------------------------------------------------------------\n57616 = 0xE110。\ni = 0x00646c72\n//那么如果把i占用的4byte转换成为char[4]数组。结果就是：\nchar str[4] = {0x72, 0x6c, 0x64, 0x00}; // = {'r', 'l', 'd', 0}\n//所以输出就是\nHell0 World\n```\n\n5. cprintf(\"x=%d y=%d\", 3) 该代码的输出？\n\n这种栈越界行为，显然无法判定操作，因为不知道越界位置的内存放的是什么内容。\n\n\n\n### 3.3 The Stack\n\n在这个环节中，我们将了解x86程序对于堆栈的使用。\n\n**exercise 9:**\n\n确定内核堆栈初始化的位置，以及堆栈在内存中的确切位置。内核如何为其堆栈保留空间？并在此保留区的哪个“末端”初始化堆栈指针指向？\n\n这就又回到kernel了，我们看一下kernel的代码过程中配置%esp的部分：\n\n![image-20200303195812344](https://tva1.sinaimg.cn/large/00831rSTly1gcgzmh0a76j30e907x75i.jpg)\n\n```assembly\nf0100034:\tbc 00 00 11 f0       \tmov    $0xf0110000,%esp\n```\n\n也就是这一条指令初始化了栈指针。\n\n栈指针`esp`寄存器指向当前栈的栈顶（低地址），栈顶的下面（更低的地址）都是栈的可用空间。push和pop就对应着esp指针的变化。\n\n相比之下`ebp`寄存器主要通过软件约定与堆栈进行关联。也就是C函数调用时其初始总是将前一个函数的base pointer压入栈中，然后使用ebp来拷贝此时的esp之后，再让栈空间以及esp进行变化。\n\n关于调用栈仍然没必要详细介绍了，这个还是需要阅读\"CSAPP\"第三章关于栈的内容。\n\n**exercies 10:**\n\n为了更加熟悉x86中C的函数调用和栈帧，我们在`obj/kern/kernel.asm`中的test_backtrace函数设置一个端点，检查内核每一次启动后调用它会发生什么。每个递归嵌套的test_backtrace嵌套级别将多少个32位字压栈？这些字是什么？\n\n我们先找到kernel中`test_backtrace`的位置：\n\n![image-20200303201438802](https://tva1.sinaimg.cn/large/00831rSTly1gch03m6rnhj30dt022dfz.jpg)\n\n然后在该起始地址0xf0100040处打断点。使用`info frame`查看栈：\n\n```assembly\n(gdb) info frame\nStack level 0, frame at 0xf010ffe0:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf01000d4\n called by frame at 0xf0110000\n source language c.\n Arglist at 0xf010ffd8, args: x=5\n Locals at 0xf010ffd8, Previous frame's sp is 0xf010ffe0\n Saved registers:\n  eip at 0xf010ffdc\n ----------------------------------------------------------------------------------\n (gdb) info frame\nStack level 0, frame at 0xf010ffc0:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf0100068\n called by frame at 0xf010ffe0\n source language c.\n Arglist at 0xf010ffb8, args: x=4\n Locals at 0xf010ffb8, Previous frame's sp is 0xf010ffc0\n Saved registers:\n  eip at 0xf010ffbc\n ----------------------------------------------------------------------------------\n (gdb) info frame\nStack level 0, frame at 0xf010ffa0:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf0100068\n called by frame at 0xf010ffc0\n source language c.\n Arglist at 0xf010ff98, args: x=3\n Locals at 0xf010ff98, Previous frame's sp is 0xf010ffa0\n Saved registers:\n  eip at 0xf010ff9c\n  ---------------------------------------------------------------------------------\n  (gdb) info frame\nStack level 0, frame at 0xf010ff80:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf0100068\n called by frame at 0xf010ffa0\n source language c.\n Arglist at 0xf010ff78, args: x=2\n Locals at 0xf010ff78, Previous frame's sp is 0xf010ff80\n Saved registers:\n  eip at 0xf010ff7c\n  ---------------------------------------------------------------------------------\n  (gdb) info frame\nStack level 0, frame at 0xf010ff60:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf0100068\n called by frame at 0xf010ff80\n source language c.\n Arglist at 0xf010ff58, args: x=1\n Locals at 0xf010ff58, Previous frame's sp is 0xf010ff60\n Saved registers:\n  eip at 0xf010ff5c\n  ---------------------------------------------------------------------------------\n  (gdb) info frame\nStack level 0, frame at 0xf010ff40:\n eip = 0xf0100040 in test_backtrace (kern/init.c:13); saved eip = 0xf0100068\n called by frame at 0xf010ff60\n source language c.\n Arglist at 0xf010ff38, args: x=0\n Locals at 0xf010ff38, Previous frame's sp is 0xf010ff40\n Saved registers:\n  eip at 0xf010ff3c\n```\n\n本题考察了x86架构下的栈帧与函数调用。有一说一，每次到栈帧我都要重学一遍。\n\n#### >> 函数调用\n\n函数调用分为以下几步:\n\n- 参数入栈: 将参数按照调用约定(C 是从右向左)依次压入系统栈中;\n\n- 返回地址入栈: 将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行;\n\n- 代码跳转: 处理器将代码区跳转到被调用函数的入口处;\n\n- 栈帧调整:  \n\n  1.将调用者的ebp压栈处理，保存指向**调用者栈底**的ebp的地址（方便函数返回之后的现场恢复），此时esp指向新的栈顶位置； `push ebp` \n  2.将当前栈帧切换到新栈帧(将eps值装入ebp- `mov esp, ebp`更新栈帧底部为**被调用者栈底**)\n  3.给新栈帧分配空间 `sub esp, XXX`（这些空间用于临时变量，操作时用ebp-x存取）\n\n#### >> 函数返回\n\n函数返回分为以下几步:\n\n- 保存被调用函数的返回值到 eax 寄存器中 `mov eax, xxx`\n- 恢复 esp 同时回收局部变量空间 `mov ebp, esp`\n- 将上一个栈帧底部位置恢复到 ebp `pop ebp`\n- 弹出当前栈顶元素,从栈中取到返回地址,并跳转到该位置 `ret`\n\n**exercise 11:**\n\n阅读完上述代码后，在`kern/monitor.c`中实现一个`mon_backtrace()`函数。请使用`inc/x86.h`中的`read_ebp()`。我们要先阅读`obj/kern/kernel.asm`中注意到，初始的ebp分配为0:\n\n![image-20200303214913263](https://tva1.sinaimg.cn/large/00831rSTly1gch2tzr5k6j30do028q34.jpg)\n\n```c\nint\nmon_backtrace(int argc, char **argv, struct Trapframe *tf)\n{\n\t// Your code here.\n\tuint32_t ebp = read_ebp();\n\t#define TO_INT(x) *((uint32_t *)(x))\n\twhile(ebp){\n\t\tcprintf(\"ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\\n\",\n\t\t\t\tTO_INT(ebp),\t\t /*ebp*/\n\t\t\t\tTO_INT((ebp + 4)),   /*eip*/\n\t\t\t\tTO_INT((ebp + 8)),   /*arg1*/\n\t\t\t\tTO_INT((ebp + 12)),  /*arg2*/\n\t\t\t\tTO_INT((ebp + 16)),  /*arg3*/\n\t\t\t\tTO_INT((ebp + 20)),  /*arg4*/\n\t\t\t\tTO_INT((ebp + 24))); /*arg5*/\n\t\tebp = TO_INT(ebp);\n\t}\n\treturn 0;\n}\n```\n\n重新make观察qemu的输出即可。\n\n![image-20200303215034236](https://tva1.sinaimg.cn/large/00831rSTly1gch2ve0p0lj30k00bq74v.jpg)\n\n\n\n**exercise 12:**\n\n这次我们需要修改`stack backtrace`函数，让它显示每一个`eip, func_name, source_file_name, line_number`。为了帮助实现这些功能，在`kern/kdebug.c`中已经实现了一个函数`debuginfo_eip()`，这个函数能够查找eip的符号表然后返回关于该地址的debug信息。\n\n1. 在实现好的debuginfo_eip()中，`__STAB_*`这些信息是从哪来的？\n\n- look in the file `kern/kernel.ld` for `__STAB_*`\n\n我们找到了链接脚本\n\n```\n.stab : {\n\t\tPROVIDE(__STAB_BEGIN__ = .);\n\t\t*(.stab);\n\t\tPROVIDE(__STAB_END__ = .);\n\t\tBYTE(0)\t\t/* Force the linker to allocate space\n\t\t\t\t   for this section */\n\t}\n\n\t.stabstr : {\n\t\tPROVIDE(__STABSTR_BEGIN__ = .);\n\t\t*(.stabstr);\n\t\tPROVIDE(__STABSTR_END__ = .);\n\t\tBYTE(0)\t\t/* Force the linker to allocate space\n\t\t\t\t   for this section */\n\t}\n```\n\n`__STAB_BEGIN__,__STAB_END__, __STABSTR_BEGIN__, __STABSTR_END__`等符号均在kern/kern.ld文件定义，它们分别代表.stab和.stabstr这两个段开始与结束的地址。\n\n- run objdump -h obj/kern/kernel (`-h`是显示头部摘要)\n\n```\nobj/kern/kernel:\tfile format ELF32-i386\n\nSections:\nIdx Name          Size      Address          Type\n  0               00000000 0000000000000000\n  1 .text         000017b2 00000000f0100000 TEXT\n  2 .rodata       00000758 00000000f01017c0 DATA\n  3 .stab         00004285 00000000f0101f18 DATA\n  4 .stabstr      00001956 00000000f010619d\n  5 .data         0000a300 00000000f0108000 DATA\n  6 .bss          00000648 00000000f0112300 DATA\n  7 .comment      00000011 0000000000000000\n  8 .debug_info   00001811 0000000000000000\n  9 .debug_abbrev 00000486 0000000000000000\n 10 .debug_loc    00000eef 0000000000000000\n 11 .debug_aranges 00000040 0000000000000000\n 12 .debug_ranges 00000070 0000000000000000\n 13 .debug_line   000006fc 0000000000000000\n 14 .debug_str    00000b87 0000000000000000\n 15 .symtab       000006b0 0000000000000000\n 16 .strtab       00000343 0000000000000000\n 17 .shstrtab     000000a5 0000000000000000\n```\n\n在这里我们看到了Idx为4的.stabstr段\n\n- run objdump -G obj/kern/kernel （只显示部分）\n\n```\nobj/kern/kernel:     file format elf32-i386\nContents of .stab section:\nSymnum n_type n_othr n_desc n_value  n_strx String\n-1     HdrSym 0      1294   00001973 1\n0      SO     0      0      f0100000 1      {standard input}\n1      SOL    0      0      f010000c 18     kern/entry.S\n2      SLINE  0      44     f010000c 0\n15     OPT    0      0      00000000 49     gcc2_compiled.\n16     LSYM   0      0      00000000 64     int:t(0,1)=r(0,1);-2147483648;2147483647;\n17     LSYM   0      0      00000000 106    char:t(0,2)=r(0,2);0;127;\n108    FUN    0      0      f0100040 2946   test_backtrace:F(0,25)\n118    FUN    0      0      f01000a6 2987   i386_init:F(0,25)\n```\n\n\n\n- run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.\n\n```\n.file   \"init.c\"\n.stabs  \"kern/init.c\",100,0,2,.Ltext0\n.text\n.Ltext0:\n.stabs  \"gcc2_compiled.\",60,0,0,0\n.stabs  \"int:t(0,1)=r(0,1);-2147483648;2147483647;\",128,0,0,0\n.stabs  \"char:t(0,2)=r(0,2);0;127;\",128,0,0,0\n.stabs  \"long int:t(0,3)=r(0,3);-0;4294967295;\",128,0,0,0\n.stabs  \"unsigned int:t(0,4)=r(0,4);0;4294967295;\",128,0,0,0\n.stabs  \"long unsigned int:t(0,5)=r(0,5);0;-1;\",128,0,0,0\n.stabs  \"long double:t(0,16)=r(0,1);16;0;\",128,0,0,0\n.stabs  \"_Float32:t(0,17)=r(0,1);4;0;\",128,0,0,0\n.stabs  \"ssize_t:t(4,17)=(4,8)\",128,0,0,0\n.stabs  \"off_t:t(4,18)=(4,8)\",128,0,0,0\n.stabn  162,0,0,0\n.stabn  162,0,0,0\n.section    .rodata.str1.1,\"aMS\",@progbits,1\n.LC0:\n.string \"entering test_backtrace %d\\n\"\n.LC1:\n.string \"leaving test_backtrace %d\\n\"\n.text\n.p2align 4,,15\n.stabs  \"test_backtrace:F(0,25)\",36,0,0,test_backtrace\n.stabs  \"x:P(0,1)\",64,0,0,3\n.globl  test_backtrace\n.type   test_backtrace, @function\ntest_backtrace:\n.stabn  68,0,13,.LM0-.LFBB1\n```\n\n- see if the bootloader loads the symbol table in memory as part of loading the kernel binary\n\n我们如何确认BootLoader加载内核的时候是否把符号表加载进内存呢？\n\n首先使用`objdump -x obj/kern/kernel`查看符号表（节选） 以及地址\n\n```\nf0101f18 l    d  .stab\t\t 00000000 .stab\nf010619d l    d  .stabstr\t\t 00000000 .stabstr\n\nProgram Header:\n    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12\n         filesz 0x00007af3 memsz 0x00007af3 flags r-x\n    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12\n         filesz 0x0000a948 memsz 0x0000a948 flags rw-\n```\n\n只要用gdb查看符号表的地址位置是否储存了符号表信息即可。\n\n```\n(gdb) x/8s 0x10619d      <---注意这个地址！因为这里我自己还没执行到entry.s的标记cr0地址映射\n0x10619d:\t\"\"\n0x10619e:\t\"{standard input}\"\n0x1061af:\t\"kern/entry.S\"\n0x1061bc:\t\"kern/entrypgdir.c\"\n0x1061ce:\t\"gcc2_compiled.\"\n0x1061dd:\t\"int:t(0,1)=r(0,1);-2147483648;2147483647;\"\n0x106207:\t\"char:t(0,2)=r(0,2);0;127;\"\n0x106221:\t\"long int:t(0,3)=r(0,3);-2147483648;2147483647;\"\n-----------------------------------------------------------------------------------\n为了不让大家产生误会：执行完entry.S再打印：\n(gdb) si\n=> 0x100025:\tmov    %eax,%cr0\n0x00100025 in ?? ()\n(gdb) si\n(gdb) x/8s 0xf010619d\n0xf010619d:\t\"\"\n0xf010619e:\t\"{standard input}\"\n0xf01061af:\t\"kern/entry.S\"\n0xf01061bc:\t\"kern/entrypgdir.c\"\n0xf01061ce:\t\"gcc2_compiled.\"\n0xf01061dd:\t\"int:t(0,1)=r(0,1);-2147483648;2147483647;\"\n0xf0106207:\t\"char:t(0,2)=r(0,2);0;127;\"\n0xf0106221:\t\"long int:t(0,3)=r(0,3);-2147483648;2147483647;\"\n```\n\n2. debuginfo_eip函数实现根据地址寻找行号的功能：\n\n熟悉stabs每行记录的含义，我折腾了一两小时才搞清楚。首先，使用`objdump -G obj/kern/kernel > output.md`将内核的符号表信息输出到output.md文件，在output.md文件中可以看到以下片段：\n\n```\nSymnum n_type n_othr n_desc n_value  n_strx String\n118    FUN    0      0      f01000a6 2987   i386_init:F(0,25)\n119    SLINE  0      24     00000000 0\n120    SLINE  0      34     00000012 0\n121    SLINE  0      36     00000017 0\n122    SLINE  0      39     0000002b 0\n123    SLINE  0      43     0000003a 0 \n```\n\n这个片段是什么意思呢？首先要理解第一行给出的每列字段的含义：\n\n- Symnum是符号索引，换句话说，整个符号表看作一个数组，Symnum是当前符号在数组中的下标\n- n_type是符号类型，FUN指函数名，SLINE指在text段中的行号\n- n_othr目前没被使用，其值固定为0\n- n_desc表示在文件中的行号\n- n_value表示地址。特别要注意的是，这里只有FUN类型的符号的地址是绝对地址，SLINE符号的地址是偏移量，其实际地址为函数入口地址加上偏移量。比如第3行的含义是地址f01000b8(=0xf01000a6+0x00000012)对应文件第34行。\n\n这样，调用stab_binsearch就可以找到某个地址对应的行号了，前面的代码已经找到地址在哪个函数里面以及函数入口地址，将原地址减去函数入口地址即可得到偏移量，再根据偏移量在符号表中的指定区间查找对应的记录即可：\n\n```c\n// Search the entire set of stabs for the source file (type N_SO).\n\tlfile = 0;\n\trfile = (stab_end - stabs) - 1;\n\tstab_binsearch(stabs, &lfile, &rfile, N_SO, addr);\n\tif (lfile == 0)\n\t\treturn -1;\n\n\t// Search within that file's stabs for the function definition\n\t// (N_FUN).\n\tlfun = lfile;\n\trfun = rfile;\n\tstab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);\n\n\tif (lfun <= rfun) {\n\t\t// stabs[lfun] points to the function name\n\t\t// in the string table, but check bounds just in case.\n\t\tif (stabs[lfun].n_strx < stabstr_end - stabstr)\n\t\t\tinfo->eip_fn_name = stabstr + stabs[lfun].n_strx;\n\t\tinfo->eip_fn_addr = stabs[lfun].n_value;\n\t\taddr -= info->eip_fn_addr;\n\t\t// Search within the function definition for the line number.\n\t\tlline = lfun;\n\t\trline = rfun;\n\t} else {\n\t\t// Couldn't find function stab!  Maybe we're in an assembly\n\t\t// file.  Search the whole file for the line number.\n\t\tinfo->eip_fn_addr = addr;\n\t\tlline = lfile;\n\t\trline = rfile;\n\t}\n```\n\n3. 给我们的内核模拟器增加backtrace命令。\n\n* `kern/monitor.c`文件中，仿照已有命令进行添加即可。\n\n```c\nstatic struct Command commands[] = {\n\t{ \"help\", \"Display this list of commands\", mon_help },\n\t{ \"kerninfo\", \"Display information about the kernel\", mon_kerninfo },\n\t{ \"backtrace\", \"Display a backtrace of the function stack\", mon_backtrace}\n};\n```\n\n* 给`mon_backtrace`增加打印文件名、函数名、行号功能。\n\n根据之前的源代码阅读，我们只需要调用`debugingo_eip`来获取文件名、函数名、行号。\n\n```c\nmon_backtrace(int argc, char **argv, struct Trapframe *tf)\n{\n\t// Your code here.\n\tuint32_t ebp = read_ebp();\n\tuint32_t eip;\n\tstruct Eipdebuginfo info;\n#define TO_INT(x) *((uint32_t *)(x))\n\twhile(ebp){\n\t\tcprintf(\"ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\\n\",\n\t\t\t\tTO_INT(ebp),\t\t /*ebp*/\n\t\t\t\tTO_INT((ebp + 4)),   /*eip*/\n\t\t\t\tTO_INT((ebp + 8)),   /*arg1*/\n\t\t\t\tTO_INT((ebp + 12)),  /*arg2*/\n\t\t\t\tTO_INT((ebp + 16)),  /*arg3*/\n\t\t\t\tTO_INT((ebp + 20)),  /*arg4*/\n\t\t\t\tTO_INT((ebp + 24))); /*arg5*/\n\t\teip = TO_INT((ebp + 4));\n\t\tdebuginfo_eip(eip, &info);\n\t\tcprintf(\"     %s:%d: %.*s+%d\\n\", info.eip_file, info.eip_line,\n\t\t\t\tinfo.eip_fn_namelen, info.eip_fn_name, eip - info.eip_fn_addr);\n\t\tebp = TO_INT(ebp);\n\t}\n\treturn 0;\n}\n```\n\n* 补充debuginfo_eip()：\n\n表示行号的成员是n_desc，所以缺失的代码如下：\n\n```c\n\t// Search within [lline, rline] for the line number stab.\n\t// If found, set info->eip_line to the right line number.\n\t// If not found, return -1.\n\t//\n\t// Hint:\n\t//\tThere's a particular stabs type used for line numbers.\n\t//\tLook at the STABS documentation and <inc/stab.h> to find\n\t//\twhich one.\n\t// Your code here.\n\tstab_binsearch(stabs, &lline, &rline, N_SLINE, addr);\n\tif (lline <= rline)\n\t{\n\t\tinfo->eip_line = stabs[lline].n_desc;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n```\n\n一切就绪后我们运行我们的monitor：\n\n![image-20200303233338466](https://tva1.sinaimg.cn/large/00831rSTly1gch5umxyf1j30fz07lmzg.jpg)\n\n大功告成，舒服了。\n\n\n\n## 感想\n\n不去做jos扬名立万，搁那儿画啥GUI？\n\n","tags":["operating system","lab"],"categories":["operating system"]},{"title":"Data Structure for Graphics","url":"/2019/07/31/FOCG-01/","content":"<script type=\"text/javascript\"\n   src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\">\n</script>\n# Data Structures for Graphics\n\n## 1 Triangle Meshes(三角网格)\n---\n\n*Triangle meshes are generally used to represent surfaces, so a mesh is not just a collection of unrelated triangles, but rather a network of triangles that connect to one another through shared vertices and edges to form a single continuous surface.*\n\n---\n\n### 1.1 Mesh Topology\n\n\n**manifold**: a surface in which a small neighborhood around any point could be smoothed out into a bit of ﬂat surface.\n> 表面上的任意一点的周围领域都可以平滑进入该表面\n\n**figures**    \n\n* Every edge is shared by exactly two triangles.    \n\n\n![figure1.1](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564538894/blog/figure1.1_ut9yft.jpg)\n> Non-manifold (left) and manifold (right) interior edges.\n\n* Every vertex has a single, complete loop of triangles around it.\n\n![figure1.2](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564538894/blog/figure1.2_iv5flz.jpg)\n> Non-manifold (left) and manifold (right) interior vertices.\n\n**direction**    \n\n* For a single triangle, we deﬁne orientation based on the order in which the vertices are listed: the front is the side from which the triangle’s three vertices are arranged in counterclockwise order.\n\n> 顶点顺序按照逆时针排列的三角形视为前面\n\n![orient](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564539441/blog/5ADF80BC-E440-48B1-AEFC-C3C2B4F3D249_ojbeph.jpg)\n\n> Triangles (B,A,C) and (D,C,A) are consistently oriented, whereas (B,A,C) and (A,C,D) are inconsistently oriented.    \n\n### 1.2 Indexed Mesh Storage        \n\n*The minimum information required for a triangle mesh is a set of triangles (triples of vertices) and the positions (in 3D space) of their vertices.*\n\n**Triangle-to-vertax** data structure\n\n```\nTriangle {\n\tVertex v[3]\n}\n\nVertex {\n\tvector3 position \n\t// or other vertex data\n}\n```\n![Triangle-to-vertax data structure](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564540141/blog/111aa_yth3n1.png)\n\n**Triangle-to-vertax shared vertex mesh** data structure\n\n```\nIndexedMesh {\n\tint tInd[nt][3]\n\tvector3 verts[nv] \n}\n```\n> `tInd[i][k]`: the index of *k*th vertice of *i*th triangle.     \n> `verts[nv]`: the position of `vertex[nv]`(sharing vertex)\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564540496/blog/WX20190731-103442_2x_wg6qe0.png)\n\n### 1.3 fans and strips \n\n**Triangle fan**\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564540922/blog/WX20190731-104150_2x_p7gn1m.png)\n\n> In an indexed mesh, the triangles array would contain [(0, 1, 2), (0, 2, 3), (0, 3, 4), (0, 4, 5)].    \n\nThe fan in the ﬁgure could be speciﬁed with the sequence `[0, 1, 2, 3, 4, 5]`: **the ﬁrst vertex establishes the center**, and subsequently each pair of adjacent vertices (1-2, 2-3, etc.).\n\n**Triangle strip**\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564541079/blog/WX20190731-104415_2x_uvquoc.png)\n\nThe triangle strip in the ﬁgure could be speciﬁed by the sequence `[0 1 2 3 4 5 6 7]`, and every subsequence of three adjacent vertices (0-1-2, 1-2-3, etc.).    \n\n**For consistent orientation, every other triangle needs to have its order reversed**. In the example, this results in the triangles (0, 1, 2), (2, 1, 3), (2, 3, 4), (4, 3, 5), etc.\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564541240/blog/WX20190731-104708_2x_q4ic3t.png)\n\n### 1.4 Mesh connectivity data structure\n*more complicated data structures are needed to efﬁciently answer queries such as:*   \n\n* Given a triangle, what are the three adjacent triangles?\n* Given an edge, which two triangles share it?\n* Given a vertex, which faces share it?\n* Given a vertex, which edges share it?\n\nimplementation like following:\n\n```\nTriangle {\n\tVertex v[3] \n\tEdge e[3] \n}\n\nEdge {\n\tVertex v[2] \n\tTriangle t[2]\n}\n\nVertex {\n\tTriangle t[]\n\tEdge e[]\n}\n```\n**1.4.1 The Triangle-Neighbor Structure:**\n\n```\nTriangle {\n\tTriangle nbr[3]; \n\tVertex v[3]; \n}\n\nVertex {\n\t// ... per-vertex data ... \n\tTriangle t; // any adjacent tri \n}\n```\n> notice that in the array Triangle.nbr, the **k**th entry points to the **neighboring triangle** that **shares vertices k and k + 1**\n\n```\nMesh { \n\t// ... per-vertex data ...\n\tint tInd[nt][3]; // vertex indices    \n\tint tNbr[nt][3]; // indices of neighbor triangles    \n\tint vTri[nv]; // index of any adjacent triangle\n}\n```\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564542561/blog/WX20190731-110903_2x_jajbdd.png)\n\n* feature:\n**If triangle t has vertex v as its kth vertex, then the triangle t.nbr[k] is the next triangle around v in the clockwise direction.**(用于计算三角形t对于某一个顶点v的最近邻接三角形t.nbr[k]，如图中绿色箭头)\n\ntraverse all the triangles adjacent to a given vertex(对于一个给定顶点，遍历该点所有邻接三角形)：\n\n```\nTrianglesOfVertex(v) {\n\tt = v.t\n\tdo {\n\t\tfind i such that (t.v[i] == v)\n\t\tt = t.nbr[i]\n\t} while (t != v.t)\n}\n```\n\n**1.4.2 winged-edge data structure**\n\nmakes edges the ﬁrst-class citizen of the data structure.    \n\neach edge stores pointers to the **two vertices it connects (the head and tail vertices)**, the **two faces it is part of (the left and right faces)**, and, most importantly, **the next and previous edges in the counterclockwise traversal of its left and right faces**. Each vertex and face also stores a pointer to a single, arbitrary edge that connects to it.\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564544627/blog/WX20190731-114329_2x_kguihc.png)\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564556779/blog/54B0707E-9E44-44BB-BD3E-7E3377A12021_vhougd.jpg)\n\n```\nEdge { \n\tEdge lprev, lnext, rprev, rnext;\n\tVertex head, tail;\n\tFace left, right;\n}\n\nFace {\n\t// ... per-face data ...\n\tEdge e; // any adjacent edge\n}\n\nVertex { \n\t// ... per-vertex data ... \n\tEdge e; // any incident edge \n}\n```\n\nThe winged-edge data structure supports constant-time access to the edges of a face or of a vertex:\n\n```\nEdgesOfVertex(v) {\n\te = v.e;\n\tdo { \n\t\tif (e.tail == v) \n\t\t\te = e.lprev; \n\t\telse \n\t\t\te = e.rprev; \n\t} while (e != v.e);\n}\n\nEdgesOfFace(f) {\n\te = f.e;\n\tdo { \n\t\tif (e.left == f) \n\t\t\te = e.lnext; \n\t\telse \n\t\t\te = e.rnext; \n\t} while (e != f.e);\n}\n```\n\n> 应注意的是，使用winged-edge进行搜索时，我们每次在移动到下一条边之前需要检查边的方向。\n\n**1.4.3 The Half-Edge Structure**\n\nEach half-edge **points to the face on its side of the edge** and to **the vertex at its head**, and each contains **the edge pointers for its face**. It also points to **its neighbor on the other side of the edge.\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564558625/blog/WX20190731-153648_2x_lixjc4.png)\n\n```\nHEdge {\n\tHEdge pair, next; \n\tVertex v; \n\tFace f;\n}\n\nFace { \n\t// ... per-face data ...\n\tHEdge h; // any h-edge of this face \n}\n\nVertex { \n\t// ... per-vertex data ...\n\tHEdge h; // any h-edge pointing toward this vertex\n}\n```\nWe no longer need to check orientation, and we follow the pair pointer to access the edges in the opposite face.\n\n```\nEdgesOfVertex(v) { \n\th = v.h; \n\tdo { \n\t\th = h.pair.next; \n\t} while (h != v.h); \n}\n\nEdgesOfFace(f) { \n\th = f.h; \n\tdo {\n\t\th = h.next; \n\t} while (h != f.h); \n}\n```\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564558839/blog/WX20190731-154026_2x_pgzvwd.png)\n\n## 2 Scene Graphs\n\n---\n\nMost scenes admit to a hierarchical organization, and the transformations can be managed according to this hierarchy using a scene graph.\n\n---\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564561356/blog/WX20190731-162207_2x_hillvh.png)\n\n> On the left are the two pieces in their “local” coordinate systems. The hinge of the bottom piece is at point b and the attachment for the bottom piece is at its local origin. The degrees of freedom for the assembled object are the angles (θ,φ) and the location p of the top hinge.\n\n* draw the top part of the pendulum\n\n$$M_1 = rotate(\\theta)$$\n\n$$M_2 = translate(\\mathsf{p})$$\n\n$$M_3 = M_1M_2$$\n\n* draw the bottom part of the pendulum\n\n$$M_a = rotate(\\phi)$$\n\n$$M_b = translate(\\mathsf{b})$$\n\n$$M_c = M_bM_a$$\n\n$$M_d = M_3M_c$$\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564562754/blog/WX20190731-164539_2x_fqvkyt.png)\n\n> The scene graph for the hinged pendulum\n\n## 3 Spatial Data Structures\n\n---\n\n*We will use ray tracing as the primary motivation while discussing these structures, though they can all also be used for view culling or collision detection.*\n> 主要用于光照检测 \n\n---\n\n### 3.1 Bounding Boxes\n\nThis differs from conventional intersection tests in that **we do not need to know where the ray hits the box; we only need to know whether it hits the box.**\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564564422/blog/WX20190731-171329_2x_b7emcm.png)\n\n> The ray is **only tested for intersection with the surfaces if it hits the bounding box**.\n\n#### 3.1.1 Bounding Boxes\n\n$$x = x_{min}$$\n\n$$x = x_{max}$$\n\n$$y = y_{min}$$\n\n$$y = y_{max}$$\n\nThe points bounded by these lines can be described in interval notation:\n\n$$(x,y) \\in [x_{min},x_{max}] \\times[y_{min},y_{max}]$$\n\nFor intersection test:\n\n* assume that the light source position $e(x_e, y_e)$\n* assume that the light source direction $d(x_d, y_d)$\n\nlight source: \n\n$$\\vec P = \\vec e + t\\vec d$$\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564565510/blog/WX20190731-173136_2x_tdkvuo.png)\n\n> The ray will be inside the interval $x \\in [x_{min} , x_{max} ]$ for some interval in its parameter space $t \\in [t_ {xmin} , t_{xmax} ]$ . A similar interval exists for the y interval. **The ray intersects the box if it is in both the x interval and y interval at the same time**, i.e., the intersection of the two one-dimensional intervals is not empty.\n\n**Three possibilities for hitting test:**\n\n* $x_e \\leq x_{min}$ (no hit)\n* $x_{min} < x_e < x_{max}$ (hit)\n* $x_{max} < x_e$ (no hit)\n\n**Final code of hitting test:**\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564623288/blog/WX20190801-093429_2x_kopleh.png)\n\n### 3.1.2 Hierarchical Bounding Boxes\n\n![](https://res.cloudinary.com/dg6z7pidk/image/upload/v1564623700/blog/WX20190801-094129_2x_om2f8r.png)\n\n> The bounding boxes can be nested by creating boxes around subsets of the model.\n\n","tags":["Fundamentals of Computer Graphics"],"categories":["图形学基础"]},{"title":"MAC_MASM","url":"/2019/03/19/MAC-MASM/"},{"title":"LLDB简易指南","url":"/2019/03/14/lldb/","content":"# 关于LLDB\nLLDB is a next generation, high-performance debugger. It is built as a set of reusable components which highly leverage existing libraries in the larger LLVM Project, such as the Clang expression parser and LLVM disassembler.    \n\nLLDB is the default debugger in Xcode on Mac OS X and supports debugging C, Objective-C and C++ on the desktop and iOS devices and simulator.    \n\n# 教程\n\n## 调试可执行文件\n假设编译文件main.c:   \n \n```c\ngcc main.c -g -o debug.run\n```\n   \n> 必须 -g 才可以使用lldb指令查看代码\n  \n对可执行文件进行调试:    \n\n```c    \nlldb debug.run\n```\n\n如果可执行文件是带参数的，那就写入参数，比如：     \n\n```c   \nlldb -- debug.run 1 2 3\n```\n\n> debug.run是编译出来的可执行文件\n\n## 调试正在运行的进程\n***进程标识符pid：***    \n在计算机领域，进程标识符`pid`(process identifier)是大多数操作系统的内核用于唯一标识一个进程的数值。    \n\n***进程的状态：***    \n1.*R* 运行   \n2.*S* 中断（休眠中、受阻、在等待某个条件的形成或接收到信号）   \n3.*D* 不可中断    \n4.*Z* 僵死（进程终止，但进程描述符存在，直到父进程调用wait4()系统调用后释放）   \n5.*T* 停止（收到SIGSTOP、SIGSTP、SIGTIN、SIGTOU等信号后停止运行）      \n   \n\n***进程查看器 ps命令：***      \nps命令是最基本的进程查看命令。使用该命令可以确定有哪些进程正在运行以及运行的状态等等。    \n一般使用\n```\nps -aux | grep\n```\n查找特定进程，如\n```\nps aux | grep chuqiz\n```\n查找我的用户名进行的进程\n\n### 1. 启动lldb\n\n终端输入\n```\nlldb\n```\n\n### 2. 挂载进程的pid\n```\nprocess attach --pid xxxxxx\n```\n(xxxxxx为进程的pid)    \n同时也可以挂载到进程的名下：    \n```\nprocess attacj --name Safari\n```\n简写：\n```\npro att -n Safari\n```\n## 使用lldb看代码\n只有在之前编译选项带-g时才可以通过命令查看代码。    \n\n### 1. 使用list查看代码\n在lldb下输入`list` 或者`l` \n输入\n```\nl row\n```\n表示从第row行开始往下看      \n> 每次list只能查看10行代码，继续往下查看只需要继续输入list就可以     \n\n### 2. 查看其他文件代码\n如果程序编译的时候是由很多文件组成的，那么只需要\n```\nlist fileName\n```\n就可以查看其他文件的代码，以后再list时就是查看设置的fileName的代码。比如\n```\nlist CNFClause.c\n```\n### 3. 查看某函数的代码\n直接输入待查看函数的名字即可\n```\nlist funcName\n```\n比如: \n```\nlist deepCpyClause\n```\n     \n```\n(lldb) list deepCpyClause   \nFile: /Users/chuqiz/2018/CourseDesign/DPLL2/CourseDesign/DataStructure/CNFClause.c    \n   22  \t//    cls -> literals = (int *)malloc(sizeof(int) * literalNum) ;    \n   23  \t//    memcpy(cls -> literals, literals, literalNum * sizeof(int)) ;\n   24  \t//    return cls ;\n   25  \t//}\n   26\n   27  \tclause deepCpyClause(clause aclause){\n   28  \t//    int literalNum = aclause -> literalCount ;\n   29  \t//    ClauseStatus clsStatus = aclause -> clauseStatus ;\n   30  \t//    int * literals = (int *)malloc(sizeof(int) * literalNum) ;\n   31  \t//    memcpy(literals, aclause -> literals, literalNum * sizeof(int)) ;\n   32  \t//    clause cls = createClause(literalNum, literals) ;\n(lldb) list\n   33  \t    clause cpyCls = NULL ;\n   34  \t    initClause(&cpyCls) ;\n   35  \t    while (aclause) {\n   36  \t        addLiteral(&cpyCls, aclause -> literal) ;\n   37  \t        aclause = aclause -> next ;\n   38  \t    }\n   39  \t    return cpyCls ;\n   40  \t}\n```\n## 打断点\n让lldb调试器挂载进程显示代码以后，其余的步骤就是找地方下断点然后让程序运行。    \n\n### 1. 根据文件名和行号下断点\n\n```\n(lldb) breakpoint set --file main.c --line 27\nBreakpoint 1: where = CourseDesign`main + 22 at main.c:27, address = 0x0000000100001d16\n```\n\n### 2. 根据函数名下断点\n\n```\n(lldb) breakpoint set --name functionName           //C 函数\n(lldb) breakpoint set --method foo                  //C++ 类方法\n(lldb) breakpoint set --selector msgNameWithArg:    //Objective-C 选择器\n```\n\n### 3. 根据某个函数调用语句下断点(Objective-C常用)\n```\nbreakpoint set -n \"-[UIView viewDidLoad:]\"\n```\n\n### 4.设置命令别名化简指令\n命令: \n```\n(lldb)breakpoint set --file main.c --line 27\n```\n化简: \n```\n(lldb)command alias bfl breakpoint set -f %1 -l %2\n```\n使用:\n```\n(lldb)bfl main.c 27\n```\n\n### 5. 查看断点列表、禁用/启用断点、删除断点\n***查看断点列表：***`(lldb) breakpoint list`\n\n```\n(lldb) breakpoint list\nCurrent breakpoints:\n1: file = 'main.c', line = 27, exact_match = 0, locations = 1\n  1.1: where = CourseDesign`main + 22 at main.c:27, address = CourseDesign[0x0000000100001d16], unresolved, hit count = 0\n\n2: name = 'deepCpyClause', locations = 1\n  2.1: where = CourseDesign`deepCpyClause + 16 at CNFClause.c:33, address = CourseDesign[0x0000000100000ab0], unresolved, hit count = 0\n\n3: name = 'deepCpyFormula', locations = 0 (pending)\n\n4: name = 'addClause', locations = 1\n  4.1: where = CourseDesign`addClause + 16 at CNFFormula.c:45, address = CourseDesign[0x00000001000024d0], unresolved, hit count = 0\n```\n> 可以看出使用指令查看断点列表，会根据下断点的顺序给断点自动编号。只需要操作对应的编号即可处理相应的断点（禁用/启用，删除）   \n\n***禁用断点：***`(lldb) breakpoint disable x`（x为禁用的断点序号）   \n\n```\n(lldb) breakpoint disable 2\n1 breakpoints disabled.\n(lldb) breakpoint list\nCurrent breakpoints:\n1: file = 'main.c', line = 27, exact_match = 0, locations = 1\n  1.1: where = CourseDesign`main + 22 at main.c:27, address = CourseDesign[0x0000000100001d16], unresolved, hit count = 0\n\n2: name = 'deepCpyClause', locations = 1 Options: disabled\n  2.1: where = CourseDesign`deepCpyClause + 16 at CNFClause.c:33, address = CourseDesign[0x0000000100000ab0], unresolved, hit count = 0\n\n3: name = 'deepCpyFormula', locations = 0 (pending)\n\n4: name = 'addClause', locations = 1\n  4.1: where = CourseDesign`addClause + 16 at CNFFormula.c:45, address = CourseDesign[0x00000001000024d0], unresolved, hit count = 0\n\n```\n> 注意到刚才disable编号为2的断点，再次list断点列表，2号断点显示options为disabled\n\n***启用断点：***`(lldb) breakpoint enable x` (x为启用的断点编号)    \n\n```\n(lldb) breakpoint enable 2\n1 breakpoints enabled.\n(lldb) breakpoint list\nCurrent breakpoints:\n1: file = 'main.c', line = 27, exact_match = 0, locations = 1\n  1.1: where = CourseDesign`main + 22 at main.c:27, address = CourseDesign[0x0000000100001d16], unresolved, hit count = 0\n\n2: name = 'deepCpyClause', locations = 1\n  2.1: where = CourseDesign`deepCpyClause + 16 at CNFClause.c:33, address = CourseDesign[0x0000000100000ab0], unresolved, hit count = 0\n\n3: name = 'deepCpyFormula', locations = 0 (pending)\n\n4: name = 'addClause', locations = 1\n  4.1: where = CourseDesign`addClause + 16 at CNFFormula.c:45, address = CourseDesign[0x00000001000024d0], unresolved, hit count = 0\n```\n\n***删除断点：***`(lldb breakpoint delete x)` (x为删除的断点编号)    \n\n```\n(lldb) breakpoint delete 2\n1 breakpoints deleted; 0 breakpoint locations disabled.\n(lldb) breakpoint list\nCurrent breakpoints:\n1: file = 'main.c', line = 27, exact_match = 0, locations = 1\n  1.1: where = CourseDesign`main + 22 at main.c:27, address = CourseDesign[0x0000000100001d16], unresolved, hit count = 0\n\n3: name = 'deepCpyFormula', locations = 0 (pending)\n\n4: name = 'addClause', locations = 1\n  4.1: where = CourseDesign`addClause + 16 at CNFFormula.c:45, address = CourseDesign[0x00000001000024d0], unresolved, hit count = 0\n```\n> 再次list断点列表可以发现，编号为2的断点已经被删除\n\n## 运行环境操作\n### 1. 启动\n`(lldb) run`即为启动命令，(详情见上述 “调试”)，程序会运行到断点处停下。\n\n```\n(lldb) run\nProcess 42740 launched: '/Users/chuqiz/2018/CourseDesign/DPLL2/CourseDesign/CourseDesign' (x86_64)\nProcess 42740 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x0000000100001d16 CourseDesign`main(argc=1, argv=0x00007ffeefbff808) at main.c:27\n   24  \tint b[9][10] = {0} ;\n   25\n   26  \tint main(int argc, const char * argv[]) {\n-> 27  \t    showModule() ;\n   28  \t    return 0;\n   29  \t}\nTarget 0: (CourseDesign) stopped.\n```\n\n### 2. 下一步、步入、步出、继续执行\n\n```\n下一步：(lldb) next/n\n步入： (lldb) step/s\n步出： (lldb) finish\n继续执行： (lldb)continue        //会在下一个断点处停下\n```\n\n### 3. 查看变量\n```\npo allLiteralArr       //po一般输出指针指向的对象\np allLiteralArr        //p一般输出基础变量\n(普通数组两者都可使用)\n```","tags":["工具"],"categories":["工具"]},{"title":"Electra越狱下的iOS11配置debugserver+lldb","url":"/2019/03/14/debugserver-1/","content":"# Electra越狱下的iOS11配置debugserver+lldb\n\ndebugserver实际执行lldb（作为客户端）传过来的命令，再将执行结果反馈给lldb最终显示给用户。（来自小黄书第二版）\n\n### 配置debugserver\n***1.帮debugserver减肥***    \n\n将未经处理的debugserver从iOS拷贝到OSX中。\n首先通过ssh连接设备，查看`/Developer/usr/bin/debugserver`是否存在。**如果不存在：**    \n\n* 在OSX设备上运行Xcode\n* 为iOS打开一个objc项目\n* 将iOS设备通过usb连接并且加载项目\n\n再次检查`/Developer/usr/bin/debugserver`，此时该二进制文件应该存在。\n\niOS11不需要减肥，因为只支持64位架构的程序。\n    \n***2.添加task_for_pid权限***    \n \n下载[ent.xml](http://iosre.com/ent.xml)到保存debugserver的目录下，cd到该目录，执行命令    \n`/opt/theos/bin/ldid -Sent.xml debugserver`\n     \n***3.将处理的debugserver拷贝回iOS***\n\n使用ssh连接设备。    \n`scp debugserver root@localhost:/usr/bin/debugserver`    \n`ssh root@localhost`\n`iceGrave:~ root# chmod +x /usr/bin/debugserver`\n\n**如果运行debugserver报错killed 9：**    \n编辑之前的xml，添加key`platform-application`为true\n\n### 使用debugserver启动或者附加进程\n* 启动进程：    \n`debugserver -x backboard IP:port /path/to/executable`\n\n> debugserver会启动executable，并且开启port端口，等待来自IP的lldb接入\n\n* 附加进程：    \n`debugserver IP:port -a \"ProcessName\"`\n\n> debugserver会附加ProcessName，并开启port端口，等待来自IP的lldb接入","tags":["iosre","工具"],"categories":["工具"]},{"title":"CNCC2018随笔","url":"/2018/10/26/DO/","content":"# Digital Object & The Internet\n\n## Abstract （About） \n\n* **Evolving the Internet to facilitate management of digital information**\n\n\t- Over both short and very long time frames\n\t- With simplicity of Design \n\t- Open Architecture*\n\t- Independence form underlying technology(独立于底层技术)\n\n> **Open Architecture**:    \n> This is a type of computer architecture of software architecture intended to make adding, upgrading, and swapping components easy.    \n> 具有应用系统的可移植性和可裁剪性、网络上各节点机间的可操作性和易于多方获得软件的体系结构。    \n> 可移植性：各种计算机应用系统可以在具有开放结构性的各种计算机系统间进行移植。    \n> 可互操作性：计算机网络中的各节点都具有开放结构的特性。(可以互相操作和资源共享，不论各节点机是否是同种机型和机器)    \n> 易获得性：在具有开放结构性的机器上运行的软件环境易于从多方获得、不受某个来源所限制\n\n* **Focus on the Digital Object Architecture**\n\n\t- Goals \n\t- Basic componments & protocols\n\t- Implementations, reference software and applications\n\nKeywords: Digital Object, identfier, Digital Object Architecture\n> 几十年前，互联网是将各种物体连接在一起，处理各种数据包，以及实现计算机的互动。现如今，我们更多处理的是信息，即Digital Object。\n\n## What is Internet \n**Original FNC Definition**: global information system that makes use of IP, TCP.    \n\n**Key Attributes**:    \n- Designed to move bits from one computer to another.   \n- In a packet network environment consisting of mutiple networks and computers of different kinds.    \n- Open Architecture and Scalable over time.    \n- Non-Proprietary Architecture.  \n> 互联网的最早的设计初衷是将位元从一台机器移动到另一台机器。这些协议以及架构更加接近于独立的网络和计算机?\n\n##Some About DOA\n\n**Digital Object Architecture** as a logical extension of the Internet - with same properties of simplicity, scalability, open architecture and non-proprietary.\n\nSome Properties:\n\n- enables interoperability of such heterogeneous information systems with integrated security based on use of public key infrastructure.\n\n> 基于公开密钥的使用，这种异构信息系统具有集成安全性的互操作性。\n\n- lower the barriers to managing digital information in the internet - long & short term.\n\nAssume:\n\n- Assumes that many different kinds of information systems will exist over time. Some old, some new and changing dynamically.\n\n> DOA架构的主要动力：新旧的信息系统一直在动态变化。\n                                                                                                                                                                                                                                                    \n### Components & Protocols of the DOA\n* **Three basic components**:\n\t* DO Repositories that store DOs and from which they can be accessed via their identifier.\n\t* DO Registers that store metadata about individual DOs and which can be used to search.                                                                                                                                                                                                                                        \n\t* An identifier/resolution system that maps given identifiers to information helpful in accessing the DOs they identify - known as state information.\n\n> 调用储存库时，通过object的identifier访问他们。任何DO只要通过独特的标识符，便可以与其他的DO区分开来，方便储存查找以及管理。    \n> state information:状态信息是一种identifier/解析 系统，可以将给定的identifier映射到能够帮助访问DO的信息。    \n> 通过identifier，可以在任何时候访问这些信息。\n\n*KEYWORD: Identifier*\n\n* **Two Protocols**:\n\t* Digital Object Identifier Protocol(DOIP)\n\t* Identifier/Resolution Protocol\n\n### Digital Object Identifier\n\nIn computing, a Digital Object Identifier or DOI is a persistent identifier or handle used to uniquely identify objects.\n\n> 一套识别数字资源的机制，涵盖的对象有视频、报告或书籍等等。它既有一套为资源命名的机制，也有一套将识别解析为具体地址的协议。    \n> 发展动机：在于补充统一资源标志符的不足，URI指涉的URL经常会变动，而且URI表达的其实是资源所在地(网址)，而不是数字资源本身的信息。    \n> 一个DOI经过解析以后，可以连至一个或者更多的数据。但是identifier本身与解析之后所导向的数据并不相关(也可能无法获取全部的数据)\n\nA Digital Object Identifier has the form of prefix/suffix.\n> DOI码由前缀和后缀两部分组成。前缀再以`.`符号分割成两部分，如：10.1000/182\n\n","tags":["随笔"]},{"title":"iOS开发架构以及OC基础知识","url":"/2018/04/26/article1/","content":"# iOS开发架构\n### 框架层(应用程序层级结构)\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/001.png)\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/002.png)\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/003.png)\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/004.png)\n### 平台组件\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/005.png)\n### 设计模式\n![](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/006.png)\n# 初步了解OBJC-Runtime&@property\n\n## RunTime(待填坑)\n### 一、简介\nObjective-C 语言是一门动态语言，是扩充C语言的面向对象的语言。其在C语言的基础上增加了一层很小的面向对象语法并且完全兼容C语言。  \n\n+ OC是一门动态语言，他在运行过程中处理很多静态语言在编译与链接时做的事\n+ Runtime库使得C语言有面向对象的能力\n+ OBJC调用对象方法的过程基于Runtime\n\n> 在Runtime中，C语言中的`结构体`可以表示成`对象`，而`方法`则可以通过C语言的函数实现。\n\n当程序执行`[Object doSomeThing]`时，会动态向`object`发送一条`doSomeThing`信息，Runtime根据消息接受着是否能相应该消息而做出反应。\n\n### 二、底层结构\nObjective-C类通过Class类型表示，实际上是一个指向`objc_class`结构体的指针。  \n\n```\ntypedef struct object_class * Class\n```\n查看objc_class结构体：\n\n```\nstruct objective_class{\n\t Class isa OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n\t Class super_class                        OBJC2_UNAVAILABLE;  // 父类，如果该类是最顶层根类，则它为NULL\n     const char *name                         OBJC2_UNAVAILABLE;  // 类名\n     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0\n     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识\n     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小\n     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表\n     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表\n     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存\n     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表\n#endif\n}OBJC2_UNAVAILABLE;\n```\n\n其中的成员变量列表以及方法列表：\n\n```\n// 成员变量列表\nstruct objc_ivar_list {\n    int ivar_count                                           OBJC2_UNAVAILABLE;\n#ifdef __LP64__\n    int space                                                OBJC2_UNAVAILABLE;\n#endif\n    /* variable length structure */\n    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;\n}                                                            OBJC2_UNAVAILABLE;\n\n// 方法列表\nstruct objc_method_list {\n    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;\n\n    int method_count                                         OBJC2_UNAVAILABLE;\n#ifdef __LP64__\n    int space                                                OBJC2_UNAVAILABLE;\n#endif\n    /* variable length structure */\n    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;\n}\n```\n\n### objc_object\n\nobjc_object是表示一个类的实例的结构体：\n\n```\nstruct objc_object{\n     Class isa OBJC_ISA_AVAILABILITY;\n};\ntypedef struct objc_object *id;\n```\n\n+ isa指针  \n\n**在Objective-C中，任何类的定义都是对象。类和类的实例（对象）没有本质区别，任何一个对象都有isa指针。**  \nisa指针是一个Class类型指针，指向对象的类，Class中也有一个isa指针，指向meteClass(元类)。**元类保存了类方法的列表。**\n> 类方法调用过程：1.从本身查找 2.向父类查找  \n\n元类也是类，也是类对象。元类的isa指针指向**根元类(root meteClass)**。根元类的isa对象指向**本身**，形成封闭内循环。\n\n![Underlying structure](https://github.com/Icegrave0391/Icegrave0391.github.io/blob/master/ref_img/1.png)\n\n### Category\nCategory表示一个指向分类的结构体的指针。\n\n```\ntypedef struct objc_category *Category\nstruct objc_category{\n     char *category_name                         OBJC2_UNAVAILABLE; // 分类名\n     char *class_name                            OBJC2_UNAVAILABLE;  // 分类所属的类名\n     struct objc_method_list *instance_methods   OBJC2_UNAVAILABLE;  // 实例方法列表\n     struct objc_method_list *class_methods      OBJC2_UNAVAILABLE; // 类方法列表\n     struct objc_protocol_list *protocols        OBJC2_UNAVAILABLE; // 分类所实现的协议列表\n}\n```\n该结构体主要包含分类的实例方法与类方法。\n> instance_methods是objc_class中方法列表的一个子集  \n> class_method是元类方法列表的一个子集  \n\n**分类中没有ivar成员变量指针，因此分类中不能添加实例变量和属性。**  \n\n\n### objc_ivar\n\nOC中类和对象的实例变量，实际上就是一个指向objc_ivar的结构体指针ivar\n\n```\ntypedef struct objc_ivar * Ivar ;\n```\n\n在Runtime机制中，通过runtime方法`class_copyIvarList`可以获取一个指向类和对象所有实例变量的Ivar类型指针。  \n获取到Ivar类型指针后，可以通过`ivar_getName`方法获取该实例变量的名称并由C语言字符串表示。\n> 由于笔者能力有限，此处不再展示示例。\n\n### 属性\n\nOC中类和对象的属性@property，是一个指向`objc_property`的结构体指针`objc_property_t`。\n\n```\ntypedef struct objc_property *objc_property_t ;\n```\n\n同理，runtime方法`class_copyPropertyList`可以获取一个指向类和对象所有属性的`objc_property_t`类型指针。  \n获取到`objc_property_t`类型指针之后，通过runtime方法`property_getName`可以获取属性名称。\n> 由于笔者能力有限，此处仍然没有示例\n\n### 方法\nOC中类和对象的方法，是一个指向objc_method的结构体指针Method。\n\n```\ntypedef struct objc_method *Method ;\n```\n\n通过runtime方法`class_copyMehtodLists`可以获取一个指向类和对象所有方法的Method类型指针。  \n获取到Method类型指针之后，通过method_getName方法获取方法名称。\n> 依然没有示例 \n\n### * Method Swizzling\n在runtime中，可以通过修改一个已经存在的类方法，实现方法的替换。\n**网上抄的demo:**  \nUIView的load方法中:  \n\n```\n+ (void)load {\n     Method origin = class_getInstanceMethod([UIView class], @selector(touchesBegan:withEvent:));\n     Method custom = class_getInstanceMethod([UIView class], @selector(custom_touchesBegan:withEvent:));\n     method_exchangeImplementations(origin, custom);\n}\n- (void)custom_touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n     // TODO\n}\n```\n\n这样触发UIView的`touchesBegan:withEvent:`方法时，实际调用了自定义方法`custom_touchesBegan:withEvent:`方法。\n\n### 关联对象\n\n上文`objc_class`结构体中，我们可以看出，通过动态修改 `* methodList`的值添加成员方法，同样这也是Category实现原理。但是分类中没有`ivar`成员变量类型指针，这就说明分类中不能够添加实例变量和属性。\n> 这个也解释了Category不能添加属性的原因。对于分类的详解请参考:[深入理解Objective-C: Category](https://tech.meituan.com/DiveIntoCategory.html)。\n\n关于Category无法向现有的类添加属性，可以使用runtime风的关联对象(associated objdects)实现。\n\n**有待补充**\n\n---\n## @Property(基础使用)\n\n[Apple官方在 Adopting Modern Objective-C](https://developer.apple.com/library/content/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html) 提及现代化的OC写法，其中就讲到尽量使用@property属性: \n\nProperties capture the state of an object. They reflect the object’s intrinsic attributes and relationships to other objects. Properties provide a safe, convenient way to interact with these attributes without having to write a set of custom accessor methods (although properties do allow custom getters and setters, if desired).\n\nUsing properties instead of instance variables in as many places as possible provides many benefits:\n\n+ **Autosynthesized getters and setters**. When you declare a property. by default getter and setter methods are created for you.\n+ **Better declaration of intent of a set of methods.** Because of accessor method naming conventions, it's clear exactly what the getter and setter are doing.\n+ **Property keywords that express additional information about behavior.** Properties provide the potential for declaration of attributes like `assign` (vs`copy`),`weak`, `atomic`(vs`nonatomic`), and so on\n\n**对于属性自动合成的setter和getter方法命名以及使用等基本内容，不再赘述。**\n### @property指示符\n常用指示符有：  \n\n+ `nonatomic` `atomic`\n+ `strong` `weak`\n+ `readwrite` `readonly`\n+ `assign`\n+ `copy`\n+ `unsafe_unretained`\n+ `retain`\n\n### atomaic/nonatomic\n\n该指示符指定合成的存取方法是否为原子操作，与线程安全有关。(待)  \n但几乎所有代码的属性设置都会使用`nonatomic`，这样能提高访问性能。\n\n### readonly/readwrite\n编译器合成的默认选项时`readwrite`，即自动生成getter以及setter。  \n`readonly`表示只合成`getter`而不合成`setter`。\n\n### assign\n`assign`表示不更改对属性所赋值的引用计数，只进行简单的赋值操作，同时也不改变旧值的引用计数。  \n通常`assign`常用标量类型，如`NSInteger``NSUInteger``CGFloat``NSTimeInterval`。  \n`assign`其实也可以修饰对象(比如`NSString`)，但是该修饰符不会改变所赋新值的引用计数以及旧值的引用计数，如果新值对象引用计数为0而被销毁时属性并不知道，编译器也不会将该属性值设为`nil`，这样指针仍然会指向被销毁的内存，访问该属性就会出现悬挂指针，导致程序崩溃。\n\n```\n#import <Foundation/Foundation.h>\n\n@interface Person : NSObject\n\n@property(nonatomic, assign) NSUInteger age ;\n@property(nonatomic, assign) NSString * name ;\n\n\n@end\n@implementation Person\n\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person * aPerson = [[Person alloc] init] ;\n        NSMutableString * name = [[NSMutableString alloc] initWithString:@\"Chuqi Zhang\"] ;\n        \n        //设置属性仅仅是将name的地址赋给aPerson.name\n        aPerson.name = name ;\n        \n        //输出两变量内存地址 ，一致\n        NSLog(@\"%p %p\",aPerson.name , name) ;\n        NSLog(@\"%@ %lu\",aPerson.name , (unsigned long)aPerson.age) ;\n        \n        //将name置空，引用计数为0，对象被销毁\n        name = nil ;\n        //地址仍然指向该内存，但是访问会崩溃\n        NSLog(@\"%p\",aPerson.name) ;\n    }\n    return 0;\n}\n```\n\n### strong/weak\n\n`strong`表示属性对所赋的值持有强引用，表示拥有关系(owning relationship)，使用该指示符，会先保留新值(增加新值的引用计数)，然后释放旧值(减少旧值引用计数)。该修饰符只能修饰对象，即对对象持有一种强引用。  \n\n`weak`表示属性对所赋的对象持有一种弱引用，表示非拥有关系(nonowning relationship)，对新值不会增加引用计数，也不会减少旧值的引用计数。所赋的值在引用计数为0被销毁以后，该修饰符修饰的属性会自动设置成`nil`，有效防止悬挂指针问题。\n\n使用`strong`:\n\n```\n#import <Foundation/Foundation.h>\n\n@interface Person : NSObject\n//使用强引用\n@property(nonatomic, strong) NSString * name ;\n@end\n@implementation Person\n\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person * aPerson = [[Person alloc] init] ;\n        NSMutableString * name = [[NSMutableString alloc] initWithString:@\"Chuqi Zhang\"] ;\n        //将name地址赋给property，aPerson.name持有强引用\n        aPerson.name = name ;\n        //两地址相同\n        NSLog(@\"%p %p\",aPerson.name , name) ;\n        //将name置空\n        name = nil ;\n        NSLog(@\"%@ %@ %p %p\",aPerson.name, name,aPerson.name , name) ;\n    }\n    \n    //最终输出结果：aPerson.name地址和值并没有改变,name地址变为0X0，值为(null)，即引用保留。\n    return 0;\n}\n\n```\n### copy\n`copy`修饰符修饰的属性会在内存中拷贝一份对象，两个指针指向不同地址。  \n该修饰符通常用来修改**有对应 可变类型子类 的对象**。如:`NSString/NSMutableString` `NSArray/NSMutableArray` 以及 `NSDictionary/NSMutableDictionary` 等。  \n使用`copy`修饰符进行备份，可防止对象由于可变类型子类影响，防止属性值被修改。  \n\n使用strong导致属性可能被修改:\n\n```\n@interface Person : NSObject\n@property(nonatomic, strong) NSString * name ;\n@end\n@implementation Person\n@end\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        Person * aPerson = [[Person alloc] init] ;\n        NSMutableString * name = [[NSMutableString alloc] initWithString:@\"Chuqi Zhang\"] ;\n        //将name地址赋值给aPerson.name\n        aPerson.name = name ;\n    \t//修改name\n        [name appendString:@\"hi\"] ;\n        //aPerson.name也会随之改变\n        NSLog(@\"%@\",aPerson.name) ;\n    }\n    return 0;\n}\n```\n`Foundation`框架提供的所有类都实现了`NSCopying`协议，使用`copy`都会返回一个不可变对象，因此属性如果为可变对象类别(如`NSMutableString`)就不能够使用`copy`修饰符修饰，应该用`strong`，这样会得到一个不可变的对象。\n\n## @Property(深入)\n\n### 关于copy\n","tags":["iOS"],"categories":["iOS"]},{"title":"Hello World","url":"/2018/04/03/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]